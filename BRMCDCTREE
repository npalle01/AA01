#!/usr/bin/env python

import sys
import sqlite3
import logging
import json
import math
import re
from datetime import datetime
from collections import deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QTimer
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QFormLayout, QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QInputDialog, QDockWidget,
    QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView, QPlainTextEdit,
    QSplitter, QCheckBox
)
import pyqtgraph as pg

# For ODBC support
try:
    import pyodbc
except ImportError:
    pyodbc = None

logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

# Global flag to indicate if using ODBC
USE_ODBC = False

# Default SQLite URI (in‑memory)
DB_URI = "file::memory:?cache=shared"

# Helper functions for ODBC row conversion
def get_cursor_rows(cursor):
    rows = cursor.fetchall()
    if USE_ODBC and rows:
        cols = [col[0] for col in cursor.description]
        return [dict(zip(cols, row)) for row in rows]
    return rows

def get_cursor_one(cursor):
    row = cursor.fetchone()
    if USE_ODBC and row is not None:
        cols = [col[0] for col in cursor.description]
        return dict(zip(cols, row))
    return row

# Connection selection: SQLite In‑Memory or ODBC
def get_connection():
    global USE_ODBC
    options = ("SQLite In-Memory", "ODBC")
    item, ok = QInputDialog.getItem(None, "Select Connection", "Connection Type:", options, 0, False)
    if not ok:
        sys.exit(0)
    if item == "SQLite In-Memory":
        USE_ODBC = False
        return setup_in_memory_db()
    else:
        if pyodbc is None:
            QMessageBox.critical(None, "ODBC Error", "pyodbc module is not installed.")
            sys.exit(1)
        conn_str, ok = QInputDialog.getText(None, "ODBC Connection", "Enter ODBC connection string:")
        if not ok or not conn_str:
            sys.exit(0)
        try:
            USE_ODBC = True
            conn = pyodbc.connect(conn_str)
            return conn
        except Exception as e:
            QMessageBox.critical(None, "ODBC Error", f"Failed to connect via ODBC: {str(e)}")
            sys.exit(1)

# Setup for SQLite (creates tables with UNIQUE constraint to prevent duplicate rule names within a business group)
def setup_in_memory_db():
    conn = sqlite3.connect(DB_URI, uri=True, timeout=10.0)
    try:
        conn.execute("PRAGMA foreign_keys = ON;")
    except:
        pass
    conn.row_factory = sqlite3.Row
    conn.execute("""
    CREATE TABLE IF NOT EXISTS USERS(
        USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        USERNAME TEXT UNIQUE NOT NULL,
        PASSWORD TEXT NOT NULL,
        USER_GROUP TEXT NOT NULL,
        FOREIGN KEY(USER_GROUP) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE RESTRICT
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUPS(
        GROUP_NAME TEXT PRIMARY KEY,
        DESCRIPTION TEXT,
        EMAIL TEXT
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS GROUP_PERMISSIONS(
        GROUP_NAME TEXT NOT NULL,
        TARGET_TABLE TEXT NOT NULL,
        PRIMARY KEY(GROUP_NAME, TARGET_TABLE),
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TYPES(
        RULE_TYPE_ID INTEGER PRIMARY KEY,
        RULE_TYPE_NAME TEXT NOT NULL UNIQUE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_GROUPS(
        GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT UNIQUE NOT NULL,
        DESCRIPTION TEXT
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULES(
        RULE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_ID INTEGER,
        PARENT_RULE_ID INTEGER,
        RULE_TYPE_ID INTEGER NOT NULL,
        RULE_NAME TEXT NOT NULL,
        RULE_SQL TEXT NOT NULL,
        EFFECTIVE_START_DATE TEXT NOT NULL,
        EFFECTIVE_END_DATE TEXT,
        STATUS TEXT NOT NULL CHECK (STATUS IN ('ACTIVE','INACTIVE')),
        VERSION INTEGER NOT NULL DEFAULT 1,
        CREATED_BY TEXT NOT NULL,
        DESCRIPTION TEXT,
        OPERATION_TYPE TEXT,
        BUSINESS_JUSTIFICATION TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        UPDATED_BY TEXT,
        OWNER_GROUP TEXT NOT NULL,
        CLUSTER_NAME TEXT,
        APPROVAL_STATUS TEXT NOT NULL DEFAULT 'DRAFT',
        IS_GLOBAL INTEGER NOT NULL DEFAULT 0,
        CRITICAL_RULE INTEGER NOT NULL DEFAULT 0,
        CRITICAL_SCOPE TEXT NOT NULL DEFAULT 'NONE',
        CDC_TYPE TEXT NOT NULL DEFAULT 'NONE',
        FOREIGN KEY(RULE_TYPE_ID) REFERENCES BRM_RULE_TYPES(RULE_TYPE_ID),
        FOREIGN KEY(PARENT_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_ID) REFERENCES BRM_RULE_GROUPS(GROUP_ID) ON DELETE SET NULL,
        UNIQUE (OWNER_GROUP, RULE_NAME)
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TABLE_DEPENDENCIES(
        DEPENDENCY_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        DATABASE_NAME TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_AUDIT_LOG(
        AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        ACTION TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        RECORD_ID TEXT NOT NULL,
        ACTION_BY TEXT NOT NULL,
        OLD_DATA TEXT,
        NEW_DATA TEXT,
        ACTION_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_LINEAGE(
        LINEAGE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_INFO TEXT,
        TARGET_INFO TEXT,
        TRANSFORMATION_DETAILS TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_COLUMN_MAPPING(
        MAPPING_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_RULE_ID INTEGER NOT NULL,
        SOURCE_COLUMN_NAME TEXT NOT NULL,
        TARGET_COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(SOURCE_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_RULE_GROUPS(
        CUSTOM_GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_NAME TEXT NOT NULL UNIQUE,
        OWNER_BUSINESS_GROUP TEXT NOT NULL,
        CREATED_BY TEXT NOT NULL,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_MEMBERS(
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        RULE_ID INTEGER NOT NULL,
        PRIMARY KEY(CUSTOM_GROUP_ID, RULE_ID),
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUP_APPROVERS(
        APPROVER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_APPROVALS(
        RULE_ID INTEGER NOT NULL,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        APPROVED_FLAG INTEGER NOT NULL DEFAULT 0,
        APPROVED_TIMESTAMP DATETIME,
        APPROVAL_STAGE INTEGER NOT NULL DEFAULT 1,
        PRIMARY KEY(RULE_ID, GROUP_NAME, USERNAME),
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GLOBAL_CRITICAL_LINKS(
        LINK_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GCR_RULE_ID INTEGER NOT NULL,
        TARGET_RULE_ID INTEGER,
        TARGET_GROUP_ID INTEGER,
        FOREIGN KEY(GCR_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(TARGET_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    groups = [
        ("Admin", "Admin group", "admin@example.com"),
        ("BG1", "Group1", "bg1@example.com"),
        ("BG2", "Group2", "bg2@example.com"),
        ("BG3", "Group3", "bg3@example.com")
    ]
    for g in groups:
        conn.execute("INSERT OR IGNORE INTO BUSINESS_GROUPS(GROUP_NAME, DESCRIPTION, EMAIL) VALUES(?,?,?)", g)
    users = [
        ("admin", "admin", "Admin"),
        ("bg1_user", "user", "BG1"),
        ("bg2_user", "user", "BG2"),
        ("bg3_user", "user", "BG3")
    ]
    for u in users:
        conn.execute("INSERT OR IGNORE INTO USERS(USERNAME, PASSWORD, USER_GROUP) VALUES(?,?,?)", u)
    perms = [
        ("Admin", "TABLE_A"), ("Admin", "TABLE_B"), ("Admin", "TABLE_C"), ("Admin", "TABLE_D"),
        ("BG1", "TABLE_A"), ("BG1", "TABLE_B"), ("BG2", "TABLE_C"), ("BG3", "TABLE_D")
    ]
    for p in perms:
        conn.execute("INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME, TARGET_TABLE) VALUES(?,?)", p)
    conn.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID, RULE_TYPE_NAME) VALUES(1,'DQ')")
    conn.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID, RULE_TYPE_NAME) VALUES(2,'DM')")
    rule_groups = [
        ("Finance Rules", "Rules related to financial data"),
        ("HR Rules", "Rules related to human resources")
    ]
    for rg in rule_groups:
        conn.execute("INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME, DESCRIPTION) VALUES(?,?)", rg)
    conn.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES('BG1','bg1_user')")
    conn.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES('BG2','bg2_user')")
    conn.execute("INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME, USERNAME) VALUES('BG3','bg3_user')")
    conn.commit()
    return conn

# Enhanced duplicate check in add_rule (for same business group and rule name)
def add_rule(conn, rule_data, created_by, user_group):
    c = conn.cursor()
    grp_id = rule_data.get("GROUP_ID")
    if grp_id is not None:
        c.execute("SELECT GROUP_ID FROM BRM_RULE_GROUPS WHERE GROUP_ID=?", (grp_id,))
        if not get_cursor_one(c):
            raise ValueError(f"GROUP_ID {grp_id} not found in BRM_RULE_GROUPS.")
    p_id = rule_data.get("PARENT_RULE_ID")
    if p_id is not None:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_ID=?", (p_id,))
        if p_id and not get_cursor_one(c):
            raise ValueError(f"PARENT_RULE_ID {p_id} not found in BRM_RULES.")
    # Check duplicate: same rule name for same business group
    owner_grp = rule_data["OWNER_GROUP"]
    rule_name = rule_data["RULE_NAME"]
    c.execute("SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=? AND RULE_NAME=?", (owner_grp, rule_name))
    if get_cursor_one(c):
        raise ValueError(f"A rule named '{rule_name}' already exists in business group '{owner_grp}'.")
    is_global = rule_data.get("IS_GLOBAL", 0)
    if is_global == 1 and user_group != "Admin":
        raise ValueError("Only Admin can create a global rule.")
    c.execute("""
      INSERT INTO BRM_RULES(
        GROUP_ID, PARENT_RULE_ID, RULE_TYPE_ID, RULE_NAME, RULE_SQL,
        EFFECTIVE_START_DATE, EFFECTIVE_END_DATE, STATUS, VERSION,
        CREATED_BY, DESCRIPTION, OPERATION_TYPE, BUSINESS_JUSTIFICATION,
        OWNER_GROUP, APPROVAL_STATUS, IS_GLOBAL, CRITICAL_RULE, CRITICAL_SCOPE,
        CDC_TYPE
      ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """, (
      rule_data.get("GROUP_ID"),
      rule_data.get("PARENT_RULE_ID"),
      rule_data["RULE_TYPE_ID"],
      rule_data["RULE_NAME"],
      rule_data["RULE_SQL"],
      rule_data["EFFECTIVE_START_DATE"],
      rule_data.get("EFFECTIVE_END_DATE"),
      "INACTIVE",
      1,
      created_by,
      rule_data.get("DESCRIPTION"),
      rule_data.get("OPERATION_TYPE"),
      rule_data.get("BUSINESS_JUSTIFICATION", ""),
      rule_data["OWNER_GROUP"],
      "APPROVAL_IN_PROGRESS",
      is_global,
      rule_data.get("CRITICAL_RULE", 0),
      rule_data.get("CRITICAL_SCOPE", "NONE"),
      rule_data.get("CDC_TYPE", "NONE")
    ))
    new_id = c.lastrowid
    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn, tbn) in deps:
        c.execute("""
          INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
          VALUES(?,?,?,?)
        """, (new_id, dbn, tbn, "DerivedCol"))
    add_audit_log(conn, "INSERT", "BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()
    if is_global == 1:
        logger.info(f"Global rule {new_id}, skipping approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)
    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    old_data = dict(old)
    new_grp_id = rule_data.get("GROUP_ID", old["GROUP_ID"])
    if new_grp_id is not None:
        c.execute("SELECT GROUP_ID FROM BRM_RULE_GROUPS WHERE GROUP_ID=?", (new_grp_id,))
        if not get_cursor_one(c):
            raise ValueError(f"GROUP_ID {new_grp_id} not found in BRM_RULE_GROUPS.")
    new_par_id = rule_data.get("PARENT_RULE_ID", old["PARENT_RULE_ID"])
    if new_par_id is not None:
        c.execute("SELECT RULE_ID FROM BRM_RULES WHERE RULE_ID=?", (new_par_id,))
        if new_par_id and not get_cursor_one(c):
            raise ValueError(f"PARENT_RULE_ID {new_par_id} not found in BRM_RULES.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can update a global rule.")
    if rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]) == 1 and user_group != "Admin":
        raise ValueError("Only Admin can set a rule global.")
    c.execute("""
      UPDATE BRM_RULES
      SET
        GROUP_ID=?,
        PARENT_RULE_ID=?,
        RULE_TYPE_ID=?,
        RULE_NAME=?,
        RULE_SQL=?,
        EFFECTIVE_START_DATE=?,
        EFFECTIVE_END_DATE=?,
        STATUS='INACTIVE',
        VERSION=VERSION+1,
        UPDATED_BY=?,
        DESCRIPTION=?,
        OPERATION_TYPE=?,
        BUSINESS_JUSTIFICATION=?,
        OWNER_GROUP=?,
        APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
        IS_GLOBAL=?,
        CRITICAL_RULE=?,
        CRITICAL_SCOPE=?,
        CDC_TYPE=?
      WHERE RULE_ID=?
    """, (
      new_grp_id,
      new_par_id,
      rule_data["RULE_TYPE_ID"],
      rule_data["RULE_NAME"],
      rule_data["RULE_SQL"],
      rule_data["EFFECTIVE_START_DATE"],
      rule_data.get("EFFECTIVE_END_DATE"),
      updated_by,
      rule_data.get("DESCRIPTION"),
      rule_data.get("OPERATION_TYPE"),
      rule_data.get("BUSINESS_JUSTIFICATION", ""),
      rule_data["OWNER_GROUP"],
      rule_data.get("IS_GLOBAL", old["IS_GLOBAL"]),
      rule_data.get("CRITICAL_RULE", old["CRITICAL_RULE"]),
      rule_data.get("CRITICAL_SCOPE", old["CRITICAL_SCOPE"]),
      rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
      rule_data["RULE_ID"]
    ))
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?", (rule_data["RULE_ID"],))
    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn, tbn) in deps:
        c.execute("""
          INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME)
          VALUES(?,?,?,?)
        """, (rule_data["RULE_ID"], dbn, tbn, "DerivedCol"))
    new_data = dict(old_data)
    for k, v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "UPDATE", "BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()
    if old["IS_GLOBAL"] == 1 or rule_data.get("IS_GLOBAL", 0) == 1:
        logger.info(f"Global rule {rule_data['RULE_ID']} updated => skip approvals.")
    else:
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?", (rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot deactivate unless fully APPROVED.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can deactivate a global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules must be deactivated first.")
    old_data = dict(old)
    c.execute("""
      UPDATE BRM_RULES
      SET STATUS='INACTIVE', UPDATED_BY=?, VERSION=VERSION+1
      WHERE RULE_ID=?
    """, (updated_by, rule_id))
    new_data = dict(old_data)
    new_data["STATUS"] = "INACTIVE"
    new_data["VERSION"] = old["VERSION"] + 1
    add_audit_log(conn, "DEACTIVATE", "BRM_RULES", rule_id, updated_by, old_data, new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    old = get_cursor_one(c)
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"] == 1 and user_group != "Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old["APPROVAL_STATUS"] != "APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"] != "INACTIVE":
        raise ValueError("Must be INACTIVE first.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?", (rule_id,))
    kids = get_cursor_rows(c)
    if kids:
        raise ValueError("Child rules exist.")
    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?", (rule_id, rule_id))
    leftover = get_cursor_rows(c)
    if leftover:
        raise ValueError("Remove or re-map column references first.")
    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?", (rule_id,))
    add_audit_log(conn, "DELETE", "BRM_RULES", rule_id, action_by, old_data, None)
    conn.commit()

class LoginDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.setFixedSize(300,200)
        layout = QVBoxLayout(self)
        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)
        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)
        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)
        self.setLayout(layout)
    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?", (usern, passw))
        row = get_cursor_one(c)
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

class RuleEditorDialog(QDialog):
    def __init__(self, connection, rule_types, logged_in_user, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_types = rule_types
        self.logged_in_user = logged_in_user
        self.rule_data = rule_data
        ttl = "Edit Rule" if rule_data else "Add New Rule"
        self.setWindowTitle(ttl)
        self.resize(900,500)
        main_layout = QHBoxLayout(self)
        left_box = QGroupBox("Basic Info")
        left_layout = QFormLayout(left_box)
        self.group_combo = QComboBox()
        self.group_combo.addItem("None", None)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID, GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
            for row in get_cursor_rows(c):
                self.group_combo.addItem(row["GROUP_NAME"], row["GROUP_ID"])
        except:
            pass
        left_layout.addRow("Rule Group:", self.group_combo)
        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("None", None)
        try:
            c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES WHERE STATUS='ACTIVE'")
            for row in get_cursor_rows(c):
                self.parent_rule_combo.addItem(f"{row['RULE_NAME']} (ID:{row['RULE_ID']})", row["RULE_ID"])
        except:
            pass
        left_layout.addRow("Parent Rule:", self.parent_rule_combo)
        self.name_edit = QLineEdit()
        left_layout.addRow("Rule Name:", self.name_edit)
        self.type_combo = QComboBox()
        for rt in self.rule_types:
            self.type_combo.addItem(rt)
        left_layout.addRow("Rule Type:", self.type_combo)
        self.status_combo = QComboBox()
        self.status_combo.addItems(["ACTIVE", "INACTIVE"])
        left_layout.addRow("Status:", self.status_combo)
        self.start_dt = QDateTimeEdit(QtCore.QDateTime.currentDateTime())
        self.start_dt.setCalendarPopup(True)
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("Start Date:", self.start_dt)
        self.end_dt = QDateTimeEdit(QtCore.QDateTime.currentDateTime().addDays(30))
        self.end_dt.setCalendarPopup(True)
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("End Date:", self.end_dt)
        self.owner_grp_combo = QComboBox()
        try:
            c.execute("SELECT DISTINCT GROUP_NAME FROM GROUP_PERMISSIONS ORDER BY GROUP_NAME")
            for g in get_cursor_rows(c):
                self.owner_grp_combo.addItem(g["GROUP_NAME"], g["GROUP_NAME"])
        except:
            pass
        left_layout.addRow("Owner Group:", self.owner_grp_combo)
        self.global_checkbox = None
        if self.logged_in_user == "Admin":
            self.global_checkbox = QCheckBox("Global (admin-only)")
            left_layout.addRow("Global:", self.global_checkbox)
        self.critical_checkbox = QCheckBox("Critical (Stop-on-fail)")
        left_layout.addRow("Critical Rule:", self.critical_checkbox)
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE", "GROUP", "CLUSTER", "GLOBAL"])
        left_layout.addRow("Critical Scope:", self.scope_combo)
        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE", "FULL_LOAD", "INCREMENTAL", "INSERT_ONLY", "UPSERT"])
        left_layout.addRow("CDC Type:", self.cdc_combo)
        main_layout.addWidget(left_box)
        right_box = QGroupBox("Details & Logic")
        right_layout = QFormLayout(right_box)
        self.sql_editor = QPlainTextEdit()
        font = QtGui.QFont("Courier", 10)
        self.sql_editor.setFont(font)
        right_layout.addRow(QLabel("Rule SQL:"), self.sql_editor)
        self.description_edit = QTextEdit()
        right_layout.addRow(QLabel("Description:"), self.description_edit)
        self.justification_edit = QTextEdit()
        right_layout.addRow(QLabel("Justification:"), self.justification_edit)
        btn_box = QHBoxLayout()
        self.save_btn = QPushButton("Save" if self.rule_data else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_box.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(cancel_btn)
        right_layout.addRow(btn_box)
        main_layout.addWidget(right_box)
        self.setLayout(main_layout)
        if self.rule_data:
            self.load_rule_data(self.rule_data)
    def load_rule_data(self, rd):
        if rd["GROUP_ID"]:
            idx = self.group_combo.findData(rd["GROUP_ID"])
            if idx >= 0:
                self.group_combo.setCurrentIndex(idx)
        if rd["PARENT_RULE_ID"]:
            idx2 = self.parent_rule_combo.findData(rd["PARENT_RULE_ID"])
            if idx2 >= 0:
                self.parent_rule_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd["RULE_NAME"])
        for nm, tid in self.rule_types.items():
            if tid == rd["RULE_TYPE_ID"]:
                i_ = self.type_combo.findText(nm)
                if i_ >= 0:
                    self.type_combo.setCurrentIndex(i_)
                break
        s_ = self.status_combo.findText(rd["STATUS"])
        if s_ >= 0:
            self.status_combo.setCurrentIndex(s_)
        try:
            sdt = datetime.strptime(rd["EFFECTIVE_START_DATE"], "%Y-%m-%d %H:%M:%S")
            self.start_dt.setDateTime(QtCore.QDateTime(sdt))
        except:
            pass
        if rd["EFFECTIVE_END_DATE"]:
            try:
                edt = datetime.strptime(rd["EFFECTIVE_END_DATE"], "%Y-%m-%d %H:%M:%S")
                self.end_dt.setDateTime(QtCore.QDateTime(edt))
            except:
                pass
        og = rd["OWNER_GROUP"]
        i_og = self.owner_grp_combo.findText(og)
        if i_og >= 0:
            self.owner_grp_combo.setCurrentIndex(i_og)
        self.sql_editor.setPlainText(rd["RULE_SQL"] or "")
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])
        if self.global_checkbox and rd.get("IS_GLOBAL", 0) == 1:
            self.global_checkbox.setChecked(True)
        if rd.get("CRITICAL_RULE", 0) == 1:
            self.critical_checkbox.setChecked(True)
        sc_val = rd.get("CRITICAL_SCOPE", "NONE").upper()
        i_sc = self.scope_combo.findText(sc_val)
        if i_sc >= 0:
            self.scope_combo.setCurrentIndex(i_sc)
        cdc_val = rd.get("CDC_TYPE", "NONE").upper()
        i_cdc = self.cdc_combo.findText(cdc_val)
        if i_cdc >= 0:
            self.cdc_combo.setCurrentIndex(i_cdc)
    def on_save(self):
        if not self.name_edit.text().strip():
            QMessageBox.warning(self, "Error", "Name is empty.")
            return
        sql_text = self.sql_editor.toPlainText().strip()
        if not sql_text:
            QMessageBox.warning(self, "Error", "SQL is empty.")
            return
        op_type = get_op_type_from_sql(sql_text)
        rule_dict = {
            "GROUP_ID": self.group_combo.currentData(),
            "PARENT_RULE_ID": self.parent_rule_combo.currentData(),
            "RULE_TYPE_ID": self.rule_types.get(self.type_combo.currentText()),
            "RULE_NAME": self.name_edit.text().strip(),
            "RULE_SQL": sql_text,
            "EFFECTIVE_START_DATE": self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "EFFECTIVE_END_DATE": self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "STATUS": self.status_combo.currentText(),
            "DESCRIPTION": self.description_edit.toPlainText().strip(),
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": self.justification_edit.toPlainText().strip(),
            "OWNER_GROUP": self.owner_grp_combo.currentText().strip(),
            "IS_GLOBAL": 1 if (self.global_checkbox and self.global_checkbox.isChecked()) else 0,
            "CRITICAL_RULE": 1 if self.critical_checkbox.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper(),
            "CDC_TYPE": self.cdc_combo.currentText().upper()
        }
        created_by = self.logged_in_user
        if self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self, "Confirm", "Update rule?")
            if confirm != QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self, "Success", "Rule updated. Approval re-initiated.")
                self.accept()
            except Exception as e:
                QMessageBox.critical(self, "DB Error", str(e))
        else:
            confirm = QMessageBox.question(self, "Confirm", "Add new rule?")
            if confirm != QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self, "Success", f"Rule created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as e:
                QMessageBox.critical(self, "DB Error", str(e))

class RuleAnalyticsDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Rule Analytics")
        self.resize(800,600)
        layout = QVBoxLayout(self)
        chart_hbox = QHBoxLayout()
        self.bar_chart = pg.PlotWidget(title="Number of Rules by Creator")
        self.bar_chart.setBackground('w')
        chart_hbox.addWidget(self.bar_chart)
        self.pie_chart = pg.PlotWidget(title="Rule Status Distribution")
        self.pie_chart.setBackground('w')
        chart_hbox.addWidget(self.pie_chart)
        layout.addLayout(chart_hbox)
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)
        self.load_charts()
    def load_charts(self):
        c = self.connection.cursor()
        c.execute("SELECT CREATED_BY, COUNT(*) as cnt FROM BRM_RULES GROUP BY CREATED_BY")
        creators_data = get_cursor_rows(c)
        creators = {row["CREATED_BY"]: row["cnt"] for row in creators_data}
        status_counts = {"ACTIVE": 0, "INACTIVE": 0, "DELETED": 0}
        c.execute("SELECT STATUS, COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        for row in get_cursor_rows(c):
            su = row["STATUS"].upper()
            if su in status_counts:
                status_counts[su] = row["sc"]
        c.execute("SELECT COUNT(*) as delcnt FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'")
        row2 = get_cursor_one(c)
        if row2:
            status_counts["DELETED"] = row2["delcnt"]
        self.bar_chart.clear()
        if creators:
            sorted_creators = sorted(creators.items(), key=lambda x: x[1], reverse=True)
            names = [sc[0] for sc in sorted_creators]
            vals = [sc[1] for sc in sorted_creators]
            bar_item = pg.BarGraphItem(x=range(len(names)), height=vals, width=0.6, brush="skyblue")
            self.bar_chart.addItem(bar_item)
            ax = self.bar_chart.getAxis("bottom")
            ax.setTicks([list(zip(range(len(names)), names))])
            self.bar_chart.setLabel("left", "Number of Rules")
            self.bar_chart.setLabel("bottom", "Created By")
            self.bar_chart.showGrid(x=True, y=True)
        self.pie_chart.clear()
        total = sum(status_counts.values())
        if total > 0:
            angles = [360*(v/total) for v in status_counts.values()]
            start = 90
            color_map = {"ACTIVE": "green", "INACTIVE": "red", "DELETED": "gray"}
            scene = self.pie_chart.scene()
            if not scene:
                scene = QtWidgets.QGraphicsScene()
                self.pie_chart.setScene(scene)
            keys = list(status_counts.keys())
            for i, ang in enumerate(angles):
                k = keys[i]
                if ang > 0:
                    wedge = QtGui.QPainterPath()
                    wedge.moveTo(0,0)
                    wedge.arcTo(-100, -100, 200, 200, start, ang)
                    wedge.closeSubpath()
                    brush = QtGui.QBrush(QtGui.QColor(color_map.get(k, "blue")))
                    path_item = pg.QtWidgets.QGraphicsPathItem(wedge)
                    path_item.setBrush(brush)
                    path_item.setPen(pg.mkPen("black"))
                    scene.addItem(path_item)
                    mid = start + (ang/2)
                    rad = (mid * math.pi) / 180
                    xx = 50 * math.cos(rad)
                    yy = 50 * math.sin(rad)
                    perc = math.floor((ang/360)*100)
                    lab = pg.TextItem(f"{k} ({perc}%)", anchor=(0.5,0.5))
                    lab.setPos(xx, yy)
                    scene.addItem(lab)
                    start += ang
            self.pie_chart.setAspectLocked(True)

class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs")
        self.resize(800,600)
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by Action, Table, or Action By...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)
        self.audit_table = QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels(["Audit ID", "Action", "Table Name", "Record ID", "Action By", "Old Data", "New Data", "Timestamp"])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.audit_table)
        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_logs()
    def load_logs(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT AUDIT_ID, ACTION, TABLE_NAME, RECORD_ID, ACTION_BY, OLD_DATA, NEW_DATA, ACTION_TIMESTAMP
          FROM BRM_AUDIT_LOG
          ORDER BY ACTION_TIMESTAMP DESC
          LIMIT 1000
        """)
        rows = get_cursor_rows(c)
        self.audit_table.setRowCount(0)
        for row in rows:
            r = self.audit_table.rowCount()
            self.audit_table.insertRow(r)
            self.audit_table.setItem(r,0, QTableWidgetItem(str(row["AUDIT_ID"])))
            self.audit_table.setItem(r,1, QTableWidgetItem(row["ACTION"]))
            self.audit_table.setItem(r,2, QTableWidgetItem(row["TABLE_NAME"]))
            self.audit_table.setItem(r,3, QTableWidgetItem(row["RECORD_ID"]))
            self.audit_table.setItem(r,4, QTableWidgetItem(row["ACTION_BY"]))
            old_txt = ""
            if row["OLD_DATA"]:
                try:
                    parsed = json.loads(row["OLD_DATA"])
                    old_txt = json.dumps(parsed, indent=2)
                except:
                    old_txt = row["OLD_DATA"]
            self.audit_table.setItem(r,5, QTableWidgetItem(old_txt))
            new_txt = ""
            if row["NEW_DATA"]:
                try:
                    parsed = json.loads(row["NEW_DATA"])
                    new_txt = json.dumps(parsed, indent=2)
                except:
                    new_txt = row["NEW_DATA"]
            self.audit_table.setItem(r,6, QTableWidgetItem(new_txt))
            self.audit_table.setItem(r,7, QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))
    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            match = False
            for col in (1,2,4):
                it = self.audit_table.item(row, col)
                if it and txt_l in it.text().lower():
                    match = True
                    break
            self.audit_table.setRowHidden(row, not match)

class SearchRuleDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules")
        self.resize(800,600)
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        layout.addLayout(top_h)
        self.res_table = QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID", "Name", "SQL", "Status", "Version", "Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.res_table)
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_results()
    def load_results(self):
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            c.execute("""
              SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
              FROM BRM_RULES
              WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
              ORDER BY RULE_ID DESC
              LIMIT 1000
            """, (f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, CREATED_BY
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
              LIMIT 1000
            """)
        rows = get_cursor_rows(c)
        self.res_table.setRowCount(0)
        for row in rows:
            r = self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r,0, QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r,1, QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r,2, QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r,3, QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r,4, QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r,5, QTableWidgetItem(row["CREATED_BY"]))

class BusinessRuleManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        layout = QVBoxLayout(self)
        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        btn_h.addWidget(add_btn)
        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        btn_h.addWidget(upd_btn)
        deact_btn = QPushButton("Deactivate Selected")
        deact_btn.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(deact_btn)
        del_btn = QPushButton("Delete Rule")
        del_btn.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(del_btn)
        aud_btn = QPushButton("View Audit Logs")
        aud_btn.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_btn)
        srch_btn = QPushButton("Search Rules")
        srch_btn.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        layout.addWidget(self.rule_dash)
        layout.addStretch()
        self.setLayout(layout)
    def on_add_rule(self):
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()
    def on_update_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self, "No Selection", "Select a rule to update.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rid,))
        row = get_cursor_one(c)
        if not row:
            QMessageBox.warning(self, "Not Found", "No rule with that ID.")
            return
        data = dict(row)
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, data, self)
        if dlg.exec_() == QDialog.Accepted:
            self.rule_dash.load_rules()
    def on_deactivate_rules(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None Selected", "No rules selected.")
            return
        success = 0
        fails = []
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success += 1
            except Exception as e:
                fails.append(f"Rule {rr}: {str(e)}")
        msg = f"Deactivation done. Success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Deactivate", msg)
        self.rule_dash.load_rules()
    def on_delete_rule(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self, "None Selected", "No rule(s) selected.")
            return
        confirm = QMessageBox.question(self, "Confirm", f"Delete {len(rids)} rule(s)?")
        if confirm != QMessageBox.Yes:
            return
        success = 0
        fails = []
        for rid in rids:
            try:
                delete_rule(self.connection, rid, self.user_group, self.user_group)
                success += 1
            except Exception as e:
                fails.append(f"Rule {rid}: {str(e)}")
        msg = f"Deletion done. Success={success}"
        if fails:
            msg += "\nFails:\n" + "\n".join(fails)
        QMessageBox.information(self, "Delete", msg)
        self.rule_dash.load_rules()

class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1
        layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        self.status_filter = QComboBox()
        self.status_filter.addItem("All Statuses", None)
        self.status_filter.addItem("ACTIVE", "ACTIVE")
        self.status_filter.addItem("INACTIVE", "INACTIVE")
        self.status_filter.addItem("DELETED", "DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        layout.addLayout(top_h)
        self.rule_table = QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID", "Name", "SQL", "Status", "Version", "Owner Group", "Created Timestamp", "Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        layout.addWidget(self.rule_table)
        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        layout.addLayout(nav_h)
        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)
        run_etl_btn = QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)
        analytics_btn = QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics_popup)
        btn_h.addWidget(analytics_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)
        self.setLayout(layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.load_rules()
    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"ETL Finished.\nExecuted: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self, "ETL", msg)
        self.load_rules()
    def show_analytics_popup(self):
        dlg = RuleAnalyticsDialog(self.connection, self)
        dlg.exec_()
    def build_filter_query(self):
        f = []
        p = []
        txt = self.search_edit.text().strip()
        if txt:
            f.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            p.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            if st.upper() == "DELETED":
                f.append("RULE_ID IN (SELECT RECORD_ID FROM BRM_AUDIT_LOG WHERE ACTION='DELETE')")
            else:
                f.append("STATUS=?")
                p.append(st)
        clause = " AND ".join(f) if f else "1"
        return clause, p
    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()
        c.execute(f"SELECT COUNT(*) as ccount FROM BRM_RULES WHERE {clause}", params)
        rowc = get_cursor_one(c)
        total = rowc["ccount"] if rowc else 0
        self.total_pages = max(1, math.ceil(total / self.records_per_page))
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        elif self.current_page < 1:
            self.current_page = 1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")
        offset = (self.current_page - 1) * self.records_per_page
        c.execute(f"""
          SELECT RULE_ID, RULE_NAME, RULE_SQL, STATUS, VERSION, OWNER_GROUP, CREATED_TIMESTAMP, APPROVAL_STATUS
          FROM BRM_RULES
          WHERE {clause}
          ORDER BY RULE_ID DESC
          LIMIT ? OFFSET ?
        """, (*params, self.records_per_page, offset))
        rows = get_cursor_rows(c)
        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r,0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r,1, QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r,2, QTableWidgetItem(rd["RULE_SQL"]))
            sitem = QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"].lower() == "active":
                sitem.setBackground(QColor(144,238,144))
            else:
                sitem.setBackground(QColor(255,182,193))
            self.rule_table.setItem(r,3, sitem)
            self.rule_table.setItem(r,4, QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r,5, QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r,6, QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r,7, QTableWidgetItem(rd["APPROVAL_STATUS"]))
    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id = None
            return
        row = sel[0].row()
        it = self.rule_table.item(row, 0)
        self.selected_rule_id = int(it.text()) if it else None
    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        ret = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row, 0)
            if it:
                ret.append(int(it.text()))
        return ret
    def prev_page(self):
        if self.current_page > 1:
            self.current_page -= 1
            self.load_rules()
    def next_page(self):
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.load_rules()

class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
        self.node_map = {}
        self.children_map = {}
        self.parents_map = {}
        self.detail_dock = QDockWidget("Rule Details", self.parentWidget())
        self.detail_panel = QTextEdit()
        self.detail_panel.setReadOnly(True)
        self.detail_dock.setWidget(self.detail_panel)
        self.detail_dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        mw = self.find_main_window()
        if mw:
            mw.addDockWidget(Qt.RightDockWidgetArea, self.detail_dock)
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)
        self.populate_graph()
    def find_main_window(self):
        w = self.parent()
        while w:
            if isinstance(w, QMainWindow):
                return w
            w = w.parent()
        return None
    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()
        c = self.connection.cursor()
        c.execute("""
          SELECT RULE_ID, RULE_NAME, PARENT_RULE_ID, STATUS, RULE_TYPE_ID,
                 CLUSTER_NAME, IS_GLOBAL, CRITICAL_RULE
          FROM BRM_RULES
          ORDER BY RULE_ID
        """)
        rules = get_cursor_rows(c)
        if not rules:
            self.scene.addItem(QtWidgets.QGraphicsTextItem("No rules found."))
            return
        for r in rules:
            rid = r["RULE_ID"]
            pid = r["PARENT_RULE_ID"]
            if pid:
                self.children_map.setdefault(pid, []).append(rid)
                self.parents_map[rid] = pid
        rule_lookup = {r["RULE_ID"]: r for r in rules}
        roots = [r["RULE_ID"] for r in rules if not r["PARENT_RULE_ID"]]
        queue = deque()
        level_map = {}
        visited = set()
        for rt in roots:
            queue.append((rt, 0))
        while queue:
            (rid, depth) = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            rinfo = rule_lookup[rid]
            c_so_far = level_map.get(depth, 0)
            level_map[depth] = c_so_far + 1
            x = depth * 220
            y = c_so_far * 120
            node_item = self.create_node(rinfo)
            node_item.setPos(x, y)
            self.scene.addItem(node_item)
            self.node_map[rid] = node_item
            if rid in self.children_map:
                for ch in self.children_map[rid]:
                    queue.append((ch, depth+1))
        for r in rules:
            pid = r["PARENT_RULE_ID"]
            rid = r["RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(pid, rid)
        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()
    def create_node(self, rinfo):
        rtype = rinfo["RULE_TYPE_ID"]
        status = rinfo["STATUS"]
        cluster = rinfo.get("CLUSTER_NAME", "")
        isg = rinfo["IS_GLOBAL"]
        icrit = rinfo["CRITICAL_RULE"]
        if rtype == 1:
            node = RuleRectItem(0, 0, 120, 50, rinfo, cluster)
        else:
            node = RuleEllipseItem(0, 0, 120, 50, rinfo, cluster)
        basecol = QtGui.QColor("lightgreen") if status.lower() == "active" else QtGui.QColor("tomato")
        if cluster:
            hval = abs(hash(cluster)) % 360
            basecol = QtGui.QColor.fromHsv(hval, 128, 255)
        node.setBrush(QtGui.QBrush(basecol))
        pen = QtGui.QPen(QtCore.Qt.black, 2)
        if icrit == 1:
            pen = QtGui.QPen(QtGui.QColor("red"), 3)
        node.setPen(pen)
        if isg == 1:
            rinfo["RULE_NAME"] = f"(G) {rinfo['RULE_NAME']}"
        return node
    def draw_edge(self, parent_id, child_id):
        p_item = self.node_map[parent_id]
        c_item = self.node_map[child_id]
        p_center = p_item.sceneBoundingRect().center()
        c_center = c_item.sceneBoundingRect().center()
        line = QtWidgets.QGraphicsLineItem(p_center.x(), p_center.y(), c_center.x(), c_center.y())
        line.setPen(QtGui.QPen(QtGui.QColor("darkblue"), 2))
        self.scene.addItem(line)
    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.pos())
            if isinstance(item, (RuleRectItem, RuleEllipseItem)):
                self.show_rule_details(item.rule_data)
        super().mousePressEvent(event)
    def show_rule_details(self, rinfo):
        msg = (
            f"Rule ID: {rinfo['RULE_ID']}\n"
            f"Name: {rinfo['RULE_NAME']}\n"
            f"Status: {rinfo['STATUS']}\n"
            f"Type ID: {rinfo['RULE_TYPE_ID']}\n"
            f"Parent: {rinfo['PARENT_RULE_ID']}\n"
            f"Global?: {rinfo['IS_GLOBAL']}\n"
            f"Critical?: {rinfo['CRITICAL_RULE']}\n"
        )
        self.detail_panel.setPlainText(msg)
    def show_context_menu(self, pos):
        item = self.itemAt(pos)
        menu = QtWidgets.QMenu()
        if isinstance(item, (RuleRectItem, RuleEllipseItem)):
            rinfo = item.rule_data
            edit_act = QtWidgets.QAction("Edit Rule", menu)
            def on_edit():
                c = self.connection.cursor()
                c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?", (rinfo["RULE_ID"],))
                row = get_cursor_one(c)
                if not row:
                    QMessageBox.warning(self, "Not Found", "Rule not found.")
                    return
                data = dict(row)
                cc = self.connection.cursor()
                cc.execute("SELECT RULE_TYPE_NAME, RULE_TYPE_ID FROM BRM_RULE_TYPES")
                trows = get_cursor_rows(cc)
                rtypes = {tr["RULE_TYPE_NAME"]: tr["RULE_TYPE_ID"] for tr in trows}
                dlg = RuleEditorDialog(self.connection, rtypes, "Admin", data, parent=self)
                dlg.exec_()
                self.populate_graph()
            edit_act.triggered.connect(on_edit)
            menu.addAction(edit_act)
            ance_act = QtWidgets.QAction("Highlight Ancestors", menu)
            ance_act.triggered.connect(lambda: self.highlight_ancestors(rinfo["RULE_ID"]))
            menu.addAction(ance_act)
            desc_act = QtWidgets.QAction("Highlight Descendants", menu)
            desc_act.triggered.connect(lambda: self.highlight_descendants(rinfo["RULE_ID"]))
            menu.addAction(desc_act)
        else:
            clear_act = QtWidgets.QAction("Clear Highlights", menu)
            clear_act.triggered.connect(self.clear_highlights)
            menu.addAction(clear_act)
        menu.exec_(self.mapToGlobal(pos))
    def highlight_ancestors(self, start_id):
        cur = start_id
        while cur in self.parents_map:
            node = self.node_map.get(cur)
            if node:
                node.setHighlight(True)
            p_ = self.parents_map[cur]
            if p_ in self.node_map:
                self.node_map[p_].setHighlight(True)
            cur = p_
    def highlight_descendants(self, start_id):
        queue = deque([start_id])
        visited = set()
        while queue:
            cid = queue.popleft()
            if cid in visited:
                continue
            visited.add(cid)
            if cid in self.node_map:
                self.node_map[cid].setHighlight(True)
            if cid in self.children_map:
                for ch in self.children_map[cid]:
                    queue.append(ch)
    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setHighlight(False)
    def search_nodes(self, query):
        self.clear_highlights()
        ql = query.lower()
        c = self.connection.cursor()
        found_matches = []
        c.execute("""
          SELECT RULE_ID
          FROM BRM_RULES
          WHERE LOWER(RULE_NAME) LIKE ?
             OR LOWER(RULE_SQL) LIKE ?
             OR LOWER(DESCRIPTION) LIKE ?
             OR LOWER(BUSINESS_JUSTIFICATION) LIKE ?
             OR CAST(RULE_ID AS TEXT) LIKE ?
        """, (f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%", f"%{ql}%"))
        for row in get_cursor_rows(c):
            found_matches.append(row["RULE_ID"])
        c.execute("""
          SELECT RULE_ID
          FROM BRM_COLUMN_MAPPING
          WHERE LOWER(SOURCE_COLUMN_NAME) LIKE ? OR LOWER(TARGET_COLUMN_NAME) LIKE ?
        """, (f"%{ql}%", f"%{ql}%"))
        for row in get_cursor_rows(c):
            found_matches.append(row["RULE_ID"])
        found_matches = list(set(found_matches))
        if not found_matches:
            QMessageBox.information(self, "No Match", f"No matches for '{query}'")
            return
        for rid in found_matches:
            if rid in self.node_map:
                self.node_map[rid].setHighlight(True)
                self.highlight_ancestors(rid)
                self.highlight_descendants(rid)

class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        layout = QVBoxLayout(self)
        self.appr_table = QTableWidget(0,7)
        self.appr_table.setHorizontalHeaderLabels([
            "Rule ID", "Group Name", "Rule Name", "Stage", "Approved?", "Action", "Pipeline"
        ])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.appr_table)
        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.load_approvals()
    def load_approvals(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID, A.GROUP_NAME, A.USERNAME, A.APPROVED_FLAG, A.APPROVED_TIMESTAMP,
               A.APPROVAL_STAGE, R.RULE_NAME, R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """, (self.logged_in_username,))
        rows = get_cursor_rows(c)
        pipeline_data = {}
        c_all = self.connection.cursor()
        c_all.execute("SELECT RULE_ID, GROUP_NAME, APPROVED_FLAG, APPROVAL_STAGE FROM BRM_RULE_APPROVALS")
        all_rows = get_cursor_rows(c_all)
        for apr in all_rows:
            rid_ = apr["RULE_ID"]
            grp_ = apr["GROUP_NAME"]
            st_ = apr["APPROVAL_STAGE"]
            fl_ = apr["APPROVED_FLAG"]
            pipeline_data.setdefault(rid_, {"BG1": "NotStarted", "BG2": "NotStarted", "BG3": "NotStarted", "FINAL": "NotStarted"})
            if fl_ == 1:
                pipeline_data[rid_][grp_] = "Approved"
            else:
                cur_st = get_current_approval_stage(self.connection, rid_)
                if cur_st == st_:
                    pipeline_data[rid_][grp_] = "Pending"
                else:
                    pipeline_data[rid_][grp_] = "NotStarted"
        minimal_rows = []
        for rd in rows:
            rid = rd["RULE_ID"]
            stg = rd["APPROVAL_STAGE"]
            min_st = get_current_approval_stage(self.connection, rid)
            if min_st == stg:
                minimal_rows.append(rd)
        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0, QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r,1, QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r,2, QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r,3, QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r,4, QTableWidgetItem(str(rd["APPROVED_FLAG"])))
            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, row_index=r: self.do_approve(row_index))
            self.appr_table.setCellWidget(r,5, approve_btn)
            pipe_map = pipeline_data.get(rd["RULE_ID"], {"BG1": "NotStarted", "BG2": "NotStarted", "BG3": "NotStarted", "FINAL": "NotStarted"})
            pipe_widget = ApprovalPipelineWidget(pipe_map)
            self.appr_table.setCellWidget(r,6, pipe_widget)
    def do_approve(self, row_index):
        rid_item = self.appr_table.item(row_index, 0)
        grp_item = self.appr_table.item(row_index, 1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        group_name = grp_item.text()
        c = self.connection.cursor()
        try:
            c.execute("""
              UPDATE BRM_RULE_APPROVALS
              SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
              WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
            """, (rule_id, group_name, self.logged_in_username))
            c.execute("""
              SELECT COUNT(*) as not_done
              FROM BRM_RULE_APPROVALS
              WHERE RULE_ID=? AND APPROVED_FLAG=0
            """, (rule_id,))
            row = get_cursor_one(c)
            if row["not_done"] == 0:
                c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE' WHERE RULE_ID=?", (rule_id,))
            else:
                c.execute("UPDATE BRM_RULES SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE' WHERE RULE_ID=?", (rule_id,))
            add_audit_log(self.connection, "UPDATE", "BRM_RULE_APPROVALS", rule_id, self.logged_in_username,
                          {"APPROVED_FLAG": 0}, {"APPROVED_FLAG": 1})
            self.connection.commit()
            QMessageBox.information(self, "Approved", f"You approved rule {rule_id}.")
            self.load_approvals()
        except Exception as e:
            self.connection.rollback()
            QMessageBox.critical(self, "DB Error", f"Failed to approve rule: {str(e)}")

class ApprovalPipelineWidget(QWidget):
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(5)
        stages = ["BG1", "BG2", "BG3", "FINAL"]
        for st in stages:
            circle = QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status = stage_status_map.get(st, "NotStarted")
            if status == "Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status == "Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status == "Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

class CtrlTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)
        self.table_list = ["USERS", "BUSINESS_GROUPS", "GROUP_PERMISSIONS", "BRM_RULE_TYPES",
                           "BRM_RULE_GROUPS", "BRM_RULES", "BRM_RULE_TABLE_DEPENDENCIES", "BRM_AUDIT_LOG",
                           "BRM_RULE_LINEAGE", "BRM_GROUP_BACKUPS", "BRM_COLUMN_MAPPING",
                           "BRM_CUSTOM_RULE_GROUPS", "BRM_CUSTOM_GROUP_MEMBERS",
                           "BUSINESS_GROUP_APPROVERS", "BRM_RULE_APPROVALS", "BRM_CUSTOM_GROUP_BACKUPS",
                           "BRM_GLOBAL_CRITICAL_LINKS"]
        self.table_combo = QComboBox()
        for t in self.table_list:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)
        self.load_btn = QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)
        self.table_view = QTableWidget(0,0)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.table_view)
        self.setLayout(layout)
    def on_load_data(self):
        tbl = self.table_combo.currentText()
        if not tbl:
            return
        c = self.connection.cursor()
        try:
            c.execute(f"PRAGMA table_info({tbl})")
            info = get_cursor_rows(c)
            col_names = [x["name"] for x in info]
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve table info: {str(e)}")
            return
        try:
            if not col_names:
                c.execute(f"SELECT * FROM {tbl} LIMIT 1")
                col_names = [d[0] for d in c.description]
            c.execute(f"SELECT * FROM {tbl}")
            rows = get_cursor_rows(c)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve table data: {str(e)}")
            return
        self.table_view.setRowCount(0)
        self.table_view.setColumnCount(len(col_names))
        self.table_view.setHorizontalHeaderLabels(col_names)
        for rd in rows:
            r = self.table_view.rowCount()
            self.table_view.insertRow(r)
            for j, cn in enumerate(col_names):
                val = rd[cn]
                self.table_view.setItem(r, j, QTableWidgetItem(str(val) if val is not None else ""))

class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool - Enhanced Lineage")
        self.resize(1200,800)
        self.connection = get_connection()
        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_() == QDialog.Accepted:
            self.user_id = self.login_dialog.user_id
            c = self.connection.cursor()
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?", (self.user_id,))
            row = get_cursor_one(c)
            self.logged_in_username = row["USERNAME"] if row else "Unknown"
            c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?", (self.user_id,))
            row2 = get_cursor_one(c)
            self.user_group = row2["USER_GROUP"] if row2 else "Unknown"
            self.init_ui()
        else:
            sys.exit()
    def init_ui(self):
        cw = QWidget()
        lay = QVBoxLayout(cw)
        if self.user_group == "Admin":
            self.switch_combo = QComboBox()
            self.populate_switch_combo()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h = QHBoxLayout()
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            lay.addLayout(top_h)
        self.tabs = QTabWidget()
        lay.addWidget(self.tabs)
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab, "Business Rule Management")
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection, parent=self)
        line_w = QWidget()
        lw_layout = QVBoxLayout(line_w)
        lb = QLabel("Lineage Visualization (Enhanced)")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        s_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search anything: name, ID, SQL, desc, columns...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        s_h.addWidget(self.lineage_search)
        s_h.addWidget(s_btn)
        s_h.addWidget(rst_btn)
        s_h.addWidget(ref_btn)
        s_h.addStretch()
        lw_layout.addLayout(s_h)
        lw_layout.addWidget(self.lineage_tab)
        line_w.setLayout(lw_layout)
        self.tabs.addTab(line_w, "Lineage Visualization")
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab, "Approvals")
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")
        cw.setLayout(lay)
        self.setCentralWidget(cw)
        self.init_timer()
        self.show()
    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID, USERNAME, USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = get_cursor_rows(c)
        for row in rows:
            disp = f"{row['USERNAME']} ({row['USER_GROUP']})"
            self.switch_combo.addItem(disp, (row["USER_ID"], row["USER_GROUP"]))
    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_ug = data
        if new_uid == self.user_id and new_ug == self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_ug
        QMessageBox.information(self, "Switched User", f"Now impersonating user_id={new_uid}, group={new_ug}.")
    def init_timer(self):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)
    def refresh_approvals(self):
        self.approv_tab.load_approvals()
    def get_rule_types(self):
        c = self.connection.cursor()
        c.execute("SELECT RULE_TYPE_NAME, RULE_TYPE_ID FROM BRM_RULE_TYPES")
        rows = get_cursor_rows(c)
        return {r["RULE_TYPE_NAME"]: r["RULE_TYPE_ID"] for r in rows}
    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()
    def launch_search_rule_dialog(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()
    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except:
                pass
        event.accept()

def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()