#!/usr/bin/env python

import sys
import sqlite3
import logging
import json
import math
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QDate, QTimer
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QFormLayout, QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QInputDialog, QDockWidget,
    QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView, QPlainTextEdit,
    QSplitter, QCheckBox, QTreeWidget, QTreeWidgetItem
)
import pyqtgraph as pg

##############################################################################
# GLOBAL LOGGING SETUP
##############################################################################
logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

##############################################################################
# DATABASE URI
##############################################################################
DB_URI = "file::memory:?cache=shared"

##############################################################################
# UTILITY: DETERMINE OPERATION TYPE FROM SQL
##############################################################################
def get_op_type_from_sql(sql_text: str) -> str:
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

##############################################################################
# UTILITY: EXTRACT TABLES FROM SQL
##############################################################################
def extract_tables(sql_text: str):
    found = []
    tokens = re.split(r"\s+", sql_text.strip())
    for i, t in enumerate(tokens):
        if t.upper() in ("FROM", "JOIN"):
            if i+1 < len(tokens):
                tbl = re.sub(r"[;(),]", "", tokens[i+1])
                found.append(("", tbl))
    return list(set(found))

##############################################################################
# SETUP DATABASE (INCLUDING CDC_TYPE & MULTI-STEP APPROVALS)
##############################################################################
def setup_in_memory_db():
    conn = sqlite3.connect(DB_URI, uri=True, timeout=10.0)
    conn.execute("PRAGMA foreign_keys = ON;")
    conn.row_factory = sqlite3.Row

    conn.execute("""
    CREATE TABLE IF NOT EXISTS USERS(
        USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        USERNAME TEXT UNIQUE NOT NULL,
        PASSWORD TEXT NOT NULL,
        USER_GROUP TEXT NOT NULL
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUPS(
        GROUP_NAME TEXT PRIMARY KEY,
        DESCRIPTION TEXT,
        EMAIL TEXT
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS GROUP_PERMISSIONS(
        GROUP_NAME TEXT NOT NULL,
        TARGET_TABLE TEXT NOT NULL,
        PRIMARY KEY(GROUP_NAME, TARGET_TABLE),
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TYPES(
        RULE_TYPE_ID INTEGER PRIMARY KEY,
        RULE_TYPE_NAME TEXT NOT NULL UNIQUE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_GROUPS(
        GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT UNIQUE NOT NULL,
        DESCRIPTION TEXT
    );
    """)

    # CDC_TYPE included with default 'NONE'
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULES(
        RULE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_ID INTEGER,
        PARENT_RULE_ID INTEGER,
        RULE_TYPE_ID INTEGER NOT NULL,
        RULE_NAME TEXT NOT NULL,
        RULE_SQL TEXT NOT NULL,
        EFFECTIVE_START_DATE TEXT NOT NULL,
        EFFECTIVE_END_DATE TEXT,
        STATUS TEXT NOT NULL CHECK (STATUS IN ('ACTIVE','INACTIVE')),
        VERSION INTEGER NOT NULL DEFAULT 1,
        CREATED_BY TEXT NOT NULL,
        DESCRIPTION TEXT,
        OPERATION_TYPE TEXT,
        BUSINESS_JUSTIFICATION TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        UPDATED_BY TEXT,
        OWNER_GROUP TEXT NOT NULL,
        CLUSTER_NAME TEXT,
        APPROVAL_STATUS TEXT NOT NULL DEFAULT 'DRAFT',
        IS_GLOBAL INTEGER NOT NULL DEFAULT 0,
        CRITICAL_RULE INTEGER NOT NULL DEFAULT 0,
        CRITICAL_SCOPE TEXT NOT NULL DEFAULT 'NONE',
        CDC_TYPE TEXT NOT NULL DEFAULT 'NONE',
        FOREIGN KEY(RULE_TYPE_ID) REFERENCES BRM_RULE_TYPES(RULE_TYPE_ID),
        FOREIGN KEY(PARENT_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_ID) REFERENCES BRM_RULE_GROUPS(GROUP_ID) ON DELETE SET NULL
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TABLE_DEPENDENCIES(
        DEPENDENCY_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        DATABASE_NAME TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_AUDIT_LOG(
        AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        ACTION TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        RECORD_ID TEXT NOT NULL,
        ACTION_BY TEXT NOT NULL,
        OLD_DATA TEXT,
        NEW_DATA TEXT,
        ACTION_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_LINEAGE(
        LINEAGE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_INFO TEXT,
        TARGET_INFO TEXT,
        TRANSFORMATION_DETAILS TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_COLUMN_MAPPING(
        MAPPING_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_RULE_ID INTEGER NOT NULL,
        SOURCE_COLUMN_NAME TEXT NOT NULL,
        TARGET_COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(SOURCE_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_RULE_GROUPS(
        CUSTOM_GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_NAME TEXT NOT NULL UNIQUE,
        OWNER_BUSINESS_GROUP TEXT NOT NULL,
        CREATED_BY TEXT NOT NULL,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_MEMBERS(
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        RULE_ID INTEGER NOT NULL,
        PRIMARY KEY(CUSTOM_GROUP_ID, RULE_ID),
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUP_APPROVERS(
        APPROVER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_APPROVALS(
        RULE_ID INTEGER NOT NULL,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        APPROVED_FLAG INTEGER NOT NULL DEFAULT 0,
        APPROVED_TIMESTAMP DATETIME,
        APPROVAL_STAGE INTEGER NOT NULL DEFAULT 1,
        PRIMARY KEY(RULE_ID, GROUP_NAME, USERNAME),
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)

    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GLOBAL_CRITICAL_LINKS(
        LINK_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GCR_RULE_ID INTEGER NOT NULL,
        TARGET_RULE_ID INTEGER,
        TARGET_GROUP_ID INTEGER,
        FOREIGN KEY(GCR_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(TARGET_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    # Seed data
    groups = [
        ("Admin","Admin group","admin@example.com"),
        ("BG1","Group1","bg1@example.com"),
        ("BG2","Group2","bg2@example.com"),
        ("BG3","Group3","bg3@example.com"),
    ]
    for g in groups:
        conn.execute("""
        INSERT OR IGNORE INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL)
        VALUES(?,?,?)
        """,(g[0],g[1],g[2]))

    users = [
        ("admin","admin","Admin"),
        ("bg1_user","user","BG1"),
        ("bg2_user","user","BG2"),
        ("bg3_user","user","BG3"),
    ]
    for u in users:
        conn.execute("""
        INSERT OR IGNORE INTO USERS(USERNAME,PASSWORD,USER_GROUP)
        VALUES(?,?,?)
        """,(u[0],u[1],u[2]))

    perms = [
        ("Admin","TABLE_A"),
        ("Admin","TABLE_B"),
        ("Admin","TABLE_C"),
        ("Admin","TABLE_D"),
        ("BG1","TABLE_A"),
        ("BG1","TABLE_B"),
        ("BG2","TABLE_C"),
        ("BG3","TABLE_D")
    ]
    for p in perms:
        conn.execute("""
        INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE)
        VALUES(?,?)
        """, p)

    conn.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(1,'DQ')")
    conn.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(2,'DM')")

    rule_groups = [
        ("Finance Rules", "Rules related to financial data"),
        ("HR Rules", "Rules related to human resources")
    ]
    for rg in rule_groups:
        conn.execute("""
        INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION)
        VALUES(?,?)
        """,(rg[0], rg[1]))

    conn.execute("""INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG1','bg1_user')""")
    conn.execute("""INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG2','bg2_user')""")
    conn.execute("""INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG3','bg3_user')""")

    conn.commit()
    return conn

##############################################################################
# HELPER: ADD AUDIT LOG
##############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    c = conn.cursor()
    c.execute("""
      INSERT INTO BRM_AUDIT_LOG(ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA)
      VALUES(?,?,?,?,?,?)
    """,(action, table_name, str(record_id), action_by,
         json.dumps(old_data) if old_data else None,
         json.dumps(new_data) if new_data else None))
    conn.commit()

##############################################################################
# BFS RULE EXECUTION
##############################################################################
def build_rule_adjacency(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()

    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r in rows:
        rid = r["RULE_ID"]
        pid = r["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)

    root_rules = [rid for rid in all_ids if rid not in parent_ids]
    return children_map, root_rules

def run_rule_sql(conn, rule_sql):
    try:
        c = conn.cursor()
        c.execute(rule_sql)
        row = c.fetchone()
        if row is None:
            return True
        return (row[0] == 1)
    except Exception as e:
        logger.error(f"Rule execution error: {e}")
        return False

def load_global_critical_links(conn):
    c = conn.cursor()
    c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS")
    rows = c.fetchall()
    link_map = {}
    for r in rows:
        parent = r["GCR_RULE_ID"]
        child = r["TARGET_RULE_ID"]
        if not child:
            continue
        link_map.setdefault(parent, set()).add(child)
    return link_map

def skip_descendants(child_id, children_map, skipped):
    stack = [child_id]
    while stack:
        current = stack.pop()
        if current in skipped:
            continue
        skipped.add(current)
        if current in children_map:
            stack.extend(children_map[current])

def get_all_rules_as_dict(conn):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    rows = c.fetchall()
    return {r["RULE_ID"]: dict(r) for r in rows}

def execute_rules_in_order(conn):
    children_map, root_rules = build_rule_adjacency(conn)
    gcr_links = load_global_critical_links(conn)
    executed = []
    skipped = set()
    queue = list(root_rules)
    rule_lookup = get_all_rules_as_dict(conn)

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            logger.warning(f"Rule {rid} not found.")
            continue

        rinfo = rule_lookup[rid]
        rule_sql = rinfo["RULE_SQL"]
        passed = run_rule_sql(conn, rule_sql)

        if passed:
            executed.append(rid)
            if rid in children_map:
                for ch in children_map[rid]:
                    if ch not in skipped:
                        queue.append(ch)
        else:
            logger.warning(f"Rule {rid} FAILED.")
            is_crit = (rinfo["CRITICAL_RULE"] == 1 or rinfo["IS_GLOBAL"] == 1)
            scope = rinfo["CRITICAL_SCOPE"].upper()
            if is_crit and scope != "NONE":
                if rid in children_map:
                    for child_id in children_map[rid]:
                        skip_descendants(child_id, children_map, skipped)
                if rid in gcr_links:
                    for child_rid in gcr_links[rid]:
                        skip_descendants(child_rid, children_map, skipped)

    logger.info(f"ETL Complete. Executed={executed}, Skipped={list(skipped)}")
    return executed, skipped

##############################################################################
# MULTI-STEP APPROVAL LOGIC
##############################################################################
MULTISTEP_ORDER = ["BG1","BG2","BG3","FINAL"]

def find_impacted_business_groups(conn, rule_id):
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = c.fetchone()
    if row:
        impacted.add(row["OWNER_GROUP"])

    queue = [rule_id]
    visited = set()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=?",(curr,))
        kids = c.fetchall()
        for k in kids:
            cid = k["RULE_ID"]
            c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(cid,))
            row2 = c.fetchone()
            if row2:
                impacted.add(row2["OWNER_GROUP"])
            queue.append(cid)
    return impacted

def create_multistep_approvals(conn, rule_id, impacted_bg_list):
    c = conn.cursor()
    stage_counter = 1
    stage_list = []
    for step_bg in MULTISTEP_ORDER:
        if step_bg == "FINAL":
            stage_list.append((step_bg, stage_counter))
            stage_counter += 1
        else:
            if step_bg in impacted_bg_list:
                stage_list.append((step_bg, stage_counter))
                stage_counter += 1

    for (bg, st) in stage_list:
        if bg == "FINAL":
            user_ap = "final_approver"
            c.execute("""
              INSERT OR IGNORE INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVAL_STAGE)
              VALUES(?,?,?,?,?)
            """,(rule_id,bg,user_ap,0,st))
        else:
            c.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(bg,))
            row_aps = c.fetchall()
            for raps in row_aps:
                c.execute("""
                  INSERT OR IGNORE INTO BRM_RULE_APPROVALS
                  (RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVAL_STAGE)
                  VALUES(?,?,?,?,?)
                """,(rule_id,bg,raps["USERNAME"],0,st))
    conn.commit()

def get_current_approval_stage(conn, rule_id):
    c = conn.cursor()
    c.execute("""
      SELECT MIN(APPROVAL_STAGE) as stage
      FROM BRM_RULE_APPROVALS
      WHERE RULE_ID=? AND APPROVED_FLAG=0
    """,(rule_id,))
    row = c.fetchone()
    if row and row["stage"]:
        return row["stage"]
    return None

def check_multistep_approval_complete(conn, rule_id):
    c = conn.cursor()
    c.execute("""
      SELECT COUNT(*) as not_done
      FROM BRM_RULE_APPROVALS
      WHERE RULE_ID=? AND APPROVED_FLAG=0
    """,(rule_id,))
    row = c.fetchone()
    return (row["not_done"] == 0)

def find_child_rules(conn, parent_rule_id):
    results = []
    queue = [parent_rule_id]
    visited = set()
    c = conn.cursor()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES WHERE PARENT_RULE_ID=?",(curr,))
        ch = c.fetchall()
        for row in ch:
            results.append(dict(row))
            queue.append(row["RULE_ID"])
    return results

##############################################################################
# CRUD with CDC_TYPE
##############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    is_global = rule_data.get("IS_GLOBAL",0)
    if is_global==1 and user_group!="Admin":
        raise ValueError("Only Admin can create a global rule.")

    c = conn.cursor()
    c.execute("""
      INSERT INTO BRM_RULES(
        GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
        EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
        CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
        OWNER_GROUP,APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,
        CDC_TYPE
      ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
    """,(
      rule_data.get("GROUP_ID"),
      rule_data.get("PARENT_RULE_ID"),
      rule_data["RULE_TYPE_ID"],
      rule_data["RULE_NAME"],
      rule_data["RULE_SQL"],
      rule_data["EFFECTIVE_START_DATE"],
      rule_data.get("EFFECTIVE_END_DATE"),
      "INACTIVE",
      1,
      created_by,
      rule_data.get("DESCRIPTION"),
      rule_data.get("OPERATION_TYPE"),
      rule_data.get("BUSINESS_JUSTIFICATION",""),
      rule_data["OWNER_GROUP"],
      "APPROVAL_IN_PROGRESS",
      is_global,
      rule_data.get("CRITICAL_RULE",0),
      rule_data.get("CRITICAL_SCOPE","NONE"),
      rule_data.get("CDC_TYPE","NONE")
    ))
    new_id = c.lastrowid

    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn, tbn) in deps:
        c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                RULE_ID, DATABASE_NAME, TABLE_NAME, COLUMN_NAME
            )
            VALUES(?,?,?,?)
        """,(new_id, dbn, tbn, "DerivedCol"))

    add_audit_log(conn,"INSERT","BRM_RULES", new_id, created_by, None, rule_data)
    conn.commit()

    if is_global==1:
        logger.info(f"Global rule {new_id} => skipping multi-step approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)

    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_data["RULE_ID"],))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    old_data = dict(old)

    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update a global rule.")
    if rule_data.get("IS_GLOBAL",old["IS_GLOBAL"])==1 and user_group!="Admin":
        raise ValueError("Only Admin can set a rule global.")

    c.execute("""
      UPDATE BRM_RULES
      SET
        GROUP_ID=?,
        PARENT_RULE_ID=?,
        RULE_TYPE_ID=?,
        RULE_NAME=?,
        RULE_SQL=?,
        EFFECTIVE_START_DATE=?,
        EFFECTIVE_END_DATE=?,
        STATUS='INACTIVE',
        VERSION=VERSION+1,
        UPDATED_BY=?,
        DESCRIPTION=?,
        OPERATION_TYPE=?,
        BUSINESS_JUSTIFICATION=?,
        OWNER_GROUP=?,
        APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
        IS_GLOBAL=?,
        CRITICAL_RULE=?,
        CRITICAL_SCOPE=?,
        CDC_TYPE=?
      WHERE RULE_ID=?
    """,(
      rule_data.get("GROUP_ID",old["GROUP_ID"]),
      rule_data.get("PARENT_RULE_ID",old["PARENT_RULE_ID"]),
      rule_data["RULE_TYPE_ID"],
      rule_data["RULE_NAME"],
      rule_data["RULE_SQL"],
      rule_data["EFFECTIVE_START_DATE"],
      rule_data.get("EFFECTIVE_END_DATE"),
      updated_by,
      rule_data.get("DESCRIPTION"),
      rule_data.get("OPERATION_TYPE"),
      rule_data.get("BUSINESS_JUSTIFICATION",""),
      rule_data["OWNER_GROUP"],
      rule_data.get("IS_GLOBAL",old["IS_GLOBAL"]),
      rule_data.get("CRITICAL_RULE",old["CRITICAL_RULE"]),
      rule_data.get("CRITICAL_SCOPE",old["CRITICAL_SCOPE"]),
      rule_data.get("CDC_TYPE", old["CDC_TYPE"]),
      rule_data["RULE_ID"]
    ))

    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rule_data["RULE_ID"],))
    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn,tbn) in deps:
        c.execute("""
          INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME)
          VALUES(?,?,?,?)
        """,(rule_data["RULE_ID"],dbn,tbn,"DerivedCol"))

    new_data = dict(old_data)
    for k,v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"]+1
    add_audit_log(conn,"UPDATE","BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()

    if old["IS_GLOBAL"]==1 or rule_data.get("IS_GLOBAL",0)==1:
        logger.info(f"Global rule {rule_data['RULE_ID']} updated => skipping multi-step approvals.")
    else:
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate a global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    kids = c.fetchall()
    if kids:
        raise ValueError("Child rules must be deactivated first.")

    old_data = dict(old)
    c.execute("UPDATE BRM_RULES SET STATUS='INACTIVE',UPDATED_BY=?,VERSION=VERSION+1 WHERE RULE_ID=?",
              (updated_by, rule_id))
    new_data = dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old["VERSION"]+1
    add_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"]!="INACTIVE":
        raise ValueError("Must be INACTIVE first.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    kids = c.fetchall()
    if kids:
        raise ValueError("Child rules exist.")

    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    leftover = c.fetchall()
    if leftover:
        raise ValueError("Remove or re-map column references first.")

    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    add_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)
    conn.commit()

##############################################################################
# LOGIN DIALOG
##############################################################################
class LoginDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.setFixedSize(300, 200)
        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(usern, passw))
        row = c.fetchone()
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

##############################################################################
# RULE EDITOR DIALOG (WITH CDC COMBO)
##############################################################################
class RuleEditorDialog(QDialog):
    def __init__(self, connection, rule_types, logged_in_user, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_types = rule_types
        self.logged_in_user = logged_in_user
        self.rule_data = rule_data

        title = "Edit Rule" if rule_data else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(900, 500)

        main_layout = QHBoxLayout(self)

        left_box = QGroupBox("Basic Info")
        left_layout = QFormLayout(left_box)

        self.group_combo = QComboBox()
        self.group_combo.addItem("None", None)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
            rr = c.fetchall()
            for row in rr:
                self.group_combo.addItem(row["GROUP_NAME"], row["GROUP_ID"])
        except Exception as ex:
            logger.warning(f"Error loading rule groups: {ex}")
        left_layout.addRow("Rule Group:", self.group_combo)

        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("None",None)
        try:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES WHERE STATUS='ACTIVE'")
            for row in c.fetchall():
                self.parent_rule_combo.addItem(
                    f"{row['RULE_NAME']} (ID:{row['RULE_ID']})", row["RULE_ID"]
                )
        except Exception as ex:
            logger.warning(f"Error loading parent rules: {ex}")
        left_layout.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit = QLineEdit()
        left_layout.addRow("Rule Name:", self.name_edit)

        self.type_combo = QComboBox()
        for rt_name in self.rule_types:
            self.type_combo.addItem(rt_name)
        left_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["ACTIVE","INACTIVE"])
        left_layout.addRow("Status (informational):", self.status_combo)

        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setCalendarPopup(True)
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("Start Date:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setCalendarPopup(True)
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("End Date:", self.end_dt)

        self.owner_grp_combo = QComboBox()
        try:
            c.execute("SELECT DISTINCT GROUP_NAME FROM GROUP_PERMISSIONS ORDER BY GROUP_NAME")
            for g in c.fetchall():
                self.owner_grp_combo.addItem(g["GROUP_NAME"], g["GROUP_NAME"])
        except Exception as ex:
            logger.warning(f"Error loading group permissions: {ex}")
        left_layout.addRow("Owner Group:", self.owner_grp_combo)

        self.global_checkbox = None
        if self.logged_in_user=="Admin":
            self.global_checkbox = QCheckBox("Global (admin-only)")
            left_layout.addRow("Global:", self.global_checkbox)

        self.critical_checkbox = QCheckBox("Critical (Stop-on-fail)")
        left_layout.addRow("Critical Rule:", self.critical_checkbox)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        left_layout.addRow("Critical Scope:", self.scope_combo)

        self.cdc_combo = QComboBox()
        self.cdc_combo.addItems(["NONE","FULL_LOAD","INCREMENTAL","INSERT_ONLY","UPSERT"])
        left_layout.addRow("CDC Type:", self.cdc_combo)

        main_layout.addWidget(left_box)

        right_box = QGroupBox("Details & Logic")
        right_layout = QFormLayout(right_box)

        self.sql_editor = QPlainTextEdit()
        font = QtGui.QFont("Courier", 10)
        self.sql_editor.setFont(font)
        right_layout.addRow(QLabel("Rule SQL:"), self.sql_editor)

        self.description_edit = QTextEdit()
        right_layout.addRow(QLabel("Description:"), self.description_edit)

        self.justification_edit = QTextEdit()
        right_layout.addRow(QLabel("Justification:"), self.justification_edit)

        btn_box = QHBoxLayout()
        self.save_btn = QPushButton("Save" if rule_data else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_box.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(cancel_btn)
        right_layout.addRow(btn_box)

        main_layout.addWidget(right_box)
        self.setLayout(main_layout)

        if self.rule_data:
            self.load_rule_data(self.rule_data)

    def load_rule_data(self, rd):
        if rd["GROUP_ID"]:
            idx = self.group_combo.findData(rd["GROUP_ID"])
            if idx>=0:
                self.group_combo.setCurrentIndex(idx)
        if rd["PARENT_RULE_ID"]:
            idx2 = self.parent_rule_combo.findData(rd["PARENT_RULE_ID"])
            if idx2>=0:
                self.parent_rule_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd["RULE_NAME"])

        for nm,tid in self.rule_types.items():
            if tid==rd["RULE_TYPE_ID"]:
                i = self.type_combo.findText(nm)
                if i>=0:
                    self.type_combo.setCurrentIndex(i)
                break

        st = rd["STATUS"]
        i_st = self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)

        try:
            sdt = datetime.strptime(rd["EFFECTIVE_START_DATE"],"%Y-%m-%d %H:%M:%S")
            self.start_dt.setDateTime(QtCore.QDateTime(sdt))
        except Exception:
            pass

        if rd["EFFECTIVE_END_DATE"]:
            try:
                edt = datetime.strptime(rd["EFFECTIVE_END_DATE"],"%Y-%m-%d %H:%M:%S")
                self.end_dt.setDateTime(QtCore.QDateTime(edt))
            except Exception:
                pass

        og = rd["OWNER_GROUP"]
        i_og = self.owner_grp_combo.findText(og)
        if i_og>=0:
            self.owner_grp_combo.setCurrentIndex(i_og)

        self.sql_editor.setPlainText(rd["RULE_SQL"] or "")
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.global_checkbox and rd.get("IS_GLOBAL",0)==1:
            self.global_checkbox.setChecked(True)
        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_checkbox.setChecked(True)

        scope_val = rd.get("CRITICAL_SCOPE","NONE")
        idx_scope = self.scope_combo.findText(scope_val.upper())
        if idx_scope>=0:
            self.scope_combo.setCurrentIndex(idx_scope)

        cdc_val = rd.get("CDC_TYPE","NONE").upper()
        idx_cdc = self.cdc_combo.findText(cdc_val)
        if idx_cdc>=0:
            self.cdc_combo.setCurrentIndex(idx_cdc)

    def on_save(self):
        if not self.name_edit.text().strip():
            QMessageBox.warning(self,"Error","Name is empty.")
            return
        sql_text = self.sql_editor.toPlainText().strip()
        if not sql_text:
            QMessageBox.warning(self,"Error","SQL is empty.")
            return

        op_type = get_op_type_from_sql(sql_text)
        rule_dict = {
            "GROUP_ID": self.group_combo.currentData(),
            "PARENT_RULE_ID": self.parent_rule_combo.currentData(),
            "RULE_TYPE_ID": self.rule_types.get(self.type_combo.currentText()),
            "RULE_NAME": self.name_edit.text().strip(),
            "RULE_SQL": sql_text,
            "EFFECTIVE_START_DATE": self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "EFFECTIVE_END_DATE": self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "STATUS": self.status_combo.currentText(),
            "DESCRIPTION": self.description_edit.toPlainText().strip(),
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": self.justification_edit.toPlainText().strip(),
            "OWNER_GROUP": self.owner_grp_combo.currentText().strip(),
            "IS_GLOBAL": 1 if (self.global_checkbox and self.global_checkbox.isChecked()) else 0,
            "CRITICAL_RULE": 1 if self.critical_checkbox.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper(),
            "CDC_TYPE": self.cdc_combo.currentText().upper()
        }
        created_by = self.logged_in_user
        if self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success","Rule updated. Approval re-initiated (multi-step).")
                self.accept()
            except Exception as e:
                QMessageBox.critical(self,"DB Error",str(e))
        else:
            confirm = QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success",f"Rule created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as e:
                QMessageBox.critical(self,"DB Error",str(e))

##############################################################################
# RULE ANALYTICS DIALOG
##############################################################################
class RuleAnalyticsDialog(QDialog):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Rule Analytics")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        chart_hbox = QHBoxLayout()

        self.bar_chart = pg.PlotWidget(title="Number of Rules by Creator")
        self.bar_chart.setBackground('w')
        chart_hbox.addWidget(self.bar_chart)

        self.pie_chart = pg.PlotWidget(title="Rule Status Distribution")
        self.pie_chart.setBackground('w')
        chart_hbox.addWidget(self.pie_chart)

        layout.addLayout(chart_hbox)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)

        self.load_charts()

    def load_charts(self):
        c = self.connection.cursor()
        c.execute("SELECT CREATED_BY, COUNT(*) as cnt FROM BRM_RULES GROUP BY CREATED_BY")
        creators_data = c.fetchall()
        creators = {row["CREATED_BY"]: row["cnt"] for row in creators_data}

        status_counts = {"ACTIVE":0,"INACTIVE":0,"DELETED":0}
        c.execute("SELECT STATUS,COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        for row in c.fetchall():
            s_up = row["STATUS"].upper()
            if s_up in status_counts:
                status_counts[s_up] = row["sc"]

        c.execute("SELECT COUNT(*) as delcnt FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'")
        row2 = c.fetchone()
        if row2:
            status_counts["DELETED"] = row2["delcnt"]

        self.bar_chart.clear()
        if creators:
            sorted_creators = sorted(creators.items(), key=lambda x:x[1],reverse=True)
            names = [sc[0] for sc in sorted_creators]
            vals = [sc[1] for sc in sorted_creators]
            bar_item = pg.BarGraphItem(x=range(len(names)), height=vals, width=0.6, brush="skyblue")
            self.bar_chart.addItem(bar_item)
            ax = self.bar_chart.getAxis("bottom")
            ax.setTicks([ list(zip(range(len(names)), names)) ])
            self.bar_chart.setLabel("left","Number of Rules")
            self.bar_chart.setLabel("bottom","Created By")
            self.bar_chart.showGrid(x=True,y=True)

        self.pie_chart.clear()
        total = sum(status_counts.values())
        if total>0:
            angles = [360*(v/total) for v in status_counts.values()]
            start=90
            color_map = {"ACTIVE":"green","INACTIVE":"red","DELETED":"gray"}
            scene = self.pie_chart.scene()
            if not scene:
                from PyQt5.QtWidgets import QGraphicsScene
                scene = QGraphicsScene()
                self.pie_chart.setScene(scene)
            for (k,v),ang in zip(status_counts.items(), angles):
                if ang>0:
                    wedge = QtGui.QPainterPath()
                    wedge.moveTo(0,0)
                    wedge.arcTo(-100,-100,200,200,start,ang)
                    wedge.closeSubpath()
                    brush = QtGui.QBrush(QtGui.QColor(color_map.get(k,"blue")))
                    path_item = pg.QtWidgets.QGraphicsPathItem(wedge)
                    path_item.setBrush(brush)
                    path_item.setPen(pg.mkPen("black"))
                    scene.addItem(path_item)

                    mid = start+(ang/2)
                    rad = (mid*math.pi)/180
                    xx = 50*math.cos(rad)
                    yy = 50*math.sin(rad)
                    perc = math.floor((ang/360)*100)
                    lab = pg.TextItem(f"{k} ({perc}%)", anchor=(0.5,0.5))
                    lab.setPos(xx,yy)
                    scene.addItem(lab)
                    start+=ang
            self.pie_chart.setAspectLocked(True)

##############################################################################
# AUDIT LOG VIEWER
##############################################################################
class AuditLogViewer(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs")
        self.resize(800,600)

        main_layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by Action, Table, or Action By...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.audit_table = QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels([
            "Audit ID","Action","Table Name","Record ID","Action By","Old Data","New Data","Timestamp"
        ])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main_layout.addWidget(self.audit_table)

        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        main_layout.addWidget(ref_btn)

        self.setLayout(main_layout)
        self.load_logs()

    def load_logs(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
          FROM BRM_AUDIT_LOG
          ORDER BY ACTION_TIMESTAMP DESC
          LIMIT 1000
        """)
        rows = c.fetchall()
        self.audit_table.setRowCount(0)
        for row in rows:
            r = self.audit_table.rowCount()
            self.audit_table.insertRow(r)
            self.audit_table.setItem(r,0,QTableWidgetItem(str(row["AUDIT_ID"])))
            self.audit_table.setItem(r,1,QTableWidgetItem(row["ACTION"]))
            self.audit_table.setItem(r,2,QTableWidgetItem(row["TABLE_NAME"]))
            self.audit_table.setItem(r,3,QTableWidgetItem(row["RECORD_ID"]))
            self.audit_table.setItem(r,4,QTableWidgetItem(row["ACTION_BY"]))

            if row["OLD_DATA"]:
                try:
                    parsed = json.loads(row["OLD_DATA"])
                    txt = json.dumps(parsed,indent=2)
                except:
                    txt = row["OLD_DATA"]
                self.audit_table.setItem(r,5,QTableWidgetItem(txt))
            else:
                self.audit_table.setItem(r,5,QTableWidgetItem(""))

            if row["NEW_DATA"]:
                try:
                    parsed = json.loads(row["NEW_DATA"])
                    txt = json.dumps(parsed,indent=2)
                except:
                    txt = row["NEW_DATA"]
                self.audit_table.setItem(r,6,QTableWidgetItem(txt))
            else:
                self.audit_table.setItem(r,6,QTableWidgetItem(""))

            self.audit_table.setItem(r,7,QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))

    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            match=False
            for col in (1,2,4):
                it = self.audit_table.item(row,col)
                if it and txt_l in it.text().lower():
                    match=True
                    break
            self.audit_table.setRowHidden(row, not match)

##############################################################################
# SEARCH RULE DIALOG
##############################################################################
class SearchRuleDialog(QDialog):
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules")
        self.resize(800,600)

        main_layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.res_table = QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main_layout.addWidget(self.res_table)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        main_layout.addWidget(ref_btn)
        self.setLayout(main_layout)

        self.load_results()

    def load_results(self):
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
              FROM BRM_RULES
              WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
              ORDER BY RULE_ID DESC
              LIMIT 1000
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
              LIMIT 1000
            """)
        rows = c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r = self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r,0,QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r,1,QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r,2,QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r,3,QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r,4,QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r,5,QTableWidgetItem(row["CREATED_BY"]))

##############################################################################
# RULE DASHBOARD
##############################################################################
class RuleDashboard(QGroupBox):
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All Statuses", None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        self.status_filter.addItem("DELETED","DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        self.rule_table = QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Name","SQL","Status","Version","Owner Group","Created Timestamp","Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)

        run_etl_btn = QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)

        analytics_btn = QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics_popup)
        btn_h.addWidget(analytics_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)

        self.setLayout(main_layout)
        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"ETL Finished.\nExecuted: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self,"ETL",msg)
        self.load_rules()

    def show_analytics_popup(self):
        dlg = RuleAnalyticsDialog(self.connection, self)
        dlg.exec_()

    def build_filter_query(self):
        f = []
        p = []
        txt = self.search_edit.text().strip()
        if txt:
            f.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            p.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            if st.upper()=="DELETED":
                f.append("RULE_ID IN (SELECT RECORD_ID FROM BRM_AUDIT_LOG WHERE ACTION='DELETE')")
            else:
                f.append("STATUS=?")
                p.append(st)
        clause = " AND ".join(f) if f else "1"
        return clause, p

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()
        c.execute(f"SELECT COUNT(*) as ccount FROM BRM_RULES WHERE {clause}", params)
        rowc = c.fetchone()
        total = rowc["ccount"] if rowc else 0
        self.total_pages = max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        elif self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset = (self.current_page-1)*self.records_per_page
        c.execute(f"""
          SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
          FROM BRM_RULES
          WHERE {clause}
          ORDER BY RULE_ID DESC
          LIMIT ? OFFSET ?
        """, (*params, self.records_per_page, offset))
        rows = c.fetchall()
        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r,2,QTableWidgetItem(rd["RULE_SQL"]))

            sitem = QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"].lower()=="active":
                sitem.setBackground(QColor(144,238,144))
            else:
                sitem.setBackground(QColor(255,182,193))
            self.rule_table.setItem(r,3,sitem)

            self.rule_table.setItem(r,4,QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r,5,QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r,6,QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r,7,QTableWidgetItem(rd["APPROVAL_STATUS"]))

    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row = sel[0].row()
        it = self.rule_table.item(row,0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        ids_ = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row,0)
            if it:
                ids_.append(int(it.text()))
        return ids_

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

##############################################################################
# BUSINESS RULE MANAGEMENT TAB
##############################################################################
class BusinessRuleManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        main_layout = QVBoxLayout(self)
        btn_h = QHBoxLayout()

        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        btn_h.addWidget(add_btn)

        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        btn_h.addWidget(upd_btn)

        deact_btn = QPushButton("Deactivate Selected")
        deact_btn.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(deact_btn)

        del_btn = QPushButton("Delete Rule")
        del_btn.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(del_btn)

        aud_btn = QPushButton("View Audit Logs")
        aud_btn.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_btn)

        srch_btn = QPushButton("Search Rules")
        srch_btn.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)

        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        main_layout.addWidget(self.rule_dash)

        main_layout.addStretch()
        self.setLayout(main_layout)

    def on_add_rule(self):
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_()==QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_update_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self,"No Selection","Select a rule to update.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found","No rule with that ID.")
            return
        rule_data = dict(row)
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, rule_data, self)
        if dlg.exec_()==QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_deactivate_rules(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None Selected","No rules selected.")
            return
        success=0
        fails=[]
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success+=1
            except Exception as e:
                fails.append(f"Rule {rr}: {str(e)}")
        msg = f"Deactivation done. Success={success}"
        if fails:
            msg+= "\nFails:\n"+"\n".join(fails)
        QMessageBox.information(self,"Deactivate", msg)
        self.rule_dash.load_rules()

    def on_delete_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self,"None Selected","No rule to delete.")
            return
        try:
            delete_rule(self.connection, rid, self.user_group, self.user_group)
            QMessageBox.information(self,"Deleted","Rule deleted.")
            self.rule_dash.load_rules()
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

##############################################################################
# GROUP MANAGEMENT TAB
##############################################################################
class GroupManagementTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        if user_group!="Admin":
            lay = QVBoxLayout(self)
            lay.addWidget(QLabel("Access Denied: Only Admin can manage groups."))
            self.setLayout(lay)
            return

        main_layout = QVBoxLayout(self)
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        gm_tab = QWidget()
        gm_layout = QVBoxLayout(gm_tab)
        grp_box = QGroupBox("Group Details")
        grp_layout = QVBoxLayout(grp_box)
        self.groups_table = QTableWidget()
        self.groups_table.setColumnCount(3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        btn_h = QHBoxLayout()
        add_grp_btn = QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        btn_h.addWidget(add_grp_btn)

        rename_grp_btn = QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        btn_h.addWidget(rename_grp_btn)

        del_grp_btn = QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        btn_h.addWidget(del_grp_btn)

        backup_grp_btn = QPushButton("Backup Group")
        backup_grp_btn.clicked.connect(self.on_backup_group)
        btn_h.addWidget(backup_grp_btn)

        restore_grp_btn = QPushButton("Restore Group")
        restore_grp_btn.clicked.connect(self.on_restore_group)
        btn_h.addWidget(restore_grp_btn)

        btn_h.addStretch()
        grp_layout.addLayout(btn_h)
        gm_layout.addWidget(grp_box)

        membership_box = QGroupBox("Membership Management")
        membership_layout = QVBoxLayout(membership_box)
        self.users_table = QTableWidget()
        self.users_table.setColumnCount(3)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btn_h = QHBoxLayout()
        add_usr_btn = QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btn_h.addWidget(add_usr_btn)

        rem_usr_btn = QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btn_h.addWidget(rem_usr_btn)

        memb_btn_h.addStretch()
        membership_layout.addLayout(memb_btn_h)
        gm_layout.addWidget(membership_box)
        self.tabs.addTab(gm_tab,"Groups & Membership")

        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        perm_box = QGroupBox("Group Permissions")
        perm_box_layout = QVBoxLayout(perm_box)

        ptop_h = QHBoxLayout()
        ptop_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo = QComboBox()
        ptop_h.addWidget(self.perm_group_combo)
        ptop_h.addStretch()
        perm_box_layout.addLayout(ptop_h)

        self.perm_table = QTableWidget()
        self.perm_table.setColumnCount(1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        pbtn_h = QHBoxLayout()
        add_perm_btn = QPushButton("Add Permission")
        add_perm_btn.clicked.connect(self.on_add_permission)
        pbtn_h.addWidget(add_perm_btn)
        rem_perm_btn = QPushButton("Remove Permission")
        rem_perm_btn.clicked.connect(self.on_remove_permission)
        pbtn_h.addWidget(rem_perm_btn)
        pbtn_h.addStretch()
        perm_box_layout.addLayout(pbtn_h)

        perm_layout.addWidget(perm_box)
        self.tabs.addTab(perm_tab,"Group Permissions")

        appr_tab = QWidget()
        appr_layout = QVBoxLayout(appr_tab)
        ah = QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo = QComboBox()
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table = QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btn_h = QHBoxLayout()
        add_appr_btn = QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btn_h.addWidget(add_appr_btn)

        del_appr_btn = QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btn_h.addWidget(del_appr_btn)
        appr_btn_h.addStretch()
        appr_layout.addLayout(appr_btn_h)

        self.tabs.addTab(appr_tab,"Approvers Management")

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_data)
        main_layout.addWidget(ref_btn)
        self.setLayout(main_layout)

        self.load_data()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.groups_table.setRowCount(0)
        for row in rows:
            r = self.groups_table.rowCount()
            self.groups_table.insertRow(r)
            self.groups_table.setItem(r,0,QTableWidgetItem(row["GROUP_NAME"]))
            self.groups_table.setItem(r,1,QTableWidgetItem(row["DESCRIPTION"] or ""))
            self.groups_table.setItem(r,2,QTableWidgetItem(row["EMAIL"] or ""))

    def load_users(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = c.fetchall()
        self.users_table.setRowCount(0)
        for row in rows:
            rr = self.users_table.rowCount()
            self.users_table.insertRow(rr)
            self.users_table.setItem(rr,0,QTableWidgetItem(str(row["USER_ID"])))
            self.users_table.setItem(rr,1,QTableWidgetItem(row["USERNAME"]))
            self.users_table.setItem(rr,2,QTableWidgetItem(row["USER_GROUP"]))

    def load_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.perm_group_combo.clear()
        for r in rows:
            self.perm_group_combo.addItem(r["GROUP_NAME"],r["GROUP_NAME"])

    def load_appr_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.appr_group_combo.clear()
        for r in rows:
            self.appr_group_combo.addItem(r["GROUP_NAME"],r["GROUP_NAME"])

    def load_permissions(self):
        grp = self.perm_group_combo.currentText().strip()
        c = self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows = c.fetchall()
        self.perm_table.setRowCount(0)
        for row in rows:
            rr = self.perm_table.rowCount()
            self.perm_table.insertRow(rr)
            self.perm_table.setItem(rr,0,QTableWidgetItem(row["TARGET_TABLE"]))

    def load_approvers(self):
        grp = self.appr_group_combo.currentText().strip()
        c = self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
        rows = c.fetchall()
        self.appr_table.setRowCount(0)
        for row in rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0,QTableWidgetItem(str(row["APPROVER_ID"])))
            self.appr_table.setItem(r,1,QTableWidgetItem(row["USERNAME"]))

    def get_selected_group(self):
        idx = self.groups_table.currentRow()
        if idx<0:
            return None
        it = self.groups_table.item(idx,0)
        if not it:
            return None
        return it.text().strip()

    def on_add_group(self):
        name, ok = QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self,"Add Group","Description:")
        if not ok2:
            desc=""
        email, ok3 = QInputDialog.getText(self,"Add Group","Email:")
        if not ok3:
            email=""
        name = name.strip()
        if not name:
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(name,))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",
                  (name, desc.strip(), email.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Success","Group added.")
        self.load_data()

    def on_rename_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        new_name, ok = QInputDialog.getText(self,"Rename Group","New group name:")
        if not ok or not new_name.strip():
            return
        new_name = new_name.strip()
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name,))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New group name already exists.")
            return
        try:
            c.execute("BEGIN")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name,grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name,grp))
            c.execute("UPDATE BRM_RULE_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name,grp))
            c.execute("COMMIT")
            add_audit_log(self.connection,"RENAME_GROUP","BUSINESS_GROUPS",grp,"Admin",
                          {"old_group_name":grp},{"new_group_name":new_name})
            QMessageBox.information(self,"Success",f"Group renamed to {new_name}")
            self.load_data()
        except Exception as e:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"DB Error",str(e))

    def on_delete_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        confirm = QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Success","Group deleted.")
            self.load_data()
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

    def on_backup_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        try:
            ver = backup_group(self.connection, grp, "Admin")
            QMessageBox.information(self,"Backup Created",f"Group {grp} v{ver}")
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

    def on_restore_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        c = self.connection.cursor()
        c.execute("""
          SELECT BACKUP_VERSION,BACKUP_TIMESTAMP
          FROM BRM_GROUP_BACKUPS
          WHERE GROUP_NAME=?
          ORDER BY BACKUP_VERSION DESC
        """,(grp,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self,"No Backups",f"No backups for {grp}")
            return
        items = [f"Version {r['BACKUP_VERSION']} (ts {r['BACKUP_TIMESTAMP']})" for r in rows]
        sel, ok = QInputDialog.getItem(self,"Restore Group","Choose version:", items, 0, False)
        if not ok:
            return
        match = re.search(r"Version\s+(\d+)", sel)
        if not match:
            return
        chosen_ver = int(match.group(1))
        confirm = QMessageBox.question(self,"Restore",f"Restore {grp} to version {chosen_ver}? Overwrites current.")
        if confirm!=QMessageBox.Yes:
            return
        try:
            restore_group(self.connection, grp, chosen_ver, "Admin")
            QMessageBox.information(self,"Restored",f"{grp} => version {chosen_ver}")
            self.load_data()
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

    def get_selected_user(self):
        r = self.users_table.currentRow()
        if r<0:
            return None
        it = self.users_table.item(r,0)
        if not it:
            return None
        try:
            return int(it.text())
        except:
            return None

    def on_add_user_to_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"No selection","No user.")
            return
        grp,ok = QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT * FROM USERS WHERE USER_ID=?",(uid,))
        urow = c.fetchone()
        if not urow:
            QMessageBox.warning(self,"Error","User not found.")
            return
        if urow["USER_GROUP"]==grp.strip():
            QMessageBox.warning(self,"Error","User already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User added to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"No selection","No user selected.")
            return
        confirm = QMessageBox.question(self,"Confirm","Remove user from group?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    def on_add_permission(self):
        grp = self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group.")
            return
        tbl,ok = QInputDialog.getText(self,"Add Permission","Target table:")
        if not ok or not tbl.strip():
            return
        c = self.connection.cursor()
        c.execute("""
          INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)
        """,(grp,tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Permission {tbl} added to {grp}")
        self.load_permissions()

    def on_remove_permission(self):
        grp = self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group.")
            return
        r = self.perm_table.currentRow()
        if r<0:
            QMessageBox.warning(self,"No selection","No permission row.")
            return
        it = self.perm_table.item(r,0)
        if not it:
            QMessageBox.warning(self,"No selection","No table name found.")
            return
        tbl = it.text().strip()
        confirm = QMessageBox.question(self,"Confirm",f"Remove {tbl} from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp,tbl))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Permission {tbl} removed from {grp}.")
        self.load_permissions()

    def on_add_approver(self):
        grp = self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        username, ok = QInputDialog.getText(self,"Add Approver","Enter username:")
        if not ok or not username.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(username.strip(),))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","User not found.")
            return
        c.execute("""
          INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)
        """,(grp, username.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Approver Added",f"{username} => {grp}")
        self.load_approvers()

    def on_remove_approver(self):
        grp = self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group.")
            return
        row = self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"No selection","No approver row.")
            return
        it = self.appr_table.item(row,0)
        if not it:
            return
        appr_id = it.text().strip()
        confirm = QMessageBox.question(self,"Confirm",f"Remove Approver {appr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        self.connection.commit()
        QMessageBox.information(self,"Success","Approver removed.")
        self.load_approvers()

##############################################################################
# BACKUP & RESTORE GROUP HELPERS
##############################################################################
def backup_group(conn, group_name, action_by="System"):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE OWNER_GROUP=?",(group_name,))
    rules = c.fetchall()
    backup_data = {"rules":[]}
    for rule in rules:
        rdict = dict(rule)
        rid = rule["RULE_ID"]
        c.execute("SELECT * FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        rdict["dependencies"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_RULE_LINEAGE WHERE RULE_ID=?",(rid,))
        rdict["lineage"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?",(rid,))
        rdict["column_mappings"] = [dict(x) for x in c.fetchall()]
        backup_data["rules"].append(rdict)
    js = json.dumps(backup_data, default=str)
    c.execute("SELECT COALESCE(MAX(BACKUP_VERSION),0) as mv FROM BRM_GROUP_BACKUPS WHERE GROUP_NAME=?",(group_name,))
    row = c.fetchone()
    nextv = row["mv"]+1
    c.execute("""
      INSERT INTO BRM_GROUP_BACKUPS(GROUP_NAME,BACKUP_VERSION,BACKUP_JSON)
      VALUES(?,?,?)
    """,(group_name,nextv,js))
    conn.commit()
    add_audit_log(conn,"BACKUP","BRM_GROUP_BACKUPS",group_name,action_by,
                  {"group":group_name},{"version":nextv})
    return nextv

def restore_group(conn, group_name, backup_version, action_by="System"):
    c = conn.cursor()
    c.execute("""
      SELECT BACKUP_JSON
      FROM BRM_GROUP_BACKUPS
      WHERE GROUP_NAME=? AND BACKUP_VERSION=?
    """,(group_name,backup_version))
    row = c.fetchone()
    if not row:
        raise ValueError(f"No backup for {group_name} v{backup_version}")
    backup_data = json.loads(row["BACKUP_JSON"])

    c.execute("""
      DELETE FROM BRM_RULE_LINEAGE
      WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)
    """,(group_name,))
    c.execute("""
      DELETE FROM BRM_RULE_TABLE_DEPENDENCIES
      WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)
    """,(group_name,))
    c.execute("""
      DELETE FROM BRM_COLUMN_MAPPING
      WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)
    """,(group_name,))
    c.execute("DELETE FROM BRM_RULES WHERE OWNER_GROUP=?",(group_name,))

    for rdict in backup_data["rules"]:
        c.execute("""
          INSERT INTO BRM_RULES(
            RULE_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
            EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
            CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
            CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,GROUP_ID,
            APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
          ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
        """,(
          rdict["RULE_ID"], rdict["PARENT_RULE_ID"], rdict["RULE_TYPE_ID"],
          rdict["RULE_NAME"], rdict["RULE_SQL"], rdict["EFFECTIVE_START_DATE"],
          rdict["EFFECTIVE_END_DATE"], rdict["STATUS"], rdict["VERSION"],
          rdict["CREATED_BY"], rdict["DESCRIPTION"], rdict["OPERATION_TYPE"],
          rdict["BUSINESS_JUSTIFICATION"], rdict["CREATED_TIMESTAMP"],
          rdict["UPDATED_BY"], rdict["OWNER_GROUP"], rdict.get("CLUSTER_NAME",""),
          rdict.get("GROUP_ID",None), rdict.get("APPROVAL_STATUS","DRAFT"),
          rdict.get("IS_GLOBAL",0), rdict.get("CRITICAL_RULE",0),
          rdict.get("CRITICAL_SCOPE","NONE"),
          rdict.get("CDC_TYPE","NONE")
        ))
        rid = rdict["RULE_ID"]
        c.execute("SELECT LAST_INSERT_ROWID()")
        for d in rdict.get("dependencies",[]):
            c.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(d["DEPENDENCY_ID"], rid, d["DATABASE_NAME"], d["TABLE_NAME"], d["COLUMN_NAME"]))
        for l in rdict.get("lineage",[]):
            c.execute("""
              INSERT INTO BRM_RULE_LINEAGE(
                LINEAGE_ID,RULE_ID,SOURCE_INFO,TARGET_INFO,TRANSFORMATION_DETAILS,CREATED_TIMESTAMP
              ) VALUES(?,?,?,?,?,?)
            """,(l["LINEAGE_ID"], rid, l["SOURCE_INFO"], l["TARGET_INFO"],
                 l["TRANSFORMATION_DETAILS"], l["CREATED_TIMESTAMP"]))
        for m in rdict.get("column_mappings",[]):
            c.execute("""
              INSERT INTO BRM_COLUMN_MAPPING(
                MAPPING_ID,RULE_ID,SOURCE_RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(m["MAPPING_ID"], m["RULE_ID"], m["SOURCE_RULE_ID"],
                 m["SOURCE_COLUMN_NAME"], m["TARGET_COLUMN_NAME"]))
    conn.commit()
    add_audit_log(conn,"RESTORE","BRM_RULES",group_name,action_by,
                  {"group":group_name,"version":backup_version},None)

##############################################################################
# CUSTOM RULE GROUP TAB
##############################################################################
def backup_custom_group(conn, custom_group_id, action_by="System"):
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)
    c = conn.cursor()
    c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
    rowg = c.fetchone()
    if not rowg:
        raise ValueError("Custom group ID not found.")

    c.execute("""
      SELECT R.*
      FROM BRM_CUSTOM_GROUP_MEMBERS M
      JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
      WHERE M.CUSTOM_GROUP_ID=?
    """,(custom_group_id,))
    rules = c.fetchall()
    backup_data = {"rules":[]}
    for rule in rules:
        rd = dict(rule)
        rid = rule["RULE_ID"]
        c.execute("SELECT * FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        rd["dependencies"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_RULE_LINEAGE WHERE RULE_ID=?",(rid,))
        rd["lineage"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?",(rid,))
        rd["column_mappings"] = [dict(x) for x in c.fetchall()]
        backup_data["rules"].append(rd)

    c.execute("""
      SELECT COALESCE(MAX(BACKUP_VERSION),0) as mv
      FROM BRM_CUSTOM_GROUP_BACKUPS
      WHERE CUSTOM_GROUP_ID=?
    """,(custom_group_id,))
    row = c.fetchone()
    nextv = row["mv"]+1
    js = json.dumps(backup_data, default=str)
    c.execute("""
      INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID,BACKUP_VERSION,BACKUP_JSON)
      VALUES(?,?,?)
    """,(custom_group_id,nextv,js))
    conn.commit()
    add_audit_log(conn,"BACKUP_CUSTOM_GROUP","BRM_CUSTOM_GROUP_BACKUPS",
                  custom_group_id,action_by,
                  {"cgid":custom_group_id},{"version":nextv})
    return nextv

def restore_custom_group(conn, custom_group_id, backup_version, action_by="System"):
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)
    c = conn.cursor()
    c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
    rowg = c.fetchone()
    if not rowg:
        raise ValueError("Custom group not found.")

    c.execute("""
      SELECT BACKUP_JSON
      FROM BRM_CUSTOM_GROUP_BACKUPS
      WHERE CUSTOM_GROUP_ID=? AND BACKUP_VERSION=?
    """,(custom_group_id, backup_version))
    rowb = c.fetchone()
    if not rowb:
        raise ValueError("No backup found.")

    backup_data = json.loads(rowb["BACKUP_JSON"])
    c.execute("""
      SELECT RULE_ID
      FROM BRM_CUSTOM_GROUP_MEMBERS
      WHERE CUSTOM_GROUP_ID=?
    """,(custom_group_id,))
    mem_ids = [r["RULE_ID"] for r in c.fetchall()]
    if mem_ids:
        placeholders = ",".join(["?"]*len(mem_ids))
        c.execute(f"DELETE FROM BRM_RULE_LINEAGE WHERE RULE_ID IN ({placeholders})", mem_ids)
        c.execute(f"DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID IN ({placeholders})", mem_ids)
        c.execute(f"DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID IN ({placeholders})", mem_ids)
        c.execute(f"DELETE FROM BRM_RULES WHERE RULE_ID IN ({placeholders})", mem_ids)

    for rd in backup_data["rules"]:
        c.execute("""
          INSERT INTO BRM_RULES(
            RULE_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
            EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
            CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
            CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,GROUP_ID,
            APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE,CDC_TYPE
          ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
        """,(
          rd["RULE_ID"], rd["PARENT_RULE_ID"], rd["RULE_TYPE_ID"], rd["RULE_NAME"], rd["RULE_SQL"],
          rd["EFFECTIVE_START_DATE"], rd["EFFECTIVE_END_DATE"], rd["STATUS"], rd["VERSION"],
          rd["CREATED_BY"], rd["DESCRIPTION"], rd["OPERATION_TYPE"], rd["BUSINESS_JUSTIFICATION"],
          rd["CREATED_TIMESTAMP"], rd["UPDATED_BY"], rd["OWNER_GROUP"], rd.get("CLUSTER_NAME",""),
          rd.get("GROUP_ID",None), rd.get("APPROVAL_STATUS","DRAFT"),
          rd.get("IS_GLOBAL",0), rd.get("CRITICAL_RULE",0),
          rd.get("CRITICAL_SCOPE","NONE"), rd.get("CDC_TYPE","NONE")
        ))
        rid = rd["RULE_ID"]
        for d in rd.get("dependencies",[]):
            c.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(d["DEPENDENCY_ID"],rid,d["DATABASE_NAME"],d["TABLE_NAME"],d["COLUMN_NAME"]))
        for l in rd.get("lineage",[]):
            c.execute("""
              INSERT INTO BRM_RULE_LINEAGE(
                LINEAGE_ID,RULE_ID,SOURCE_INFO,TARGET_INFO,TRANSFORMATION_DETAILS,CREATED_TIMESTAMP
              ) VALUES(?,?,?,?,?,?)
            """,(l["LINEAGE_ID"],rid,l["SOURCE_INFO"],l["TARGET_INFO"],
                 l["TRANSFORMATION_DETAILS"],l["CREATED_TIMESTAMP"]))
        for m in rd.get("column_mappings",[]):
            c.execute("""
              INSERT INTO BRM_COLUMN_MAPPING(
                MAPPING_ID,RULE_ID,SOURCE_RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(m["MAPPING_ID"], m["RULE_ID"], m["SOURCE_RULE_ID"],
                 m["SOURCE_COLUMN_NAME"], m["TARGET_COLUMN_NAME"]))
        c.execute("""
          INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
          VALUES(?,?)
        """,(custom_group_id, rid))
    conn.commit()
    add_audit_log(conn,"RESTORE_CUSTOM_GROUP","BRM_CUSTOM_RULE_GROUPS",
                  custom_group_id,action_by,
                  {"cgid":custom_group_id,"version":backup_version},None)

class CustomRuleGroupTab(QWidget):
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        main_layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.new_group_name_edit = QLineEdit()
        self.new_group_name_edit.setPlaceholderText("Custom Group Name")
        top_h.addWidget(self.new_group_name_edit)
        create_btn = QPushButton("Create Custom Group")
        create_btn.clicked.connect(self.create_custom_group)
        top_h.addWidget(create_btn)
        main_layout.addLayout(top_h)

        self.custom_group_table = QTableWidget()
        self.custom_group_table.setColumnCount(3)
        self.custom_group_table.setHorizontalHeaderLabels(["Group ID","Group Name","Owner BG"])
        self.custom_group_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.custom_group_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.custom_group_table.itemSelectionChanged.connect(self.on_custom_group_selected)
        main_layout.addWidget(self.custom_group_table)

        splitter = QSplitter()
        splitter.setOrientation(Qt.Horizontal)

        self.rule_list = QTableWidget(0,3)
        self.rule_list.setHorizontalHeaderLabels(["Rule ID","Name","Owner BG"])
        self.rule_list.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_list.setEditTriggers(QAbstractItemView.NoEditTriggers)

        middle_v = QVBoxLayout()
        self.add_rule_btn = QPushButton("Add Rule ")
        self.add_rule_btn.clicked.connect(self.add_rule_to_custom_group)
        self.remove_rule_btn = QPushButton(" Remove Rule")
        self.remove_rule_btn.clicked.connect(self.remove_rule_from_custom_group)
        middle_v.addWidget(self.add_rule_btn)
        middle_v.addWidget(self.remove_rule_btn)
        middle_v.addStretch()
        mid_widget = QWidget()
        mid_widget.setLayout(middle_v)

        self.group_members_view = QTableWidget(0,3)
        self.group_members_view.setHorizontalHeaderLabels(["Rule ID","Name","Owner BG"])
        self.group_members_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.group_members_view.setEditTriggers(QAbstractItemView.NoEditTriggers)

        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.addWidget(self.rule_list)

        splitter.addWidget(left_widget)
        splitter.addWidget(mid_widget)

        right_widget = QWidget()
        rw_layout = QVBoxLayout(right_widget)
        rw_layout.addWidget(self.group_members_view)
        splitter.addWidget(right_widget)

        main_layout.addWidget(splitter)

        btm_h = QHBoxLayout()
        backup_btn = QPushButton("Backup Custom Group")
        backup_btn.clicked.connect(self.backup_selected_group)
        restore_btn = QPushButton("Restore Custom Group")
        restore_btn.clicked.connect(self.restore_selected_group)
        btm_h.addWidget(backup_btn)
        btm_h.addWidget(restore_btn)
        btm_h.addStretch()
        main_layout.addLayout(btm_h)

        self.setLayout(main_layout)
        self.load_custom_groups()
        self.load_all_rules()

    def create_custom_group(self):
        gname = self.new_group_name_edit.text().strip()
        if not gname:
            QMessageBox.warning(self,"Error","No name.")
            return
        c = self.connection.cursor()
        c.execute("""
          INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY)
          VALUES(?,?,?)
        """,(gname, self.user_group, f"UserID:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Created custom group {gname}.")
        self.new_group_name_edit.clear()
        self.load_custom_groups()

    def load_custom_groups(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
          FROM BRM_CUSTOM_RULE_GROUPS
          ORDER BY CUSTOM_GROUP_ID DESC
        """)
        rows = c.fetchall()
        self.custom_group_table.setRowCount(0)
        for row in rows:
            r = self.custom_group_table.rowCount()
            self.custom_group_table.insertRow(r)
            self.custom_group_table.setItem(r,0,QTableWidgetItem(str(row["CUSTOM_GROUP_ID"])))
            self.custom_group_table.setItem(r,1,QTableWidgetItem(row["CUSTOM_GROUP_NAME"]))
            self.custom_group_table.setItem(r,2,QTableWidgetItem(row["OWNER_BUSINESS_GROUP"]))

    def load_all_rules(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME,OWNER_GROUP
          FROM BRM_RULES
          ORDER BY RULE_ID DESC
        """)
        rows = c.fetchall()
        self.rule_list.setRowCount(0)
        for rd in rows:
            r = self.rule_list.rowCount()
            self.rule_list.insertRow(r)
            self.rule_list.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_list.setItem(r,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_list.setItem(r,2,QTableWidgetItem(rd["OWNER_GROUP"]))

    def on_custom_group_selected(self):
        sel = self.custom_group_table.selectedItems()
        if not sel:
            self.group_members_view.setRowCount(0)
            return
        row = sel[0].row()
        it = self.custom_group_table.item(row,0)
        if not it:
            self.group_members_view.setRowCount(0)
            return
        cgid = int(it.text())
        self.load_custom_group_members(cgid)

    def load_custom_group_members(self, cgid):
        c = self.connection.cursor()
        c.execute("""
          SELECT R.RULE_ID,R.RULE_NAME,R.OWNER_GROUP
          FROM BRM_CUSTOM_GROUP_MEMBERS M
          JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
          WHERE M.CUSTOM_GROUP_ID=?
          ORDER BY R.RULE_ID
        """,(cgid,))
        rows = c.fetchall()
        self.group_members_view.setRowCount(0)
        for rd in rows:
            r = self.group_members_view.rowCount()
            self.group_members_view.insertRow(r)
            self.group_members_view.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.group_members_view.setItem(r,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.group_members_view.setItem(r,2,QTableWidgetItem(rd["OWNER_GROUP"]))

    def get_selected_custom_group_id(self):
        sel = self.custom_group_table.selectedItems()
        if not sel:
            return None
        row = sel[0].row()
        it = self.custom_group_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_rule_to_custom_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        sel_rows = self.rule_list.selectionModel().selectedRows()
        if not sel_rows:
            QMessageBox.warning(self,"No Selection","No rule selected in 'All Rules'.")
            return
        c = self.connection.cursor()
        added_count=0
        for sr in sel_rows:
            row = sr.row()
            it = self.rule_list.item(row,0)
            if not it:
                continue
            rid = int(it.text())
            try:
                c.execute("""
                  INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                  VALUES(?,?)
                """,(cgid, rid))
                added_count+=1
            except Exception as e:
                logger.error(str(e))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"{added_count} rule(s) added.")
        self.load_custom_group_members(cgid)

    def remove_rule_from_custom_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        sel_rows = self.group_members_view.selectionModel().selectedRows()
        if not sel_rows:
            QMessageBox.warning(self,"No Selection","No rule in membership.")
            return
        c = self.connection.cursor()
        removed=0
        for sr in sel_rows:
            row = sr.row()
            it = self.group_members_view.item(row,0)
            if not it:
                continue
            rid = int(it.text())
            try:
                c.execute("""
                  DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                  WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(cgid, rid))
                removed+=1
            except Exception as e:
                logger.error(str(e))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"{removed} rule(s) removed.")
        self.load_custom_group_members(cgid)

    def backup_selected_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        try:
            ver = backup_custom_group(self.connection, cgid, f"User:{self.user_id}")
            QMessageBox.information(self,"Backup",f"Custom group backup version {ver} created.")
        except Exception as e:
            QMessageBox.critical(self,"Error",str(e))

    def restore_selected_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        c = self.connection.cursor()
        c.execute("""
          SELECT BACKUP_VERSION,BACKUP_TIMESTAMP
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
          ORDER BY BACKUP_VERSION DESC
        """,(cgid,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self,"No Backups",f"No backups for custom group {cgid}")
            return
        items = [f"Version {r['BACKUP_VERSION']} (ts {r['BACKUP_TIMESTAMP']})" for r in rows]
        sel,ok = QInputDialog.getItem(self,"Restore","Pick version:", items,0,False)
        if not ok:
            return
        m = re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver = int(m.group(1))
        confirm = QMessageBox.question(self,"Restore",
            f"Restore custom group {cgid} to version {ver}? Overwrites membership rules.")
        if confirm!=QMessageBox.Yes:
            return
        try:
            restore_custom_group(self.connection, cgid, ver, f"User:{self.user_id}")
            QMessageBox.information(self,"Restored",f"Custom group {cgid} => version {ver}")
            self.load_custom_group_members(cgid)
        except Exception as e:
            QMessageBox.critical(self,"Error",str(e))

##############################################################################
# APPROVAL PIPELINE WIDGET
##############################################################################
class ApprovalPipelineWidget(QWidget):
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(5)
        stages = ["BG1","BG2","BG3","FINAL"]
        for st in stages:
            circle = QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status = stage_status_map.get(st,"NotStarted")
            if status=="Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status=="Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status=="Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")
            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

##############################################################################
# MULTI-STEP APPROVAL TAB
##############################################################################
class MultiStepApprovalTab(QWidget):
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group
        main_layout = QVBoxLayout(self)

        self.appr_table = QTableWidget(0,7)
        self.appr_table.setHorizontalHeaderLabels([
            "Rule ID","Group Name","Rule Name","Stage","Approved?","Action","Pipeline"
        ])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main_layout.addWidget(self.appr_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        main_layout.addWidget(ref_btn)
        self.setLayout(main_layout)
        self.load_approvals()

    def load_approvals(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID,A.GROUP_NAME,A.USERNAME,A.APPROVED_FLAG,A.APPROVED_TIMESTAMP,A.APPROVAL_STAGE,
               R.RULE_NAME,R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows = c.fetchall()

        pipeline_data = {}
        all_app = self.connection.cursor()
        all_app.execute("SELECT * FROM BRM_RULE_APPROVALS")
        all_rows = all_app.fetchall()
        for apr in all_rows:
            rid = apr["RULE_ID"]
            grp = apr["GROUP_NAME"]
            stage = apr["APPROVAL_STAGE"]
            flag = apr["APPROVED_FLAG"]
            pipeline_data.setdefault(rid, {"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})
            if flag==1:
                pipeline_data[rid][grp] = "Approved"
            else:
                cur_st = get_current_approval_stage(self.connection, rid)
                if cur_st==stage:
                    pipeline_data[rid][grp] = "Pending"
                else:
                    pipeline_data[rid][grp] = "NotStarted"

        minimal_rows = []
        for rd in rows:
            rid = rd["RULE_ID"]
            st = rd["APPROVAL_STAGE"]
            min_st = get_current_approval_stage(self.connection, rid)
            if min_st==st:
                minimal_rows.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r,1,QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r,2,QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r,3,QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r,4,QTableWidgetItem(str(rd["APPROVED_FLAG"])))

            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, row_index=r: self.do_approve(row_index))
            self.appr_table.setCellWidget(r,5,approve_btn)

            pipe_map = pipeline_data.get(rd["RULE_ID"],{"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})
            pipe_widget = ApprovalPipelineWidget(pipe_map)
            self.appr_table.setCellWidget(r,6,pipe_widget)

    def do_approve(self, row_index):
        rid_item = self.appr_table.item(row_index,0)
        grp_item = self.appr_table.item(row_index,1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        group_name = grp_item.text()
        c = self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
          WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """,(rule_id, group_name, self.logged_in_username))

        nxt = get_current_approval_stage(self.connection, rule_id)
        if nxt is None:
            c.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE'
              WHERE RULE_ID=?
            """,(rule_id,))
        else:
            c.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
              WHERE RULE_ID=?
            """,(rule_id,))

        self.connection.commit()
        QMessageBox.information(self,"Approved",f"You approved rule {rule_id}.")
        self.load_approvals()

##############################################################################
# LINEAGE GRAPH VISUALIZATION
##############################################################################
class RuleRectItem(QtWidgets.QGraphicsRectItem):
    def __init__(self, x,y,w,h, rule_data, cluster_name="", parent=None):
        super().__init__(x,y,w,h,parent)
        self.rule_data = rule_data
        self.cluster_name = cluster_name
        self.highlighted=False

    def setHighlight(self, highlight):
        self.highlighted=highlight
        if highlight:
            self.setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
        else:
            self.setPen(QtGui.QPen(QtCore.Qt.black,2))

class RuleEllipseItem(QtWidgets.QGraphicsEllipseItem):
    def __init__(self, x,y,w,h, rule_data, cluster_name="", parent=None):
        super().__init__(x,y,w,h,parent)
        self.rule_data = rule_data
        self.cluster_name = cluster_name
        self.highlighted=False

    def setHighlight(self, highlight):
        self.highlighted=highlight
        if highlight:
            self.setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
        else:
            self.setPen(QtGui.QPen(QtCore.Qt.black,2))

class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.children_map={}
        self.parents_map={}

        self.detail_dock = QDockWidget("Rule Details", self.parentWidget())
        self.detail_panel = QTextEdit()
        self.detail_panel.setReadOnly(True)
        self.detail_dock.setWidget(self.detail_panel)
        self.detail_dock.setAllowedAreas(Qt.LeftDockWidgetArea|Qt.RightDockWidgetArea)
        mw = self.find_main_window()
        if mw:
            mw.addDockWidget(Qt.RightDockWidgetArea, self.detail_dock)

        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def find_main_window(self):
        w = self.parent()
        while w:
            if isinstance(w, QMainWindow):
                return w
            w = w.parent()
        return None

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c = self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,CLUSTER_NAME,IS_GLOBAL,CRITICAL_RULE
          FROM BRM_RULES
          ORDER BY RULE_ID
        """)
        rules = c.fetchall()
        if not rules:
            no_data = QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(no_data)
            return

        for r in rules:
            rid = r["RULE_ID"]
            pid = r["PARENT_RULE_ID"]
            if pid:
                self.children_map.setdefault(pid,[]).append(rid)
                self.parents_map[rid] = pid

        rule_lookup = {r["RULE_ID"]:r for r in rules}
        roots = [r for r in rules if not r["PARENT_RULE_ID"]]

        queue = deque()
        level_map={}
        visited=set()

        for rt in roots:
            queue.append((rt["RULE_ID"],0))

        while queue:
            (rid, depth) = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            rinfo = rule_lookup[rid]
            c_so_far = level_map.get(depth,0)
            level_map[depth]=c_so_far+1
            x = depth*220
            y = c_so_far*120
            node_item = self.create_node(rinfo)
            node_item.setPos(x,y)
            self.scene.addItem(node_item)
            self.node_map[rid]=node_item

            if rid in self.children_map:
                for ch in self.children_map[rid]:
                    queue.append((ch, depth+1))

        for r in rules:
            pid = r["PARENT_RULE_ID"]
            rid = r["RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(pid, rid)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.resetView()

    def create_node(self, rinfo):
        rtype = rinfo["RULE_TYPE_ID"]
        status = rinfo["STATUS"]
        cluster = rinfo.get("CLUSTER_NAME","") or ""
        isg = rinfo["IS_GLOBAL"]
        icrit = rinfo["CRITICAL_RULE"]

        if rtype==1:
            node = RuleRectItem(0,0,120,50,rinfo,cluster)
        else:
            node = RuleEllipseItem(0,0,120,50,rinfo,cluster)

        if status.lower()=="active":
            basecol = QtGui.QColor("lightgreen")
        else:
            basecol = QtGui.QColor("tomato")

        if cluster:
            hval = abs(hash(cluster))%360
            basecol = QtGui.QColor.fromHsv(hval,128,255)

        node.setBrush(QtGui.QBrush(basecol))

        pen = QtGui.QPen(QtCore.Qt.black,2)
        if icrit==1:
            pen = QtGui.QPen(QtGui.QColor("red"),3)
        node.setPen(pen)

        if isg==1:
            rinfo["RULE_NAME"] = f"(G) {rinfo['RULE_NAME']}"

        return node

    def draw_edge(self, parent_id, child_id):
        p_item = self.node_map[parent_id]
        c_item = self.node_map[child_id]
        p_rect = p_item.sceneBoundingRect()
        c_rect = c_item.sceneBoundingRect()
        line = QtWidgets.QGraphicsLineItem(p_rect.center().x(), p_rect.center().y(),
                                           c_rect.center().x(), c_rect.center().y())
        line.setPen(QtGui.QPen(QtGui.QColor("darkblue"),2))
        self.scene.addItem(line)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if event.button()==Qt.LeftButton:
            item = self.itemAt(event.pos())
            if isinstance(item, (RuleRectItem,RuleEllipseItem)):
                self.show_rule_details(item.rule_data)
        super().mousePressEvent(event)

    def show_rule_details(self, rinfo):
        msg = (
            f"Rule ID: {rinfo['RULE_ID']}\n"
            f"Name: {rinfo['RULE_NAME']}\n"
            f"Status: {rinfo['STATUS']}\n"
            f"Type ID: {rinfo['RULE_TYPE_ID']}\n"
            f"Parent: {rinfo['PARENT_RULE_ID']}\n"
            f"Global?: {rinfo['IS_GLOBAL']}\n"
            f"Critical?: {rinfo['CRITICAL_RULE']}\n"
        )
        self.detail_panel.setPlainText(msg)

    def show_context_menu(self, pos):
        item = self.itemAt(pos)
        menu = QtWidgets.QMenu()
        if isinstance(item, (RuleRectItem,RuleEllipseItem)):
            rinfo = item.rule_data
            edit_act = QtWidgets.QAction("Edit Rule", menu)
            def on_edit():
                c = self.connection.cursor()
                c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rinfo["RULE_ID"],))
                row = c.fetchone()
                if not row:
                    QMessageBox.warning(self,"Not Found","Rule not found.")
                    return
                rowd = dict(row)
                c2 = self.connection.cursor()
                c2.execute("SELECT RULE_TYPE_NAME,RULE_TYPE_ID FROM BRM_RULE_TYPES")
                rts = c2.fetchall()
                rmap = {rp["RULE_TYPE_NAME"]: rp["RULE_TYPE_ID"] for rp in rts}
                dlg = RuleEditorDialog(self.connection, rmap, "Admin", rowd, parent=self)
                dlg.exec_()
                self.populate_graph()
            edit_act.triggered.connect(on_edit)
            menu.addAction(edit_act)

            ance_act = QtWidgets.QAction("Highlight Ancestors", menu)
            def on_ance():
                self.highlight_ancestors(rinfo["RULE_ID"])
            ance_act.triggered.connect(on_ance)
            menu.addAction(ance_act)

            desc_act = QtWidgets.QAction("Highlight Descendants", menu)
            def on_desc():
                self.highlight_descendants(rinfo["RULE_ID"])
            desc_act.triggered.connect(on_desc)
            menu.addAction(desc_act)
        else:
            clear_act = QtWidgets.QAction("Clear Highlights", menu)
            def on_clear():
                self.clear_highlights()
            clear_act.triggered.connect(on_clear)
            menu.addAction(clear_act)

        menu.exec_(self.mapToGlobal(pos))

    def highlight_ancestors(self, start_id):
        self.clear_highlights()
        cur = start_id
        while cur in self.parents_map:
            node = self.node_map.get(cur)
            if node:
                node.setHighlight(True)
            par = self.parents_map[cur]
            if par in self.node_map:
                self.node_map[par].setHighlight(True)
            cur = par if par else None

    def highlight_descendants(self, start_id):
        self.clear_highlights()
        queue = deque([start_id])
        visited=set()
        while queue:
            cid = queue.popleft()
            if cid in visited:
                continue
            visited.add(cid)
            if cid in self.node_map:
                self.node_map[cid].setHighlight(True)
            if cid in self.children_map:
                for ch in self.children_map[cid]:
                    queue.append(ch)

    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setHighlight(False)

    def search_nodes(self, query):
        self.clear_highlights()
        c = self.connection.cursor()
        ql = query.lower()
        found_any=False

        # Search rule name or ID
        for rid,node in self.node_map.items():
            nm = node.rule_data["RULE_NAME"].lower()
            rid_str = str(node.rule_data["RULE_ID"])
            if ql in nm or ql==rid_str:
                node.setHighlight(True)
                found_any=True

        # Search column mappings
        c.execute("""
          SELECT RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
          FROM BRM_COLUMN_MAPPING
          WHERE LOWER(SOURCE_COLUMN_NAME) LIKE ? OR LOWER(TARGET_COLUMN_NAME) LIKE ?
        """,(f"%{ql}%", f"%{ql}%"))
        matches = c.fetchall()
        for row in matches:
            cid = row["RULE_ID"]
            if cid in self.node_map:
                self.node_map[cid].setHighlight(True)
                found_any=True

        if not found_any:
            QMessageBox.information(self,"No Match",f"No rule or column found for '{query}'")

##############################################################################
# CONTROL TABLES TAB
##############################################################################
class CtrlTablesTab(QWidget):
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table_list = [
            "USERS",
            "BUSINESS_GROUPS",
            "GROUP_PERMISSIONS",
            "BRM_RULE_TYPES",
            "BRM_RULE_GROUPS",
            "BRM_RULES",
            "BRM_RULE_TABLE_DEPENDENCIES",
            "BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE",
            "BRM_GROUP_BACKUPS",
            "BRM_COLUMN_MAPPING",
            "BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS",
            "BUSINESS_GROUP_APPROVERS",
            "BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS",
            "BRM_GLOBAL_CRITICAL_LINKS"
        ]
        self.table_combo = QComboBox()
        for t in self.table_list:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn = QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.table_view = QTableWidget(0,0)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.table_view)

        self.setLayout(layout)

    def on_load_data(self):
        tbl = self.table_combo.currentText()
        if not tbl:
            return
        c = self.connection.cursor()
        c.execute(f"PRAGMA table_info({tbl})")
        info = c.fetchall()
        col_names = [x["name"] for x in info]
        if not col_names:
            c.execute(f"SELECT * FROM {tbl} LIMIT 1")
            col_names = [d[0] for d in c.description]
        c.execute(f"SELECT * FROM {tbl}")
        rows = c.fetchall()

        self.table_view.setRowCount(0)
        self.table_view.setColumnCount(len(col_names))
        self.table_view.setHorizontalHeaderLabels(col_names)

        for rd in rows:
            r = self.table_view.rowCount()
            self.table_view.insertRow(r)
            for j,cn in enumerate(col_names):
                val = rd[cn]
                item_str = str(val) if val is not None else ""
                self.table_view.setItem(r, j, QTableWidgetItem(item_str))

##############################################################################
# GLOBAL/CRITICAL ADMIN TAB
##############################################################################
class GlobalCriticalAdminTab(QWidget):
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)
        if self.user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Only Admin can manage global/critical rules."))
            self.setLayout(layout)
            return

        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Search Rule Name/SQL:"))
        self.search_edit = QLineEdit()
        filter_layout.addWidget(self.search_edit)
        btn_filter = QPushButton("Filter")
        btn_filter.clicked.connect(self.load_rule_list)
        filter_layout.addWidget(btn_filter)
        filter_layout.addStretch()
        layout.addLayout(filter_layout)

        self.rule_table = QTableWidget(0,6)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Name","Owner Group","Global?","Critical?","Scope"
        ])
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.rule_table)

        btn_row = QHBoxLayout()
        btn_g_on = QPushButton("Mark Selected As Global")
        btn_g_on.clicked.connect(self.mark_selected_as_global)
        btn_row.addWidget(btn_g_on)

        btn_g_off = QPushButton("Unmark Selected As Global")
        btn_g_off.clicked.connect(self.unmark_selected_as_global)
        btn_row.addWidget(btn_g_off)

        btn_c_on = QPushButton("Mark Selected As Critical")
        btn_c_on.clicked.connect(self.mark_selected_as_critical)
        btn_row.addWidget(btn_c_on)

        btn_c_off = QPushButton("Unmark Selected As Critical")
        btn_c_off.clicked.connect(self.unmark_selected_as_critical)
        btn_row.addWidget(btn_c_off)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        btn_row.addWidget(QLabel("Set Scope:"))
        btn_row.addWidget(self.scope_combo)

        btn_scope = QPushButton("Apply Scope to Selected")
        btn_scope.clicked.connect(self.apply_scope_to_selected)
        btn_row.addWidget(btn_scope)
        btn_row.addStretch()
        layout.addLayout(btn_row)

        link_box = QHBoxLayout()
        self.gcr_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Select Parent GCR Rule:"))
        link_box.addWidget(self.gcr_rule_combo)

        self.child_rule_combo = QComboBox()
        link_box.addWidget(QLabel("Child Rule to Link/Unlink:"))
        link_box.addWidget(self.child_rule_combo)

        btn_link = QPushButton("Link Child")
        btn_link.clicked.connect(self.link_child_rule)
        link_box.addWidget(btn_link)

        btn_unlink = QPushButton("Unlink Child")
        btn_unlink.clicked.connect(self.unlink_child_rule)
        link_box.addWidget(btn_unlink)

        link_box.addStretch()
        layout.addLayout(link_box)

        self.link_view = QTableWidget(0,2)
        self.link_view.setHorizontalHeaderLabels(["Parent GCR ID","Child Rule ID"])
        self.link_view.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.link_view)

        ref_btn = QPushButton("Refresh Everything")
        ref_btn.clicked.connect(self.refresh_all)
        layout.addWidget(ref_btn)
        self.setLayout(layout)
        self.refresh_all()

    def refresh_all(self):
        self.load_rule_list()
        self.populate_gcr_rule_combo()
        self.populate_child_rule_combo()
        self.load_link_view()

    def load_rule_list(self):
        txt = self.search_edit.text().strip()
        c = self.connection.cursor()
        if txt:
            c.execute("""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE
                FROM BRM_RULES
                WHERE RULE_NAME LIKE ? OR RULE_SQL LIKE ?
                ORDER BY RULE_ID DESC
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
                SELECT RULE_ID,RULE_NAME,OWNER_GROUP,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE
                FROM BRM_RULES
                ORDER BY RULE_ID DESC
            """)
        rows = c.fetchall()
        self.rule_table.setRowCount(0)
        for row in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r,0,QTableWidgetItem(str(row["RULE_ID"])))
            self.rule_table.setItem(r,1,QTableWidgetItem(row["RULE_NAME"]))
            self.rule_table.setItem(r,2,QTableWidgetItem(row["OWNER_GROUP"]))
            g_str = "YES" if row["IS_GLOBAL"]==1 else "NO"
            self.rule_table.setItem(r,3,QTableWidgetItem(g_str))
            c_str = "YES" if row["CRITICAL_RULE"]==1 else "NO"
            self.rule_table.setItem(r,4,QTableWidgetItem(c_str))
            sc_str = row["CRITICAL_SCOPE"]
            self.rule_table.setItem(r,5,QTableWidgetItem(sc_str))

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        rids = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row,0)
            if it:
                rids.append(int(it.text()))
        return rids

    def mark_selected_as_global(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No selection","No rule(s) selected.")
            return
        c = self.connection.cursor()
        for rid in rids:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            old = c.fetchone()
            if not old:
                continue
            rd = dict(old)
            rd["IS_GLOBAL"] = 1
            try:
                update_rule(self.connection, rd, "Admin", "Admin")
            except Exception as e:
                logger.error(e)
        QMessageBox.information(self,"Global Applied",f"{len(rids)} rule(s) marked global.")
        self.load_rule_list()

    def unmark_selected_as_global(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No selection","No rule(s).")
            return
        c = self.connection.cursor()
        for rid in rids:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            old = c.fetchone()
            if not old:
                continue
            rd = dict(old)
            rd["IS_GLOBAL"] = 0
            try:
                update_rule(self.connection, rd, "Admin", "Admin")
            except Exception as e:
                logger.error(e)
        QMessageBox.information(self,"Global Removed",f"{len(rids)} rule(s) unmarked global.")
        self.load_rule_list()

    def mark_selected_as_critical(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No selection","No rule(s).")
            return
        c = self.connection.cursor()
        for rid in rids:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            old = c.fetchone()
            if not old:
                continue
            rd = dict(old)
            rd["CRITICAL_RULE"] = 1
            try:
                update_rule(self.connection, rd, "Admin", "Admin")
            except Exception as e:
                logger.error(e)
        QMessageBox.information(self,"Critical Applied",f"{len(rids)} rule(s) marked critical.")
        self.load_rule_list()

    def unmark_selected_as_critical(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No selection","No rule(s).")
            return
        c = self.connection.cursor()
        for rid in rids:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            old = c.fetchone()
            if not old:
                continue
            rd = dict(old)
            rd["CRITICAL_RULE"] = 0
            rd["CRITICAL_SCOPE"] = "NONE"
            try:
                update_rule(self.connection, rd, "Admin", "Admin")
            except Exception as e:
                logger.error(e)
        QMessageBox.information(self,"Critical Removed",f"{len(rids)} rule(s) unmarked critical.")
        self.load_rule_list()

    def apply_scope_to_selected(self):
        rids = self.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"No selection","No rule(s).")
            return
        chosen_scope = self.scope_combo.currentText()
        c = self.connection.cursor()
        for rid in rids:
            c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
            old = c.fetchone()
            if not old:
                continue
            rd = dict(old)
            rd["CRITICAL_SCOPE"] = chosen_scope
            try:
                update_rule(self.connection, rd, "Admin", "Admin")
            except Exception as e:
                logger.error(e)
        QMessageBox.information(self,"Scope Applied",f"Scope '{chosen_scope}' applied to {len(rids)} rule(s).")
        self.load_rule_list()

    def populate_gcr_rule_combo(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME
          FROM BRM_RULES
          WHERE IS_GLOBAL=1 OR CRITICAL_RULE=1
          ORDER BY RULE_ID
        """)
        rows = c.fetchall()
        self.gcr_rule_combo.clear()
        for row in rows:
            disp = f"ID:{row['RULE_ID']} - {row['RULE_NAME']}"
            self.gcr_rule_combo.addItem(disp, row["RULE_ID"])

    def populate_child_rule_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES ORDER BY RULE_ID")
        rows = c.fetchall()
        self.child_rule_combo.clear()
        for row in rows:
            disp = f"ID:{row['RULE_ID']} - {row['RULE_NAME']}"
            self.child_rule_combo.addItem(disp, row["RULE_ID"])

    def link_child_rule(self):
        parent_id = self.gcr_rule_combo.currentData()
        child_id = self.child_rule_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self,"Error","Select a parent and child rule.")
            return
        c = self.connection.cursor()
        c.execute("""
            INSERT OR IGNORE INTO BRM_GLOBAL_CRITICAL_LINKS(GCR_RULE_ID,TARGET_RULE_ID)
            VALUES(?,?)
        """,(parent_id, child_id))
        self.connection.commit()
        QMessageBox.information(self,"Linked",f"Child rule {child_id} linked to GCR {parent_id}")
        self.load_link_view()

    def unlink_child_rule(self):
        parent_id = self.gcr_rule_combo.currentData()
        child_id = self.child_rule_combo.currentData()
        if not parent_id or not child_id:
            QMessageBox.warning(self,"Error","Select a parent and child rule.")
            return
        c = self.connection.cursor()
        c.execute("""
            DELETE FROM BRM_GLOBAL_CRITICAL_LINKS
            WHERE GCR_RULE_ID=? AND TARGET_RULE_ID=?
        """,(parent_id, child_id))
        self.connection.commit()
        QMessageBox.information(self,"Unlinked",f"Child rule {child_id} unlinked from GCR {parent_id}")
        self.load_link_view()

    def load_link_view(self):
        c = self.connection.cursor()
        c.execute("SELECT GCR_RULE_ID, TARGET_RULE_ID FROM BRM_GLOBAL_CRITICAL_LINKS ORDER BY GCR_RULE_ID")
        rows = c.fetchall()
        self.link_view.setRowCount(0)
        for row in rows:
            r = self.link_view.rowCount()
            self.link_view.insertRow(r)
            self.link_view.setItem(r,0,QTableWidgetItem(str(row["GCR_RULE_ID"])))
            self.link_view.setItem(r,1,QTableWidgetItem(str(row["TARGET_RULE_ID"])))

##############################################################################
# RULE EXPLORER TAB
##############################################################################
class RuleExplorerTab(QWidget):
    def __init__(self, main_app, connection, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        layout = QVBoxLayout(self)
        lbl = QLabel("Rule Explorer (Tables => Referencing Rules)")
        lbl.setStyleSheet("font-weight:bold;")
        layout.addWidget(lbl)

        self.tree = QTreeWidget()
        self.tree.setHeaderLabels(["Database.Table / Rule"])
        self.tree.itemDoubleClicked.connect(self.on_item_double_clicked)
        layout.addWidget(self.tree)

        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh Explorer")
        ref_btn.clicked.connect(self.load_explorer)
        btn_h.addWidget(ref_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)
        self.load_explorer()

    def load_explorer(self):
        self.tree.clear()
        c = self.connection.cursor()
        c.execute("""
          SELECT DISTINCT DATABASE_NAME, TABLE_NAME
          FROM BRM_RULE_TABLE_DEPENDENCIES
          ORDER BY TABLE_NAME
        """)
        tables = c.fetchall()
        for tbl in tables:
            dbn = tbl["DATABASE_NAME"]
            tn = tbl["TABLE_NAME"]
            parent_item = QTreeWidgetItem([f"{dbn}.{tn}" if dbn else tn])
            self.tree.addTopLevelItem(parent_item)

            c.execute("""
              SELECT d.RULE_ID, r.RULE_NAME
              FROM BRM_RULE_TABLE_DEPENDENCIES d
              JOIN BRM_RULES r ON d.RULE_ID = r.RULE_ID
              WHERE d.DATABASE_NAME=? AND d.TABLE_NAME=?
              ORDER BY d.RULE_ID
            """,(dbn, tn))
            refs = c.fetchall()
            for rr in refs:
                rid = rr["RULE_ID"]
                rname = rr["RULE_NAME"]
                child = QTreeWidgetItem([f"Rule {rid}: {rname}"])
                child.setData(0, Qt.UserRole, rid)
                parent_item.addChild(child)
        self.tree.expandAll()

    def on_item_double_clicked(self, item, col):
        rid = item.data(0, Qt.UserRole)
        if not rid:
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found",f"No rule with ID={rid}")
            return
        rule_data = dict(row)
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.main_app.user_group, rule_data, self)
        if dlg.exec_()==QDialog.Accepted:
            self.load_explorer()

##############################################################################
# MAIN WINDOW
##############################################################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool - Multi-Step Approvals + CDC + Explorer")
        self.resize(1200,800)
        self.connection = setup_in_memory_db()

        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_() == QDialog.Accepted:
            self.user_id = self.login_dialog.user_id
            c = self.connection.cursor()
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
            row = c.fetchone()
            self.logged_in_username = row["USERNAME"] if row else "Unknown"
            c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(self.user_id,))
            row2 = c.fetchone()
            self.user_group = row2["USER_GROUP"] if row2 else "Unknown"
            self.init_ui()
        else:
            sys.exit()

    def init_ui(self):
        cw = QWidget()
        lay = QVBoxLayout(cw)

        if self.user_group=="Admin":
            self.switch_combo = QComboBox()
            self.populate_switch_combo()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h = QHBoxLayout()
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            lay.addLayout(top_h)

        self.tabs = QTabWidget()
        lay.addWidget(self.tabs)

        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab,"Business Rule Management")

        if self.user_group=="Admin":
            self.grp_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_tab,"Group Management")

        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        line_w = QWidget()
        lw_layout = QVBoxLayout(line_w)
        lw_layout.addWidget(QLabel("Lineage Visualization"))
        lw_btn_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule or column...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        lw_btn_h.addWidget(self.lineage_search)
        lw_btn_h.addWidget(s_btn)
        lw_btn_h.addWidget(rst_btn)
        lw_btn_h.addWidget(ref_btn)
        lw_btn_h.addStretch()
        lw_layout.addLayout(lw_btn_h)
        lw_layout.addWidget(self.lineage_tab)
        line_w.setLayout(lw_layout)
        self.tabs.addTab(line_w,"Lineage Visualization")
        self.lineage_tab.populate_graph()

        self.custom_tab = CustomRuleGroupTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Rule Groups")

        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        if self.user_group=="Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        self.rule_explorer_tab = RuleExplorerTab(self, self.connection)
        self.tabs.addTab(self.rule_explorer_tab, "Rule Explorer")

        cw.setLayout(lay)
        self.setCentralWidget(cw)

        self.init_timer()
        self.show()

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = c.fetchall()
        for row in rows:
            disp = f"{row['USERNAME']} ({row['USER_GROUP']})"
            self.switch_combo.addItem(disp,(row["USER_ID"], row["USER_GROUP"]))

    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_ug = data
        if new_uid==self.user_id and new_ug==self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_ug
        QMessageBox.information(self,"Switched User",f"Now impersonating user_id={new_uid}, group={new_ug}.")

    def init_timer(self):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)

    def refresh_approvals(self):
        self.approv_tab.load_approvals()

    def get_rule_types(self):
        c = self.connection.cursor()
        c.execute("SELECT RULE_TYPE_NAME,RULE_TYPE_ID FROM BRM_RULE_TYPES")
        rows = c.fetchall()
        return {r["RULE_TYPE_NAME"]: r["RULE_TYPE_ID"] for r in rows}

    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search_rule_dialog(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except Exception:
                pass
        event.accept()

##############################################################################
# MAIN
##############################################################################
def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()