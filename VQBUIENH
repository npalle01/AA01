#!/usr/bin/env python3
# vqb_federated_fixed.py
#
# A fully integrated Python/PyQt Visual Query Builder with:
#  - Multi-DB connections (Teradata / SQL Server / etc.)
#  - BFS multi-join & column-to-column lines
#  - Collapsible BFS source + target for DML (INSERT/UPDATE/DELETE)
#  - Filter/Group/Sort panels + Pivot Wizard
#  - Expression Builder & Window Function Wizard
#  - Data Profiler => "ERR(reason)" + Outlier Chart
#  - Nested subqueries & Sub-VQB
#  - CTE panel => "virtual tables" on the canvas
#  - "SQL Import" using sqlglot (no forced "ansi")
#  - Advanced cross-DB federation => Linked Server Config rewriting references
#  - No forced LIMIT in run_sql
#  - Fixes to table-dragging & BFS DML mapping
#
# Requires: pyodbc, sqlparse, sqlglot, PyQt5, matplotlib

import sys
import traceback
import logging
import pyodbc
import sqlparse
import sqlglot
from sqlglot import exp

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QPointF, QTimer, QThreadPool, QRunnable, pyqtSignal, QObject,
    QRegularExpression
)
from PyQt5.QtGui import (
    QPalette, QColor, QPen, QBrush, QFont, QSyntaxHighlighter, QTextCharFormat,
    QPixmap
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTreeWidget, QTreeWidgetItem, QTextEdit, QPushButton, QSplitter,
    QLineEdit, QLabel, QDialog, QFormLayout, QComboBox, QTableWidget,
    QTableWidgetItem, QTabWidget, QMessageBox, QGraphicsView,
    QGraphicsScene, QGraphicsRectItem, QGraphicsTextItem, QGraphicsItem,
    QGraphicsLineItem, QProgressBar, QDialogButtonBox, QStatusBar,
    QGroupBox, QAbstractItemView, QSpinBox, QMenu, QFrame, QAction,
    QListWidget, QCheckBox, QHeaderView
)

import matplotlib
matplotlib.use("Agg")
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure


###############################################################################
# 1) Logging + Apply Fusion Style
###############################################################################
logging.basicConfig(
    filename="vqb.log",
    filemode="a",
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.DEBUG
)
pyodbc.pooling = True

def apply_fusion_style():
    QApplication.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(240,240,240))
    palette.setColor(QPalette.WindowText, Qt.black)
    palette.setColor(QPalette.Base, QColor(255,255,255))
    palette.setColor(QPalette.AlternateBase, QColor(225,225,225))
    palette.setColor(QPalette.ToolTipBase, Qt.yellow)
    palette.setColor(QPalette.ToolTipText, Qt.black)
    palette.setColor(QPalette.Button, QColor(230,230,230))
    palette.setColor(QPalette.ButtonText, Qt.black)
    palette.setColor(QPalette.Highlight, QColor(76,163,224))
    palette.setColor(QPalette.HighlightedText, Qt.white)
    QApplication.setPalette(palette)

    style_sheet = """
        QCheckBox::indicator, QRadioButton::indicator {
            width: 12px;
            height: 12px;
            spacing: 2px;
        }
    """
    QApplication.instance().setStyleSheet(style_sheet)

###############################################################################
# 2) ODBC + MultiODBC
###############################################################################
class ODBCConnectDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._conn=None
        self._db_type=None
        self.setWindowTitle("Connect to ODBC")
        self.resize(400,230)

        layout=QVBoxLayout(self)
        layout.addWidget(QLabel("ODBC DSN (Teradata / SQLServer / etc.):"))
        self.dsn_combo=QComboBox()
        try:
            dsns=pyodbc.dataSources()
            for d in sorted(dsns.keys()):
                self.dsn_combo.addItem(d)
        except:
            pass
        layout.addWidget(self.dsn_combo)

        layout.addWidget(QLabel("Username (optional):"))
        self.user_edit=QLineEdit()
        layout.addWidget(self.user_edit)

        layout.addWidget(QLabel("Password (optional):"))
        self.pass_edit=QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(self.pass_edit)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        dsn=self.dsn_combo.currentText().strip()
        if not dsn:
            QMessageBox.warning(self,"No DSN","Please pick a DSN.")
            return
        user=self.user_edit.text().strip()
        pwd=self.pass_edit.text().strip()

        conn_str=f"DSN={dsn};"
        if user:
            conn_str+=f"UID={user};"
        if pwd:
            conn_str+=f"PWD={pwd};"
        try:
            cn=pyodbc.connect(conn_str, autocommit=True)
            self._conn=cn
            try:
                dbms=cn.getinfo(pyodbc.SQL_DBMS_NAME) or ""
                if "TERADATA" in dbms.upper():
                    self._db_type="Teradata"
                elif "SQL SERVER" in dbms.upper():
                    self._db_type="SQLServer"
                else:
                    self._db_type=dbms.strip()
            except:
                self._db_type="Unknown"
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self,"Connect Error",f"Failed:\n{ex}")

    def get_connection(self):
        return self._conn
    def get_db_type(self):
        return self._db_type

class MultiODBCConnectDialog(QDialog):
    def __init__(self, existing_conns=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Manage DB Connections")
        self.resize(500,300)
        self._connections=existing_conns if existing_conns else {}

        layout=QVBoxLayout(self)
        instruct=QLabel("Add or Remove ODBC connections (Teradata / SQLServer, etc.).")
        layout.addWidget(instruct)

        self.conn_table=QTableWidget(0,3)
        self.conn_table.setHorizontalHeaderLabels(["Alias","DB Type","Status"])
        self.conn_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.conn_table)

        # populate
        for alias,info in self._connections.items():
            r=self.conn_table.rowCount()
            self.conn_table.insertRow(r)
            self.conn_table.setItem(r,0,QTableWidgetItem(alias))
            dbt=info.get("db_type","Unknown")
            self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
            st="OK" if info.get("connection") else "NoConn"
            self.conn_table.setItem(r,2,QTableWidgetItem(st))

        btns=QHBoxLayout()
        add_btn=QPushButton("Add Connection")
        rm_btn=QPushButton("Remove Connection")
        close_btn=QPushButton("Close")
        btns.addWidget(add_btn)
        btns.addWidget(rm_btn)
        btns.addStretch()
        btns.addWidget(close_btn)
        layout.addLayout(btns)

        add_btn.clicked.connect(self.on_add)
        rm_btn.clicked.connect(self.on_rm)
        close_btn.clicked.connect(self.accept)

        self.setLayout(layout)

    def on_add(self):
        d=ODBCConnectDialog(self)
        if d.exec_()==QDialog.Accepted:
            c=d.get_connection()
            dbt=d.get_db_type()
            if c:
                alias=f"{dbt}_{len(self._connections)+1}"
                self._connections[alias]={"connection":c,"db_type":dbt}
                r=self.conn_table.rowCount()
                self.conn_table.insertRow(r)
                self.conn_table.setItem(r,0,QTableWidgetItem(alias))
                self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
                self.conn_table.setItem(r,2,QTableWidgetItem("OK"))

    def on_rm(self):
        rows=self.conn_table.selectionModel().selectedRows()
        if not rows:
            return
        for rr in sorted([r.row() for r in rows],reverse=True):
            alias_item=self.conn_table.item(rr,0)
            if alias_item:
                alias=alias_item.text()
                if alias in self._connections:
                    del self._connections[alias]
            self.conn_table.removeRow(rr)

    def get_connections(self):
        return self._connections

###############################################################################
# 3) LinkedServerConfigDialog => Cross-DB federation
###############################################################################
class LinkedServerConfigDialog(QDialog):
    def __init__(self, existing_map=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Linked Server / Federation Config")
        self.resize(500,300)
        self._map=existing_map.copy() if existing_map else {}

        lay=QVBoxLayout(self)
        instruct=QLabel(
            "Define each DB alias => linked server name. For cross-DB queries:\n"
            "'Alias.DB.Table' => '[LinkedSrv].[DB].dbo.[Table]'."
        )
        lay.addWidget(instruct)

        self.table=QTableWidget(0,2)
        self.table.setHorizontalHeaderLabels(["DB Alias","LinkedServerName"])
        self.table.horizontalHeader().setStretchLastSection(True)
        lay.addWidget(self.table)

        for alias,lsn in self._map.items():
            r=self.table.rowCount()
            self.table.insertRow(r)
            self.table.setItem(r,0,QTableWidgetItem(alias))
            self.table.setItem(r,1,QTableWidgetItem(lsn))

        btns=QHBoxLayout()
        add_btn=QPushButton("Add Mapping")
        rm_btn=QPushButton("Remove Mapping")
        close_btn=QPushButton("Close")
        btns.addWidget(add_btn)
        btns.addWidget(rm_btn)
        btns.addStretch()
        btns.addWidget(close_btn)
        lay.addLayout(btns)

        add_btn.clicked.connect(self.on_add)
        rm_btn.clicked.connect(self.on_rm)
        close_btn.clicked.connect(self.accept)
        self.setLayout(lay)

    def on_add(self):
        r=self.table.rowCount()
        self.table.insertRow(r)
        self.table.setItem(r,0,QTableWidgetItem("AliasXYZ"))
        self.table.setItem(r,1,QTableWidgetItem("LinkedSrvName"))

    def on_rm(self):
        rows=self.table.selectionModel().selectedRows()
        if not rows:
            return
        for rr in sorted([r.row() for r in rows], reverse=True):
            self.table.removeRow(rr)

    def accept(self):
        newmap={}
        for r in range(self.table.rowCount()):
            alias_item=self.table.item(r,0)
            ls_item=self.table.item(r,1)
            if alias_item and ls_item:
                alias=alias_item.text().strip()
                ls=ls_item.text().strip()
                if alias:
                    newmap[alias]=ls
        self._map=newmap
        super().accept()

    def get_map(self):
        return self._map

###############################################################################
# 4) load_tables/load_columns => multi DB
###############################################################################
def load_tables(connection, db_type, db_name):
    out=[]
    if not connection:
        return out
    try:
        cur=connection.cursor()
        if "TERADATA" in db_type.upper():
            q=f"SELECT TableName FROM DBC.TablesV WHERE DatabaseName='{db_name}' AND TableKind='T' ORDER BY TableName"
            cur.execute(q)
            rows=cur.fetchall()
            out=[r[0].strip() for r in rows]
        elif "SQLSERVER" in db_type.upper():
            q=f"SELECT TABLE_NAME FROM {db_name}.INFORMATION_SCHEMA.TABLES ORDER BY TABLE_NAME"
            cur.execute(q)
            rows=cur.fetchall()
            out=[r[0].strip() for r in rows]
        else:
            pass
    except Exception as ex:
        logging.warning(f"Failed to load tables for {db_name}: {ex}")
    return out

def load_columns(connection, db_type, db_name, tbl_name):
    out=[]
    if not connection:
        return out
    try:
        cur=connection.cursor()
        if "TERADATA" in db_type.upper():
            q=f"SELECT ColumnName FROM DBC.ColumnsV WHERE DatabaseName='{db_name}' AND TableName='{tbl_name}' ORDER BY ColumnId"
            cur.execute(q)
            rows=cur.fetchall()
            out=[r[0].strip() for r in rows]
        elif "SQLSERVER" in db_type.upper():
            q=f"SELECT COLUMN_NAME FROM {db_name}.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='{tbl_name}' ORDER BY ORDINAL_POSITION"
            cur.execute(q)
            rows=cur.fetchall()
            out=[r[0].strip() for r in rows]
        else:
            pass
    except Exception as ex:
        logging.warning(f"Failed to load columns for {db_name}.{tbl_name}: {ex}")
    return out

###############################################################################
# 5) MultiDBLazySchemaTreeWidget => lazy loading
###############################################################################
class SchemaLoaderSignals(QtCore.QObject):
    finished=pyqtSignal(str,list)
    error=pyqtSignal(str,str)

class SchemaLoader(QtCore.QRunnable):
    def __init__(self, connection, db_type, db_name):
        super().__init__()
        self.connection=connection
        self.db_type=db_type
        self.db_name=db_name
        self.signals=SchemaLoaderSignals()

    @QtCore.pyqtSlot()
    def run(self):
        try:
            tabs=load_tables(self.connection,self.db_type,self.db_name)
            self.signals.finished.emit(self.db_name, tabs)
        except Exception as ex:
            err=f"{ex}\n{traceback.format_exc()}"
            self.signals.error.emit(self.db_name, err)

class MultiDBLazySchemaTreeWidget(QTreeWidget):
    def __init__(self, connections, parent_builder=None, parent=None):
        super().__init__(parent)
        self.connections=connections
        self.parent_builder=parent_builder
        self.setHeaderHidden(False)
        self.setColumnCount(1)
        self.setHeaderLabel("Databases / Tables")
        self.setDragEnabled(True)  # so user can drag from tree
        self.threadpool=QThreadPool.globalInstance()
        self.populate_roots()

    def populate_roots(self):
        self.clear()
        if not self.connections:
            self.addTopLevelItem(QTreeWidgetItem(["No Connections"]))
            return
        for alias,info in self.connections.items():
            top_item=QTreeWidgetItem([f"{alias} ({info.get('db_type','Unknown')})"])
            top_item.setData(0, Qt.UserRole, ("connAlias", alias))
            self.addTopLevelItem(top_item)
            conn=info.get("connection")
            dbt=info.get("db_type","")
            if not conn:
                top_item.addChild(QTreeWidgetItem(["(No connection)"]))
                continue

            try:
                c=conn.cursor()
                if "TERADATA" in dbt.upper():
                    c.execute("SELECT DISTINCT DatabaseName FROM DBC.TablesV ORDER BY DatabaseName")
                    rows=c.fetchall()
                    for row in rows:
                        dbn=row[0].strip()
                        db_item=QTreeWidgetItem([dbn])
                        db_item.setData(0, Qt.UserRole, ("db",alias,dbn))
                        db_item.setData(0, Qt.UserRole+1, False)
                        db_item.addChild(QTreeWidgetItem(["Loading..."]))
                        top_item.addChild(db_item)
                elif "SQLSERVER" in dbt.upper():
                    c.execute("SELECT name FROM sys.databases ORDER BY name")
                    rows=c.fetchall()
                    for row in rows:
                        dbn=row[0].strip()
                        db_item=QTreeWidgetItem([dbn])
                        db_item.setData(0, Qt.UserRole, ("db",alias,dbn))
                        db_item.setData(0, Qt.UserRole+1, False)
                        db_item.addChild(QTreeWidgetItem(["Loading..."]))
                        top_item.addChild(db_item)
                else:
                    top_item.addChild(QTreeWidgetItem(["(Unknown DB type)"]))
            except Exception as ex:
                top_item.addChild(QTreeWidgetItem([f"(Error: {ex})"]))
        self.expandAll()

    def mouseDoubleClickEvent(self, e):
        it=self.itemAt(e.pos())
        if it:
            d=it.data(0, Qt.UserRole)
            if d and d[0]=="db":
                loaded=it.data(0,Qt.UserRole+1)
                if not loaded:
                    it.takeChildren()
                    alias,dbn=d[1],d[2]
                    info=self.connections.get(alias)
                    if info and info.get("connection"):
                        c=info["connection"]
                        dbt=info["db_type"]
                        worker=SchemaLoader(c,dbt,dbn)
                        def on_finish(dbname,tables):
                            self.populate_tables(it,dbname,tables)
                        def on_error(dbname,err):
                            QMessageBox.critical(self,"Schema Error",f"{dbname} => {err}")
                        worker.signals.finished.connect(on_finish)
                        worker.signals.error.connect(on_error)
                        self.threadpool.start(worker)
        super().mouseDoubleClickEvent(e)

    def populate_tables(self, parent_item, dbname, tables):
        if not tables:
            parent_item.addChild(QTreeWidgetItem(["<No Tables>"]))
            parent_item.setData(0, Qt.UserRole+1, True)
            return
        parent_item.takeChildren()
        d=parent_item.data(0,Qt.UserRole)
        alias=d[1]
        for t in tables:
            t_item=QTreeWidgetItem([t])
            t_item.setData(0, Qt.UserRole, ("table",alias,dbname,t))
            t_item.setData(0, Qt.UserRole+1, False)
            t_item.addChild(QTreeWidgetItem(["Loading..."]))
            parent_item.addChild(t_item)
        parent_item.setData(0, Qt.UserRole+1, True)

    def expand_table(self, table_item):
        loaded=table_item.data(0,Qt.UserRole+1)
        if not loaded:
            table_item.takeChildren()
            d=table_item.data(0,Qt.UserRole)
            alias,dbn,tbn=d[1],d[2],d[3]
            info=self.connections.get(alias)
            if info:
                c=info["connection"]
                dbt=info["db_type"]
                cols=load_columns(c,dbt,dbn,tbn)
                if cols:
                    for cc in cols:
                        child=QTreeWidgetItem([cc])
                        child.setData(0, Qt.UserRole, ("column",alias,dbn,tbn,cc))
                        table_item.addChild(child)
                else:
                    table_item.addChild(QTreeWidgetItem(["<No columns>"]))
            table_item.setData(0, Qt.UserRole+1, True)

    def mousePressEvent(self, e):
        it=self.itemAt(e.pos())
        if it:
            d=it.data(0, Qt.UserRole)
            if d and d[0]=="table":
                self.expand_table(it)
        super().mousePressEvent(e)

    def startDrag(self, actions):
        it=self.currentItem()
        if it:
            d=it.data(0, Qt.UserRole)
            if d and d[0]=="table":
                alias,dbn,tbl=d[1],d[2],d[3]
                full= f"{alias}.{dbn}.{tbl}"
                drag= QtGui.QDrag(self)
                mime= QtCore.QMimeData()
                mime.setText(full)
                drag.setMimeData(mime)
                drag.exec_(actions)


###############################################################################
# 6) FullSQLParser, SQLHighlighter
###############################################################################
class FullSQLParser:
    def __init__(self, sql):
        self.sql=sql
    def parse(self):
        st=sqlparse.parse(self.sql)
        if not st:
            raise ValueError("No valid SQL found.")

class SQLHighlighter(QSyntaxHighlighter):
    def __init__(self, doc):
        super().__init__(doc)
        self.rules=[]
        kwfmt=QTextCharFormat()
        kwfmt.setForeground(Qt.darkBlue)
        kwfmt.setFontWeight(QFont.Bold)

        keywords=[
            "SELECT","FROM","WHERE","JOIN","INNER","LEFT","RIGHT","FULL","OUTER",
            "GROUP","BY","HAVING","ORDER","LIMIT","OFFSET","UNION","ALL","INTERSECT",
            "EXCEPT","AS","ON","AND","OR","NOT","IN","IS","NULL","EXISTS","COUNT",
            "SUM","AVG","MIN","MAX","INSERT","UPDATE","DELETE","VALUES","OVER",
            "PARTITION","ROWS","RANGE","CURRENT ROW","ROW_NUMBER","RANK","DENSE_RANK",
            "NTILE","LAG","LEAD","CASE","COALESCE","TRIM","FIRST_VALUE","LAST_VALUE",
            "WITH"
        ]
        for w in keywords:
            pattern=QRegularExpression(r'\b'+w+r'\b', QRegularExpression.CaseInsensitiveOption)
            self.rules.append((pattern, kwfmt))

        strfmt=QTextCharFormat()
        strfmt.setForeground(Qt.darkRed)
        self.rules.append((QRegularExpression(r"'[^']*'"), strfmt))
        self.rules.append((QRegularExpression(r'"[^"]*"'), strfmt))

        cfmt=QTextCharFormat()
        cfmt.setForeground(Qt.green)
        self.rules.append((QRegularExpression(r'--[^\n]*'), cfmt))
        self.rules.append((QRegularExpression(r'/\*.*\*/', QRegularExpression.DotMatchesEverythingOption), cfmt))

    def highlightBlock(self, text):
        for pat,fmt in self.rules:
            matches=pat.globalMatch(text)
            while matches.hasNext():
                m=matches.next()
                st=m.capturedStart()
                ln=m.capturedLength()
                self.setFormat(st, ln, fmt)
        self.setCurrentBlockState(0)

###############################################################################
# 7) BFS Items: ColumnJoinWizard, MappingLine, JoinLine, BFS/Collapsible
###############################################################################
class ColumnJoinWizardDialog(QDialog):
    """
    Wizard for picking a join condition (source_col => target_col).
    """
    def __init__(self, source_full, source_type, target_full, target_type, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Column Join Wizard")
        self.resize(400,200)

        self.source_col=source_full
        self.source_type=source_type
        self.target_col=target_full
        self.target_type=target_type

        self.join_type="INNER"
        self.condition=f"{self.source_col} = {self.target_col}"

        layout=QVBoxLayout(self)
        info_l=QLabel(
            f"Source: {self.source_col} (type={self.source_type})\n"
            f"Target: {self.target_col} (type={self.target_type})"
        )
        layout.addWidget(info_l)
        if self.source_type.lower()!=self.target_type.lower():
            warn=QLabel("<b>Warning:</b> Data types differ—may need cast.")
            warn.setStyleSheet("color:red;")
            layout.addWidget(warn)

        form=QFormLayout()
        self.join_combo=QComboBox()
        self.join_combo.addItems(["INNER","LEFT","RIGHT","FULL"])
        form.addRow("Join Type:", self.join_combo)

        self.cond_edit=QLineEdit(self.condition)
        form.addRow("Condition:", self.cond_edit)
        layout.addLayout(form)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        jt=self.join_combo.currentText()
        cd=self.cond_edit.text().strip()
        if not cd:
            QMessageBox.warning(self,"No condition","Condition cannot be empty.")
            return
        self.join_type=jt
        self.condition=cd
        self.accept()

    def get_join_data(self):
        return (self.join_type, self.condition)

class MappingLine(QGraphicsLineItem):
    """
    BFS DML mapping line from BFS source col => target col
    """
    def __init__(self, source_text_item, target_text_item, parent_canvas, source_type=None, target_type=None):
        super().__init__()
        self.canvas=parent_canvas
        self.source_text_item=source_text_item
        self.target_text_item=target_text_item
        self.source_col=source_text_item.toPlainText()
        self.target_col=target_text_item.toPlainText()
        self.source_type=source_type
        self.target_type=target_type

        self.setPen(QPen(Qt.darkRed,2,Qt.SolidLine))
        self.setZValue(5)
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptHoverEvents(True)
        self.update_pos()

    def update_pos(self):
        s=self.source_text_item.mapToScene(self.source_text_item.boundingRect().center())
        t=self.target_text_item.mapToScene(self.target_text_item.boundingRect().center())
        self.setLine(QtCore.QLineF(s,t))

    def paint(self, painter, option, widget):
        self.update_pos()
        super().paint(painter, option, widget)

    def contextMenuEvent(self, event):
        menu=QMenu()
        rm=menu.addAction("Remove Column Mapping")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            if self in self.canvas.mapping_lines:
                self.canvas.mapping_lines.remove(self)
            sc=self.scene()
            if sc:
                sc.removeItem(self)

class JoinLine(QGraphicsLineItem):
    """
    BFS multi-join line => start_item => end_item, plus label and condition
    """
    def __init__(self, start_item, end_item, join_type="INNER", condition="",
                 start_col_text_item=None, end_col_text_item=None):
        super().__init__()
        self.start_item=start_item
        self.end_item=end_item
        self.join_type=join_type
        self.condition=condition
        self.start_col_text_item=start_col_text_item
        self.end_col_text_item=end_col_text_item
        self.setZValue(-1)
        self.setAcceptHoverEvents(True)

        self.pen_map={
            "INNER":(Qt.darkBlue, Qt.SolidLine),
            "LEFT": (Qt.darkGreen, Qt.SolidLine),
            "RIGHT":(Qt.magenta,  Qt.DotLine),
            "FULL": (Qt.red,      Qt.DashLine),
        }
        self.label=QGraphicsTextItem(f"{join_type} JOIN", self)
        self.label.setDefaultTextColor(Qt.blue)
        self.update_line()

    def update_line(self):
        if self.start_col_text_item:
            sr=self.start_col_text_item.boundingRect()
            scn=self.start_col_text_item.mapToScene(sr.center())
        else:
            sr=self.start_item.boundingRect()
            scn=self.start_item.mapToScene(sr.center())

        if self.end_col_text_item:
            er=self.end_col_text_item.boundingRect()
            ecn=self.end_col_text_item.mapToScene(er.center())
        else:
            er=self.end_item.boundingRect()
            ecn=self.end_item.mapToScene(er.center())

        self.setLine(QtCore.QLineF(scn,ecn))
        mx=(scn.x()+ecn.x())/2
        my=(scn.y()+ecn.y())/2
        self.label.setPos(mx,my)
        (col, st)=self.pen_map.get(self.join_type,(Qt.gray,Qt.SolidLine))
        self.setPen(QPen(col,2,st))

    def hoverEnterEvent(self,e):
        p=self.pen()
        p.setColor(Qt.yellow)
        p.setWidth(3)
        self.setPen(p)
        super().hoverEnterEvent(e)

    def hoverLeaveEvent(self,e):
        self.update_line()
        super().hoverLeaveEvent(e)

class CollapsibleBFSGraphicsItem(QGraphicsRectItem):
    """
    BFS "Source" item for DML => user can check columns to be inserted/updated.
    """
    def __init__(self, title, columns, parent_builder, x=100, y=100):
        super().__init__(0,0,240,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(250,250,180)))
        self.setPen(QPen(Qt.red,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.item_title=title
        self.columns=columns
        self.parent_builder=parent_builder
        self.is_collapsed=False
        self.title_height=20
        self.column_items=[]

        self.close_btn=QGraphicsTextItem("[X]",self)
        self.close_btn.setPos(215,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn=QGraphicsTextItem("[-]",self)
        self.toggle_btn.setPos(195,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f=QFont("Arial",9,QFont.Bold)
        self.title_text=QGraphicsTextItem(title,self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        yOff=self.title_height
        for c in columns:
            r=QGraphicsRectItem(5,yOff+4,10,10,self)
            r.setBrush(QBrush(Qt.blue))  # BFS columns "checked" by default
            r.setPen(QPen(Qt.black,1))
            t=QGraphicsTextItem(c,self)
            t.setPos(20,yOff)
            self.column_items.append([r,t,True])
            yOff+=20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,240,self.title_height)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(False)
                ct.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded=self.title_height+len(self.column_items)*20
            self.setRect(0,0,240,expanded)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(True)
                ct.setVisible(True)
            self.toggle_btn.setPlainText("[-]")

    def mousePressEvent(self,event):
        pos=event.pos()
        cbr=self.close_btn.mapToParent(self.close_btn.boundingRect())
        if cbr.boundingRect().contains(pos):
            sc=self.scene()
            if sc:
                sc.removeItem(self)
            event.accept()
            return
        tbr=self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if tbr.boundingRect().contains(pos):
            self.is_collapsed=not self.is_collapsed
            self.update_layout()
            event.accept()
            return
        for i,(cb,ct,chk) in enumerate(self.column_items):
            rr=cb.mapToParent(cb.boundingRect()).boundingRect()
            if rr.contains(pos):
                self.column_items[i][2]=not chk
                cb.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder and self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def get_checked_columns(self):
        arr=[]
        for (cb,ct,chk) in self.column_items:
            if chk:
                arr.append(ct.toPlainText().strip())
        return arr

class DraggableColumnTextItem(QGraphicsTextItem):
    """
    For columns in CollapsibleTable => supports drag-drop to define BFS multi-join
    or DML line (if from BFS => target).
    """
    def __init__(self, parent_table_item, column_name, column_type):
        super().__init__(column_name, parent_table_item)
        self.parent_table_item=parent_table_item
        self.column_name=column_name
        self.column_type=column_type
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptDrops(True)

    def mousePressEvent(self, event):
        if event.button()==Qt.LeftButton:
            drag=QtGui.QDrag(event.widget())
            mime=QtCore.QMimeData()
            full_col=f"{self.parent_table_item.table_fullname}.{self.column_name}"
            mime.setText(f"{full_col}||{self.column_type}")
            drag.setMimeData(mime)
            drag.exec_(Qt.MoveAction)
        else:
            super().mousePressEvent(event)

    def dragEnterEvent(self, event):
        if event.mimeData().hasText() and "||" in event.mimeData().text():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        event.acceptProposedAction()

    def dropEvent(self, event):
        src_txt=event.mimeData().text()
        if "||" not in src_txt:
            event.ignore()
            return
        source_full, source_type=src_txt.split("||",1)
        target_full=f"{self.parent_table_item.table_fullname}.{self.column_name}"
        target_type=self.column_type

        if source_full==target_full:
            QMessageBox.information(None,"Same Column","Cannot join a column onto itself.")
            event.ignore()
            return

        # BFS multi-join => ensure different tables
        if source_full.startswith(self.parent_table_item.table_fullname+"."):
            QMessageBox.information(None,"Same Table","Join across different tables only.")
            event.ignore()
            return

        dlg=ColumnJoinWizardDialog(source_full,source_type,target_full,target_type)
        if dlg.exec_()==QDialog.Accepted:
            jtype,cond=dlg.get_join_data()
            builder=self.parent_table_item.parent_builder
            cv=builder.canvas

            # parse source tab => e.g. "Alias.DB.Table"
            sf_tab=".".join(source_full.split(".")[:3])
            tf_tab=".".join(target_full.split(".")[:3])

            source_item=cv.table_items.get(sf_tab,None)
            target_item=cv.table_items.get(tf_tab,None)
            if not source_item or not target_item:
                QMessageBox.warning(None,"Join Error","Cannot find BFS items for source/target.")
                event.ignore()
                return

            s_col_name=source_full.split(".")[-1]
            t_col_name=target_full.split(".")[-1]
            src_col_text_item=source_item.column_text_items.get(s_col_name)
            tgt_col_text_item=target_item.column_text_items.get(t_col_name)

            jl=JoinLine(source_item,target_item,jtype,cond,src_col_text_item,tgt_col_text_item)
            cv.scene_.addItem(jl)
            cv.join_lines.append(jl)
            jl.update_line()
            QMessageBox.information(None,"Join Created",f"Created {jtype} JOIN:\n{cond}")
            event.acceptProposedAction()
        else:
            event.ignore()

class CollapsibleTableGraphicsItem(QGraphicsRectItem):
    """
    A BFS item for normal tables => user checks columns for SELECT usage.
    DraggableColumnTextItem => supports BFS multi-join lines.
    """
    def __init__(self, table_fullname, columns, parent_builder, x=0, y=0):
        super().__init__(0,0,220,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(220,220,255)))
        self.setPen(QPen(Qt.darkGray,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.table_fullname=table_fullname
        self.columns=columns
        self.parent_builder=parent_builder

        self.is_collapsed=True
        self.title_height=20
        self.column_items=[]
        self.column_text_items={}

        self.close_btn=QGraphicsTextItem("[X]",self)
        self.close_btn.setPos(190,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn=QGraphicsTextItem("[+]",self)
        self.toggle_btn.setPos(170,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f=QFont("Arial",9,QFont.Bold)
        self.title_text=QGraphicsTextItem(table_fullname,self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        self.mock_column_types={}
        for c in columns:
            if c.lower().startswith("id") or c.lower().endswith("id"):
                self.mock_column_types[c]="INT"
            else:
                self.mock_column_types[c]="VARCHAR"

        yOff=self.title_height
        for c in columns:
            cRect=QGraphicsRectItem(5,yOff+4,10,10,self)
            cRect.setBrush(QBrush(Qt.white))
            cRect.setPen(QPen(Qt.black,1))
            cText=DraggableColumnTextItem(self,c,self.mock_column_types[c])
            cText.setPos(20,yOff)
            self.column_items.append([cRect,cText,False])
            self.column_text_items[c]=cText
            yOff+=20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,220,self.title_height)
            for (r,t,_) in self.column_items:
                r.setVisible(False)
                t.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded=self.title_height+len(self.column_items)*20
            self.setRect(0,0,220,expanded)
            for (r,t,_) in self.column_items:
                r.setVisible(True)
                t.setVisible(True)
            self.toggle_btn.setPlainText("[-]")
        self.close_btn.setPos(190,2)
        self.toggle_btn.setPos(170,2)

    def mousePressEvent(self, event):
        pos=event.pos()
        close_r=self.close_btn.mapToParent(self.close_btn.boundingRect())
        if close_r.boundingRect().contains(pos):
            if self.parent_builder:
                self.parent_builder.handle_remove_table(self)
            event.accept()
            return
        toggle_r=self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if toggle_r.boundingRect().contains(pos):
            self.is_collapsed=not self.is_collapsed
            self.update_layout()
            event.accept()
            return
        for i,(cRect,cText,checked) in enumerate(self.column_items):
            rRect=cRect.mapToParent(cRect.boundingRect()).boundingRect()
            if rRect.contains(pos):
                self.column_items[i][2]=not checked
                cRect.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def contextMenuEvent(self, event):
        menu=QMenu()
        rm=menu.addAction("Remove Table/CTE")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            if self.parent_builder:
                self.parent_builder.handle_remove_table(self)

    def get_selected_columns(self):
        sel=[]
        for (r,t,checked) in self.column_items:
            if checked:
                colName=t.toPlainText().strip()
                sel.append(f"{self.table_fullname}.{colName}")
        return sel

###############################################################################
# 8) Nested Subqueries, Sub-VQB, ExpressionBuilder, FilterPanel, GroupPanel, etc
###############################################################################
# (We define them fully below)

###############################################################################
# 9) Data Profiler => "ERR(reason)" + Outlier
###############################################################################
class ProfilerChartCanvas(FigureCanvasQTAgg):
    def __init__(self, data_list, col_name="", parent=None):
        fig=Figure()
        super().__init__(fig)
        self.setParent(parent)
        self.axes=fig.add_subplot(111)
        self.data=data_list
        self.col_name=col_name
        self.plot_data()

    def plot_data(self):
        self.axes.clear()
        if not self.data:
            self.axes.text(0.5,0.5,"No numeric data",ha='center',va='center')
            self.draw()
            return
        self.axes.boxplot(self.data, vert=True, labels=[self.col_name])
        self.axes.set_title(f"Outlier Chart: {self.col_name}")
        self.draw()

class DataProfilerDialog(QDialog):
    def __init__(self, table_key, columns, connection, parent=None):
        super().__init__(parent)
        self.table_key=table_key
        self.columns=columns
        self.connection=connection
        self.setWindowTitle(f"Data Profiler - {table_key}")
        self.resize(900,500)

        main=QVBoxLayout(self)
        info=QLabel(
            "Profiling columns => COUNT, DISTINCT, MIN, MAX, AVG. If error => 'ERR(...)'.\n"
            "Click 'Outlier Chart' for numeric columns."
        )
        main.addWidget(info)

        self.prof_table=QTableWidget(0,7)
        self.prof_table.setHorizontalHeaderLabels(["Column","COUNT","DISTINCT","MIN","MAX","AVG","Error"])
        main.addWidget(self.prof_table)

        btn_h=QHBoxLayout()
        chart_btn=QPushButton("Outlier Chart")
        chart_btn.clicked.connect(self.show_outlier_chart)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        btn_h.addWidget(chart_btn)
        btn_h.addStretch()
        btn_h.addWidget(close_btn)
        main.addLayout(btn_h)

        self.setLayout(main)
        self.run_profiler()

    def run_profiler(self):
        if not self.connection:
            QMessageBox.warning(self,"No Connection","Cannot profile without a DB connection.")
            return
        c=self.connection.cursor()
        self.prof_table.setRowCount(0)

        for col in self.columns:
            short_col=col.split(".")[-1]
            r_idx=self.prof_table.rowCount()
            self.prof_table.insertRow(r_idx)
            self.prof_table.setItem(r_idx,0,QTableWidgetItem(short_col))

            # COUNT(*)
            co_val=""
            try:
                c.execute(f"SELECT COUNT(*) FROM {self.table_key}")
                rr=c.fetchone()
                co_val=str(rr[0]) if rr else "0"
            except Exception as ex:
                co_val=f"ERR({ex})"
            self.prof_table.setItem(r_idx,1,QTableWidgetItem(co_val))

            # COUNT DISTINCT
            dist_val=""
            try:
                c.execute(f"SELECT COUNT(DISTINCT {short_col}) FROM {self.table_key}")
                rr=c.fetchone()
                dist_val=str(rr[0]) if rr else "0"
            except Exception as ex:
                dist_val=f"ERR({ex})"
            self.prof_table.setItem(r_idx,2,QTableWidgetItem(dist_val))

            minv,maxv,avgv="N/A","N/A","N/A"
            err_msg=""
            try:
                c.execute(f"SELECT MIN({short_col}) FROM {self.table_key}")
                r=c.fetchone()
                if r and r[0] is not None:
                    minv=str(r[0])
                else:
                    minv="NULL"
            except Exception as ex:
                minv="ERR"
                err_msg=str(ex)

            try:
                c.execute(f"SELECT MAX({short_col}) FROM {self.table_key}")
                r=c.fetchone()
                if r and r[0] is not None:
                    maxv=str(r[0])
                else:
                    maxv="NULL"
            except Exception as ex:
                maxv="ERR"
                if not err_msg:
                    err_msg=str(ex)

            try:
                c.execute(f"SELECT AVG({short_col}) FROM {self.table_key}")
                r=c.fetchone()
                if r and r[0] is not None:
                    avgv=str(r[0])
                else:
                    avgv="NULL"
            except Exception as ex:
                avgv="ERR"
                if not err_msg:
                    err_msg=str(ex)

            self.prof_table.setItem(r_idx,3,QTableWidgetItem(minv))
            self.prof_table.setItem(r_idx,4,QTableWidgetItem(maxv))
            self.prof_table.setItem(r_idx,5,QTableWidgetItem(avgv))
            self.prof_table.setItem(r_idx,6,QTableWidgetItem(err_msg))

    def show_outlier_chart(self):
        rows=self.prof_table.selectionModel().selectedRows()
        if not rows:
            QMessageBox.information(self,"No Selection","Pick a column row first.")
            return
        row_idx=rows[0].row()
        col_name=self.prof_table.item(row_idx,0).text()

        data_list=[]
        try:
            c=self.connection.cursor()
            sql=f"SELECT {col_name} FROM {self.table_key} WHERE {col_name} IS NOT NULL"
            c.execute(sql)
            rr=c.fetchall()
            for r in rr:
                val=r[0]
                fval=float(val)
                data_list.append(fval)
        except Exception as ex:
            QMessageBox.warning(self,"Outlier Error",f"Could not fetch numeric data:\n{ex}")
            return

        if not data_list:
            QMessageBox.information(self,"No Data","No numeric data found or table empty.")
            return
        d=QDialog(self)
        d.setWindowTitle(f"Outlier Chart: {col_name}")
        d.resize(600,400)
        lay=QVBoxLayout(d)
        canvas=ProfilerChartCanvas(data_list,col_name,d)
        lay.addWidget(canvas)
        btns=QDialogButtonBox(QDialogButtonBox.Ok)
        lay.addWidget(btns)
        btns.accepted.connect(d.accept)
        d.setLayout(lay)
        d.exec_()

###############################################################################
# 10) EnhancedCanvasGraphicsView => BFS
###############################################################################
class EnhancedCanvasGraphicsView(QGraphicsView):
    def __init__(self, builder, parent=None):
        super().__init__(parent)
        self.builder=builder
        self.scene_=QGraphicsScene(self)
        self.setScene(self.scene_)
        # crucial fix => accept drops from the schema tree:
        self.setAcceptDrops(True)

        self.table_items={}
        self.join_lines=[]
        self.mapping_lines=[]
        self.operation_red_line=None
        self.collapsible_bfs_item=None
        self.target_table_item=None

        self.validation_timer=QTimer()
        self.validation_timer.setInterval(400)
        self.validation_timer.setSingleShot(True)
        self.validation_timer.timeout.connect(self.builder.validate_sql)

    def dragEnterEvent(self,e):
        if e.mimeData().hasText():
            e.acceptProposedAction()

    def dragMoveEvent(self,e):
        e.acceptProposedAction()

    def dropEvent(self,e):
        txt=e.mimeData().text()
        pos=self.mapToScene(e.pos())
        self.builder.handle_drop(txt,pos)
        e.acceptProposedAction()

    def add_table_item(self, table_key, columns, x, y):
        it=CollapsibleTableGraphicsItem(table_key, columns, self.builder, x, y)
        self.scene_.addItem(it)
        self.table_items[table_key]=it
        if self.builder.auto_generate:
            self.builder.generate_sql()
        self.validation_timer.start()

    def add_bfs_item(self, title, columns, x, y):
        bfs=CollapsibleBFSGraphicsItem(title, columns, self.builder, x, y)
        self.scene_.addItem(bfs)
        self.collapsible_bfs_item=bfs

    def add_target_item(self, title, columns, x, y):
        full="Target:"+title
        t=CollapsibleTableGraphicsItem(full, columns, self.builder, x, y)
        self.scene_.addItem(t)
        self.target_table_item=t

    def remove_table_item(self, table_key):
        if table_key in self.table_items:
            itm=self.table_items[table_key]
            lines_rm=[]
            for jl in self.join_lines:
                if jl.start_item==itm or jl.end_item==itm:
                    lines_rm.append(jl)
            for ln in lines_rm:
                self.scene_.removeItem(ln)
                self.join_lines.remove(ln)
            self.scene_.removeItem(itm)
            del self.table_items[table_key]
            self.validation_timer.start()
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_mapping_lines(self):
        for ml in self.mapping_lines:
            self.scene_.removeItem(ml)
        self.mapping_lines.clear()

    def add_vertical_red_line(self, x=450):
        if self.operation_red_line:
            self.scene_.removeItem(self.operation_red_line)
            self.operation_red_line=None
        ln=QGraphicsLineItem(x,0,x,3000)
        ln.setPen(QPen(Qt.red,2,Qt.DashDotLine))
        ln.setZValue(-10)
        self.scene_.addItem(ln)
        self.operation_red_line=ln

    def create_mapping_line(self, source_text_item, target_text_item, src_type=None, tgt_type=None):
        ml=MappingLine(source_text_item, target_text_item, self, src_type, tgt_type)
        self.scene_.addItem(ml)
        self.mapping_lines.append(ml)
        if self.builder.auto_generate:
            self.builder.generate_sql()
        self.validation_timer.start()

    def add_subquery_item(self, x, y):
        sq=NestedSubqueryItem(self.builder, x, y)
        self.scene_.addItem(sq)
        key=f"SubQueryItem_{id(sq)}"
        self.table_items[key]=sq
        self.validation_timer.start()

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        for jl in self.join_lines:
            jl.update_line()
        for ml in self.mapping_lines:
            ml.update_pos()


###############################################################################
# 11) VisualQueryBuilderTab => BFS logic, multi-DB, federation
###############################################################################
class VisualQueryBuilderTab(QWidget):
    def __init__(self, multi_connections=None, linked_map=None, parent=None):
        super().__init__(parent)
        self.connections=multi_connections if multi_connections else {}
        self.linked_server_map=linked_map if linked_map else {}
        self.table_columns_map={}
        self.auto_generate=True
        self.operation_mode="SELECT"

        self.init_ui()
        self.threadpool=QThreadPool.globalInstance()

    def init_ui(self):
        main=QVBoxLayout(self)

        # row1
        conn_h=QHBoxLayout()
        self.status_light=QFrame()
        self.status_light.setFixedSize(15,15)
        self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
        self.server_label=QLabel("Not Connected")
        conn_h.addWidget(self.status_light)
        conn_h.addWidget(self.server_label)

        self.auto_chk=QCheckBox("Auto-Generate")
        self.auto_chk.setChecked(True)
        self.auto_chk.stateChanged.connect(self.on_auto_gen_changed)
        conn_h.addWidget(self.auto_chk)
        conn_h.addStretch()
        main.addLayout(conn_h)

        # row2
        tb_h=QHBoxLayout()
        subq_btn=QPushButton("Add SubQuery to Canvas")
        subq_btn.clicked.connect(self.add_subquery_to_canvas)
        tb_h.addWidget(subq_btn)

        expr_btn=QPushButton("Expression Builder")
        expr_btn.clicked.connect(self.launch_expr_builder)
        tb_h.addWidget(expr_btn)

        wfunc_btn=QPushButton("Window Function Wizard")
        wfunc_btn.clicked.connect(self.launch_window_func)
        tb_h.addWidget(wfunc_btn)

        comb_btn=QPushButton("Combine Query (Full Sub VQB)")
        comb_btn.clicked.connect(self.combine_with_subvqb)
        tb_h.addWidget(comb_btn)

        self.op_combo=QComboBox()
        self.op_combo.addItems(["SELECT","INSERT","UPDATE","DELETE"])
        self.op_combo.currentIndexChanged.connect(self.on_op_mode_changed)
        tb_h.addWidget(self.op_combo)

        tb_h.addStretch()
        main.addLayout(tb_h)

        self.tabs=QTabWidget()
        main.addWidget(self.tabs)

        self.schema_tab=QWidget()
        self.config_tab=QWidget()
        self.sql_tab=QWidget()
        self.import_tab=SQLImportTab(builder=self)

        self.tabs.addTab(self.schema_tab,"Schema & Canvas")
        self.tabs.addTab(self.config_tab,"Query Config")
        self.tabs.addTab(self.sql_tab,"SQL Preview")
        self.tabs.addTab(self.import_tab,"SQL Import")

        self.status_bar=QStatusBar()
        main.addWidget(self.status_bar)

        self.setLayout(main)

        self.setup_schema_tab()
        self.setup_config_tab()
        self.setup_sql_tab()

    def setup_schema_tab(self):
        lay=QVBoxLayout(self.schema_tab)
        self.search_ed=QLineEdit()
        self.search_ed.setPlaceholderText("Filter in the schema tree...")
        self.search_ed.textChanged.connect(self.on_schema_filter)
        lay.addWidget(self.search_ed)

        splitter=QSplitter(Qt.Horizontal)
        self.schema_tree=MultiDBLazySchemaTreeWidget(self.connections, parent_builder=self)
        leftp=QWidget()
        lp=QVBoxLayout(leftp)
        lp.addWidget(self.schema_tree)
        splitter.addWidget(leftp)

        self.canvas=EnhancedCanvasGraphicsView(self)
        splitter.addWidget(self.canvas)
        splitter.setStretchFactor(0,1)
        splitter.setStretchFactor(1,3)
        lay.addWidget(splitter)

        self.progress=QProgressBar()
        self.progress.setVisible(False)
        lay.addWidget(self.progress)

    def setup_config_tab(self):
        h=QHBoxLayout(self.config_tab)
        self.cte_panel=CTEPanel(self)
        h.addWidget(self.cte_panel,2)

        self.filter_panel=FilterPanel(self)
        h.addWidget(self.filter_panel,2)

        self.group_panel=GroupByPanel(self)
        h.addWidget(self.group_panel,3)

        self.sort_panel=SortLimitPanel(self)
        h.addWidget(self.sort_panel,2)
        self.config_tab.setLayout(h)

    def setup_sql_tab(self):
        lay=QVBoxLayout(self.sql_tab)
        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Generated SQL:"))
        run_btn=QPushButton("Run SQL")
        run_btn.clicked.connect(self.run_sql)
        top_h.addWidget(run_btn,alignment=Qt.AlignRight)
        lay.addLayout(top_h)

        self.sql_display=QTextEdit()
        self.sql_display.setReadOnly(False)
        self.sql_highlighter=SQLHighlighter(self.sql_display.document())
        lay.addWidget(self.sql_display)

        self.validation_lbl=QLabel("SQL Status: Unknown")
        lay.addWidget(self.validation_lbl)

        prof_btn=QPushButton("Data Profiler")
        prof_btn.clicked.connect(self.launch_data_profiler)
        lay.addWidget(prof_btn, alignment=Qt.AlignRight)

        self.sql_tab.setLayout(lay)

    def set_connections(self, conns):
        self.connections=conns
        if conns:
            self.update_conn_status(True,"Multiple DBs connected")
        else:
            self.update_conn_status(False,"No Connections")
        self.schema_tree.connections=conns
        self.schema_tree.populate_roots()

    def update_conn_status(self, st, info=""):
        if st:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: green;}")
            self.server_label.setText(info)
        else:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
            self.server_label.setText(info)

    def on_schema_filter(self, txt):
        def filter_item(it,text):
            show=False
            if text.lower() in it.text(0).lower():
                show=True
            for c in range(it.childCount()):
                if filter_item(it.child(c), text):
                    show=True
            it.setHidden(not show)
            return show

        for i in range(self.schema_tree.topLevelItemCount()):
            topi=self.schema_tree.topLevelItem(i)
            filter_item(topi, txt)

    def on_auto_gen_changed(self, st):
        self.auto_generate=(st==Qt.Checked)

    def on_op_mode_changed(self, idx):
        modes=["SELECT","INSERT","UPDATE","DELETE"]
        self.operation_mode=modes[idx]
        self.toggle_dml_canvas()
        if self.auto_generate:
            self.generate_sql()

    def add_subquery_to_canvas(self):
        self.canvas.add_subquery_item(200,200)
        if self.auto_generate:
            self.generate_sql()

    def combine_with_subvqb(self):
        d=SubVQBDialog(parent_vqb=self,parent=self)
        if d.exec_()==QDialog.Accepted:
            op, second_sql=d.getResult()
            old=self.sql_display.toPlainText().strip()
            if old:
                new_sql=old+f"\n{op}\n(\n{second_sql}\n)"
            else:
                new_sql=f"{op}\n(\n{second_sql}\n)"
            self.sql_display.setPlainText(new_sql)
            self.validate_sql()

    def launch_expr_builder(self):
        cols=self.get_all_possible_columns_for_dialog()
        dlg=AdvancedExpressionBuilderDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            a,ex=dlg.get_expression_data()
            old=self.sql_display.toPlainText()
            self.sql_display.setPlainText(old+f"\n-- Derived: {a}=\n{ex}")
            self.validate_sql()

    def launch_window_func(self):
        cols=self.get_all_possible_columns_for_dialog()
        dlg=AdvancedWindowFunctionDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            expression=dlg.get_expression()
            old=self.sql_display.toPlainText()
            self.sql_display.setPlainText(old+f"\n-- WindowFunc:\n{expression}")
            self.validate_sql()

    def launch_data_profiler(self):
        real_tables=[]
        for k,v in self.canvas.table_items.items():
            if hasattr(v,"columns") and not k.startswith("SubQueryItem_") and not k.startswith("BFS") and not k.startswith("Target:") and not k.startswith("CTE."):
                real_tables.append(k)
        if not real_tables:
            QMessageBox.information(self,"No Table","No real table on BFS to profile.")
            return
        (chosen,ok)=QtWidgets.QInputDialog.getItem(self,"Pick Table","Choose a table to profile:", real_tables,0,False)
        if not ok or not chosen:
            return
        titem=self.canvas.table_items.get(chosen)
        if not titem or not hasattr(titem,"columns"):
            QMessageBox.information(self,"No columns","That BFS item doesn't have columns.")
            return
        alias=chosen.split(".")[0]
        conn=None
        if alias in self.connections:
            conn=self.connections[alias].get("connection",None)
        if not conn:
            QMessageBox.warning(self,"No Conn","No DB connection for that table.")
            return
        colkeys=[]
        for c in titem.columns:
            colkeys.append(f"{chosen}.{c}")
        d=DataProfilerDialog(chosen,colkeys,conn,self)
        d.exec_()

    def run_sql(self):
        sql=self.sql_display.toPlainText().strip()
        if not sql:
            QMessageBox.information(self,"Empty SQL","No SQL to run.")
            return
        if not self.connections:
            QMessageBox.information(self,"No Connections","No DB connection found.")
            return
        first_key=list(self.connections.keys())[0]
        conn=self.connections[first_key].get("connection")
        if not conn:
            QMessageBox.warning(self,"No Conn","Connection invalid.")
            return
        try:
            c=conn.cursor()
            c.execute(sql)
            rows=c.fetchall()
            cols=[desc[0] for desc in c.description] if c.description else []
            dlg=ResultDataDialog(rows,cols,self)
            dlg.exec_()
        except Exception as ex:
            QMessageBox.warning(self,"SQL Error",f"Failed:\n{ex}")

    def get_all_possible_columns_for_dialog(self):
        arr=[]
        for k,v in self.canvas.table_items.items():
            if hasattr(v,"columns"):
                for c in v.columns:
                    arr.append(f"{k}.{c}")
        if self.canvas.collapsible_bfs_item:
            for c in self.canvas.collapsible_bfs_item.columns:
                arr.append(f"BFS.{c}")
        return arr

    def toggle_dml_canvas(self):
        if self.operation_mode=="SELECT":
            self.canvas.remove_mapping_lines()
            if self.canvas.operation_red_line:
                self.canvas.scene_.removeItem(self.canvas.operation_red_line)
                self.canvas.operation_red_line=None
            if self.canvas.collapsible_bfs_item:
                self.canvas.scene_.removeItem(self.canvas.collapsible_bfs_item)
                self.canvas.collapsible_bfs_item=None
            if self.canvas.target_table_item:
                self.canvas.scene_.removeItem(self.canvas.target_table_item)
                self.canvas.target_table_item=None
        else:
            self.canvas.add_vertical_red_line(450)
            if not self.canvas.collapsible_bfs_item:
                bfsCols=["srcCol1","srcCol2","key"]
                bfs=CollapsibleBFSGraphicsItem("BFS Source", bfsCols, self, 50,100)
                self.canvas.scene_.addItem(bfs)
                self.canvas.collapsible_bfs_item=bfs
            if not self.canvas.target_table_item:
                targCols=["colA","colB","key"]
                targ=CollapsibleTableGraphicsItem("Target:db.tbl", targCols, self, 600,100)
                self.canvas.scene_.addItem(targ)
                self.canvas.target_table_item=targ

    def generate_sql(self):
        if not self.auto_generate:
            return
        if self.operation_mode=="INSERT":
            body=self._generate_insert()
        elif self.operation_mode=="UPDATE":
            body=self._generate_update()
        elif self.operation_mode=="DELETE":
            body=self._generate_delete()
        else:
            body=self._generate_select()

        ctes=self.cte_panel.get_ctes()
        if ctes:
            cparts=[]
            for (n,s) in ctes:
                cparts.append(f"{n} AS (\n{s}\n)")
            cblock="WITH "+",\n    ".join(cparts)+"\n"
            final_sql=cblock+body
        else:
            final_sql=body
        self.sql_display.setPlainText(final_sql)
        self.validate_sql()

    def validate_sql(self):
        txt=self.sql_display.toPlainText().strip()
        if not txt:
            self.validation_lbl.setText("SQL Status: No SQL.")
            self.validation_lbl.setStyleSheet("color:orange;")
            return
        try:
            parser=FullSQLParser(txt)
            parser.parse()
            self.validation_lbl.setText("SQL Status: Valid.")
            self.validation_lbl.setStyleSheet("color:green;")
        except Exception as ex:
            self.validation_lbl.setText(f"SQL Status: Invalid - {ex}")
            self.validation_lbl.setStyleSheet("color:red;")

    def import_and_rebuild_canvas(self, root_expr, full_sql):
        for k in list(self.canvas.table_items.keys()):
            self.canvas.remove_table_item(k)
        self.canvas.remove_mapping_lines()

        while self.filter_panel.where_table.rowCount()>0:
            self.filter_panel.where_table.removeRow(0)
        while self.filter_panel.having_table.rowCount()>0:
            self.filter_panel.having_table.removeRow(0)

        while self.group_panel.gb_table.rowCount()>0:
            self.group_panel.gb_table.removeRow(0)
        while self.group_panel.agg_table.rowCount()>0:
            self.group_panel.agg_table.removeRow(0)

        while self.sort_panel.sort_table.rowCount()>0:
            self.sort_panel.sort_table.removeRow(0)
        self.sort_panel.limit_spin.setValue(0)
        self.sort_panel.offset_spin.setValue(0)

        while self.cte_panel.cte_table.rowCount()>0:
            self.cte_panel.cte_table.removeRow(0)
        self.cte_panel.cte_data.clear()

        main_expr=root_expr
        if root_expr.key=="WITH":
            cte_exps=root_expr.args.get("expressions") or []
            for cexp in cte_exps:
                cName=cexp.alias
                cSelect=cexp.this
                cSQL=cSelect.sql()
                self.cte_panel._add_cte_row(cName,cSQL)
            main_expr=root_expr.this

        if not isinstance(main_expr, exp.Select):
            self.sql_display.setPlainText(full_sql)
            self.validate_sql()
            return

        self.sql_display.setPlainText(full_sql)
        self.validate_sql()

    def _transform_table_key_for_federation(self, table_key):
        parts=table_key.split(".")
        if len(parts)<3:
            return table_key
        alias=parts[0]
        ls=self.linked_server_map.get(alias,None)
        if not ls:
            return table_key
        dbName=parts[1]
        tblName=parts[2]
        return f"[{ls}].[{dbName}].dbo.[{tblName}]"

    def _build_bfs_from(self):
        invert={v:k for k,v in self.canvas.table_items.items()}
        adj={}
        for k in self.canvas.table_items.keys():
            adj[k]=[]
        for jl in self.canvas.join_lines:
            s=invert.get(jl.start_item,None)
            e=invert.get(jl.end_item,None)
            if s and e:
                adj[s].append((e,jl))
                adj[e].append((s,jl))
        visited=set()
        blocks=[]
        for root in adj:
            if root not in visited:
                queue=[root]
                visited.add(root)
                seg=[root]
                while queue:
                    node=queue.pop(0)
                    for (nbr,ln) in adj[node]:
                        if nbr not in visited:
                            visited.add(nbr)
                            queue.append(nbr)
                            seg.append(f"{ln.join_type} JOIN {nbr} ON {ln.condition}")
                block="\n  ".join(seg)
                if not blocks:
                    blocks.append("FROM "+block)
                else:
                    blocks.append("-- Another subgraph:\nFROM "+block)
        if not blocks:
            return "-- no tables on canvas"

        final=[]
        for blk in blocks:
            lines=blk.split("\n")
            newB=[]
            for line in lines:
                tokens=line.split()
                out=[]
                for t in tokens:
                    if t.count(".")>=2 and t.upper() not in ["FROM","JOIN","ON","INNER","LEFT","RIGHT","FULL"]:
                        # transform cross-DB reference
                        newt=self._transform_table_key_for_federation(t)
                        out.append(newt)
                    else:
                        out.append(t)
                newB.append(" ".join(out))
            final.append("\n".join(newB))
        return "\n".join(final)

    def get_selected_columns(self):
        arr=[]
        for k,itm in self.canvas.table_items.items():
            if hasattr(itm,"get_selected_columns"):
                arr.extend(itm.get_selected_columns())
        if self.canvas.collapsible_bfs_item:
            bfs_cols=self.canvas.collapsible_bfs_item.get_checked_columns()
            arr.extend([f"BFS.{c}" for c in bfs_cols])
        return arr

    def _generate_select(self):
        scols=self.get_selected_columns()
        if not scols:
            scols=["*"]
        ags=self.group_panel.get_aggregates()
        final_cols=list(scols)
        for (f,c,a) in ags:
            if f.upper()=="CUSTOM":
                final_cols.append(c)
            else:
                final_cols.append(f"{f}({c}) AS {a}")

        lines=[]
        lines.append("SELECT "+", ".join(final_cols))
        lines.append(self._build_bfs_from())
        wfs=self.filter_panel.get_filters("WHERE")
        if wfs:
            conds=[f"{x[0]} {x[1]} {x[2]}" for x in wfs]
            lines.append("WHERE "+" AND ".join(conds))

        gb=self.group_panel.get_group_by()
        if gb:
            lines.append("GROUP BY "+", ".join(gb))

        hv=self.filter_panel.get_filters("HAVING")
        if hv:
            conds=[f"{x[0]} {x[1]} {x[2]}" for x in hv]
            lines.append("HAVING "+" AND ".join(conds))

        ob=self.sort_panel.get_order_bys()
        if ob:
            lines.append("ORDER BY "+", ".join(ob))
        lm=self.sort_panel.get_limit()
        if lm is not None:
            lines.append(f"LIMIT {lm}")
        off=self.sort_panel.get_offset()
        if off is not None:
            lines.append(f"OFFSET {off}")
        return "\n".join(lines)

    def _generate_select_sql_only(self):
        scols=self.get_selected_columns()
        if not scols:
            scols=["*"]
        lines=["SELECT "+", ".join(scols), self._build_bfs_from()]
        wfs=self.filter_panel.get_filters("WHERE")
        if wfs:
            conds=[f"{x[0]} {x[1]} {x[2]}" for x in wfs]
            lines.append("WHERE "+" AND ".join(conds))
        return "\n".join(lines)

    def _parse_target_info(self):
        if not self.canvas.target_table_item:
            return (None,None)
        txt=self.canvas.target_table_item.title_text.toPlainText()
        if txt.startswith("Target:"):
            raw=txt.replace("Target:","").strip()
            if "." in raw:
                parts=raw.split(".",1)
                return (parts[0],parts[1])
        return (None,None)

    def _parse_mapped_columns(self):
        arr=[]
        for ml in self.canvas.mapping_lines:
            arr.append((ml.source_col, ml.target_col))
        return arr

    def _generate_insert(self):
        db,tbl=self._parse_target_info()
        if not db or not tbl:
            return "-- No target => no INSERT"
        mapped=self._parse_mapped_columns()
        if not mapped:
            return "-- No column mapping => no INSERT"
        subsel=self._generate_select_sql_only()
        target_cols=[m[1] for m in mapped]
        lines=[
            f"INSERT INTO {db}.{tbl} ({', '.join(target_cols)})",
            subsel
        ]
        return "\n".join(lines)

    def _generate_update(self):
        db,tbl=self._parse_target_info()
        if not db or not tbl:
            return "-- No target => no UPDATE"
        mapped=self._parse_mapped_columns()
        if not mapped:
            return "-- No column mapping => no UPDATE"
        subsel=self._generate_select_sql_only()
        key_col="key"
        sets=[]
        for (src,tgt) in mapped:
            if tgt.lower()!=key_col:
                sets.append(f"{tgt}=src.{src}")
        lines=[
            f"UPDATE {db}.{tbl}",
            f"SET {', '.join(sets)}",
            "FROM (",
            subsel,
            ") AS src",
            f"WHERE {db}.{tbl}.{key_col} = src.{key_col}"
        ]
        return "\n".join(lines)

    def _generate_delete(self):
        db,tbl=self._parse_target_info()
        if not db or not tbl:
            return "-- No target => no DELETE"
        subsel=self._generate_select_sql_only()
        key_col="key"
        lines=[
            f"DELETE FROM {db}.{tbl}",
            f"WHERE {key_col} IN (",
            subsel,
            ")"
        ]
        return "\n".join(lines)

    def handle_drop(self, full_name, pos):
        """
        Invoked by BFS canvas drop => parse alias.db.tbl => load columns => add BFS item
        """
        if not self.connections:
            if full_name not in self.table_columns_map:
                self.table_columns_map[full_name]=["id","col1","col2"]
        else:
            parts=full_name.split(".")
            if len(parts)>=3:
                alias,dbn,tbl=parts[0],parts[1],parts[2]
                info=self.connections.get(alias)
                if info:
                    c=info["connection"]
                    dbt=info["db_type"]
                    realCols=load_columns(c,dbt,dbn,tbl)
                    if not realCols:
                        realCols=["id","col1","col2"]
                    self.table_columns_map[full_name]=realCols
            else:
                self.table_columns_map[full_name]=["id","col1","col2"]
        cols=self.table_columns_map[full_name]
        self.canvas.add_table_item(full_name,cols,pos.x(),pos.y())

    def show_cte_as_virtual_table(self, cte_name, columns):
        table_key=f"CTE.{cte_name}"
        if table_key in self.canvas.table_items:
            self.canvas.remove_table_item(table_key)
        if not columns:
            columns=["col1","col2"]
        self.canvas.add_table_item(table_key, columns, 600,100)

    def remove_virtual_cte_table(self, cte_name):
        table_key=f"CTE.{cte_name}"
        self.canvas.remove_table_item(table_key)

    def handle_remove_table(self, table_item):
        for k,v in list(self.canvas.table_items.items()):
            if v==table_item:
                self.canvas.remove_table_item(k)
                break

###############################################################################
# 12) ResultDataDialog => show SQL result sets
###############################################################################
class ResultDataDialog(QDialog):
    def __init__(self, rows, columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("SQL Results")
        self.resize(800,400)
        main=QVBoxLayout(self)
        tbl=QTableWidget(len(rows), len(columns))
        tbl.setHorizontalHeaderLabels(columns)
        for r_idx,rowv in enumerate(rows):
            for c_idx,val in enumerate(rowv):
                it=QTableWidgetItem(str(val))
                tbl.setItem(r_idx,c_idx,it)
        main.addWidget(tbl)

        btns=QDialogButtonBox(QDialogButtonBox.Ok)
        btns.accepted.connect(self.accept)
        main.addWidget(btns)
        self.setLayout(main)

###############################################################################
# 13) MainVQBWindow => top-level window
###############################################################################
class MainVQBWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Merged VQB with BFS + Federation + DataProfiler + DML")
        self.resize(1200,800)

        self.connections={}
        self.linked_server_map={}

        self.builder_tab=VisualQueryBuilderTab(
            multi_connections=self.connections,
            linked_map=self.linked_server_map
        )
        self.setCentralWidget(self.builder_tab)
        self.init_toolbar()

    def init_toolbar(self):
        tb=self.addToolBar("Main Toolbar")

        conn_act=QAction("Connections", self)
        conn_act.triggered.connect(self.on_manage_connections)
        tb.addAction(conn_act)

        fed_act=QAction("Linked Server Config", self)
        fed_act.triggered.connect(self.on_fed_config)
        tb.addAction(fed_act)

        fit_act=QAction("Fit to View", self)
        fit_act.triggered.connect(self.on_fit_view)
        tb.addAction(fit_act)

        layout_act=QAction("Auto-Layout", self)
        layout_act.triggered.connect(self.on_auto_layout)
        tb.addAction(layout_act)

        demo_act=QAction("Demo BFS Map (srcCol1->colA)", self)
        demo_act.triggered.connect(self.demo_map)
        tb.addAction(demo_act)

    def on_manage_connections(self):
        d=MultiODBCConnectDialog(self.connections,self)
        if d.exec_()==QDialog.Accepted:
            self.connections=d.get_connections()
            self.builder_tab.set_connections(self.connections)

    def on_fed_config(self):
        d=LinkedServerConfigDialog(existing_map=self.linked_server_map, parent=self)
        if d.exec_()==QDialog.Accepted:
            newmap=d.get_map()
            self.linked_server_map=newmap
            self.builder_tab.linked_server_map=newmap
            QMessageBox.information(self,"Linked Config Saved","Cross-DB references are now rewritten accordingly.")

    def on_fit_view(self):
        sc=self.builder_tab.canvas.scene_
        self.builder_tab.canvas.fitInView(sc.itemsBoundingRect(),Qt.KeepAspectRatio)

    def on_auto_layout(self):
        items=list(self.builder_tab.canvas.table_items.values())
        col_count=3
        xsp=250
        ysp=180
        for i,itm in enumerate(items):
            row=i//col_count
            col=i%col_count
            itm.setPos(col*xsp, row*ysp)
        for jl in self.builder_tab.canvas.join_lines:
            jl.update_line()

    def demo_map(self):
        cv=self.builder_tab.canvas
        if not cv.collapsible_bfs_item or not cv.target_table_item:
            QMessageBox.information(self,"No BFS or Target",
                                    "Switch to INSERT/UPDATE/DELETE so BFS/Target placeholders appear, then try again.")
            return
        left_txt=None
        for ch in cv.collapsible_bfs_item.childItems():
            if isinstance(ch,QGraphicsTextItem):
                if ch.toPlainText().strip().lower()=="srccol1":
                    left_txt=ch
                    break
        right_txt=None
        for ch in cv.target_table_item.childItems():
            if isinstance(ch,QGraphicsTextItem):
                if ch.toPlainText().strip().lower()=="cola":
                    right_txt=ch
                    break
        if not left_txt or not right_txt:
            QMessageBox.information(self,"Not Found","BFS 'srcCol1' or Target 'colA' not found.")
            return
        cv.create_mapping_line(left_txt,right_txt)

def main():
    app=QApplication(sys.argv)
    apply_fusion_style()
    w=MainVQBWindow()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()