#!/usr/bin/env python

import sys
import sqlite3
import logging
import json
import math
import re
from datetime import datetime, timedelta
from collections import deque

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QDateTime, QDate, QTimer
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QVBoxLayout, QHBoxLayout,
    QFormLayout, QPushButton, QLineEdit, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QInputDialog, QDockWidget,
    QDateTimeEdit, QTabWidget, QGroupBox, QAbstractItemView, QPlainTextEdit,
    QSplitter, QCheckBox
)
import pyqtgraph as pg

##############################################################################
# GLOBAL LOGGING SETUP
##############################################################################
logging.basicConfig(
    filename='brmtool_pyqtgraph.log',
    level=logging.DEBUG,
    format='%(asctime)s:%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

##############################################################################
# DATABASE URI
##############################################################################
DB_URI = "file::memory:?cache=shared"

##############################################################################
# UTILITY: DETERMINE OPERATION TYPE FROM SQL
##############################################################################
def get_op_type_from_sql(sql_text: str) -> str:
    txt = sql_text.strip().upper()
    if txt.startswith("INSERT"):
        return "INSERT"
    elif txt.startswith("DELETE"):
        return "DELETE"
    elif txt.startswith("UPDATE"):
        return "UPDATE"
    elif txt.startswith("SELECT"):
        return "SELECT"
    return "OTHER"

##############################################################################
# UTILITY: EXTRACT TABLES FROM SQL
##############################################################################
def extract_tables(sql_text: str):
    """
    Very naive parser to identify table references.
    We just search for 'FROM <name>' or 'JOIN <name>'.
    Returns a list of (db, table).
    """
    found = []
    tokens = re.split(r"\s+", sql_text.strip())
    for i, t in enumerate(tokens):
        if t.upper() in ("FROM", "JOIN"):
            if i+1 < len(tokens):
                tbl = re.sub(r"[;(),]", "", tokens[i+1])
                found.append(("", tbl))  # no DB name used
    return list(set(found))

##############################################################################
# SETUP DATABASE (WITH MULTI-STEP APPROVAL)
##############################################################################
def setup_in_memory_db():
    conn = sqlite3.connect(DB_URI, uri=True, timeout=10.0)
    conn.execute("PRAGMA foreign_keys = ON;")
    conn.row_factory = sqlite3.Row

    # Core tables
    conn.execute("""
    CREATE TABLE IF NOT EXISTS USERS(
        USER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        USERNAME TEXT UNIQUE NOT NULL,
        PASSWORD TEXT NOT NULL,
        USER_GROUP TEXT NOT NULL
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUPS(
        GROUP_NAME TEXT PRIMARY KEY,
        DESCRIPTION TEXT,
        EMAIL TEXT
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS GROUP_PERMISSIONS(
        GROUP_NAME TEXT NOT NULL,
        TARGET_TABLE TEXT NOT NULL,
        PRIMARY KEY(GROUP_NAME, TARGET_TABLE),
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    # Rule types, rule groups
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TYPES(
        RULE_TYPE_ID INTEGER PRIMARY KEY,
        RULE_TYPE_NAME TEXT NOT NULL UNIQUE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_GROUPS(
        GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT UNIQUE NOT NULL,
        DESCRIPTION TEXT
    );
    """)

    # Main BRM_RULES
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULES(
        RULE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_ID INTEGER,
        PARENT_RULE_ID INTEGER,
        RULE_TYPE_ID INTEGER NOT NULL,
        RULE_NAME TEXT NOT NULL,
        RULE_SQL TEXT NOT NULL,
        EFFECTIVE_START_DATE TEXT NOT NULL,
        EFFECTIVE_END_DATE TEXT,
        STATUS TEXT NOT NULL CHECK (STATUS IN ('ACTIVE','INACTIVE')),
        VERSION INTEGER NOT NULL DEFAULT 1,
        CREATED_BY TEXT NOT NULL,
        DESCRIPTION TEXT,
        OPERATION_TYPE TEXT,
        BUSINESS_JUSTIFICATION TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        UPDATED_BY TEXT,
        OWNER_GROUP TEXT NOT NULL,
        CLUSTER_NAME TEXT,
        APPROVAL_STATUS TEXT NOT NULL DEFAULT 'DRAFT',
        IS_GLOBAL INTEGER NOT NULL DEFAULT 0,
        CRITICAL_RULE INTEGER NOT NULL DEFAULT 0,
        CRITICAL_SCOPE TEXT NOT NULL DEFAULT 'NONE',
        FOREIGN KEY(RULE_TYPE_ID) REFERENCES BRM_RULE_TYPES(RULE_TYPE_ID),
        FOREIGN KEY(PARENT_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_ID) REFERENCES BRM_RULE_GROUPS(GROUP_ID) ON DELETE SET NULL
    );
    """)

    # Dependencies, lineage, audit
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_TABLE_DEPENDENCIES(
        DEPENDENCY_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        DATABASE_NAME TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_AUDIT_LOG(
        AUDIT_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        ACTION TEXT NOT NULL,
        TABLE_NAME TEXT NOT NULL,
        RECORD_ID TEXT NOT NULL,
        ACTION_BY TEXT NOT NULL,
        OLD_DATA TEXT,
        NEW_DATA TEXT,
        ACTION_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_LINEAGE(
        LINEAGE_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_INFO TEXT,
        TARGET_INFO TEXT,
        TRANSFORMATION_DETAILS TEXT,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    # Group backups
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    # Column mapping
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_COLUMN_MAPPING(
        MAPPING_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        RULE_ID INTEGER NOT NULL,
        SOURCE_RULE_ID INTEGER NOT NULL,
        SOURCE_COLUMN_NAME TEXT NOT NULL,
        TARGET_COLUMN_NAME TEXT NOT NULL,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(SOURCE_RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    # Custom rule groups
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_RULE_GROUPS(
        CUSTOM_GROUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_NAME TEXT NOT NULL UNIQUE,
        OWNER_BUSINESS_GROUP TEXT NOT NULL,
        CREATED_BY TEXT NOT NULL,
        CREATED_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    """)
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_MEMBERS(
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        RULE_ID INTEGER NOT NULL,
        PRIMARY KEY(CUSTOM_GROUP_ID, RULE_ID),
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE,
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE
    );
    """)

    # Approvers
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BUSINESS_GROUP_APPROVERS(
        APPROVER_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    # Multi-step approvals
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_RULE_APPROVALS(
        RULE_ID INTEGER NOT NULL,
        GROUP_NAME TEXT NOT NULL,
        USERNAME TEXT NOT NULL,
        APPROVED_FLAG INTEGER NOT NULL DEFAULT 0,
        APPROVED_TIMESTAMP DATETIME,
        APPROVAL_STAGE INTEGER NOT NULL DEFAULT 1,
        PRIMARY KEY(RULE_ID, GROUP_NAME, USERNAME),
        FOREIGN KEY(RULE_ID) REFERENCES BRM_RULES(RULE_ID) ON DELETE CASCADE,
        FOREIGN KEY(GROUP_NAME) REFERENCES BUSINESS_GROUPS(GROUP_NAME) ON DELETE CASCADE
    );
    """)

    # Custom group backups
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)

    # Seed data
    groups = [
        ("Admin","Admin group","admin@example.com"),
        ("BG1","Group1","bg1@example.com"),
        ("BG2","Group2","bg2@example.com"),
        ("BG3","Group3","bg3@example.com"),
    ]
    for g in groups:
        conn.execute("""
        INSERT OR IGNORE INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL)
        VALUES(?,?,?)
        """,(g[0],g[1],g[2]))

    users = [
        ("admin","admin","Admin"),
        ("bg1_user","user","BG1"),
        ("bg2_user","user","BG2"),
        ("bg3_user","user","BG3"),
    ]
    for u in users:
        conn.execute("""
        INSERT OR IGNORE INTO USERS(USERNAME,PASSWORD,USER_GROUP)
        VALUES(?,?,?)
        """,(u[0],u[1],u[2]))

    perms = [
        ("Admin","TABLE_A"),
        ("Admin","TABLE_B"),
        ("Admin","TABLE_C"),
        ("Admin","TABLE_D"),
        ("BG1","TABLE_A"),
        ("BG1","TABLE_B"),
        ("BG2","TABLE_C"),
        ("BG3","TABLE_D")
    ]
    for p in perms:
        conn.execute("""
        INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE)
        VALUES(?,?)
        """, p)

    conn.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(1,'DQ')")
    conn.execute("INSERT OR IGNORE INTO BRM_RULE_TYPES(RULE_TYPE_ID,RULE_TYPE_NAME) VALUES(2,'DM')")

    rule_groups = [
        ("Finance Rules", "Rules related to financial data"),
        ("HR Rules", "Rules related to human resources")
    ]
    for rg in rule_groups:
        conn.execute("""
        INSERT OR IGNORE INTO BRM_RULE_GROUPS(GROUP_NAME,DESCRIPTION)
        VALUES(?,?)
        """,(rg[0], rg[1]))

    # Default approvers
    conn.execute("""INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG1','bg1_user')""")
    conn.execute("""INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG2','bg2_user')""")
    conn.execute("""INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES('BG3','bg3_user')""")

    conn.commit()
    return conn

##############################################################################
# HELPER: ADD AUDIT LOG
##############################################################################
def add_audit_log(conn, action, table_name, record_id, action_by, old_data, new_data):
    c = conn.cursor()
    c.execute("""
      INSERT INTO BRM_AUDIT_LOG(ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA)
      VALUES(?,?,?,?,?,?)
    """,(action, table_name, str(record_id), action_by,
         json.dumps(old_data) if old_data else None,
         json.dumps(new_data) if new_data else None))
    conn.commit()

##############################################################################
# BFS for ETL, Stopping Child Rules If Critical Rule Fails
##############################################################################
def build_rule_adjacency(conn):
    c = conn.cursor()
    c.execute("SELECT RULE_ID,PARENT_RULE_ID FROM BRM_RULES")
    rows = c.fetchall()

    children_map = {}
    all_ids = set()
    parent_ids = set()
    for r in rows:
        rid = r["RULE_ID"]
        pid = r["PARENT_RULE_ID"]
        all_ids.add(rid)
        if pid:
            parent_ids.add(pid)
            children_map.setdefault(pid, []).append(rid)

    root_rules = [rid for rid in all_ids if rid not in parent_ids]
    return children_map, root_rules

def run_rule_sql(conn, rule_sql):
    """
    Execute the rule_sql. If no row is returned, treat it as a pass.
    If a row is returned, we expect the first column to be 1=pass, 0=fail.
    Any exception => fail.
    """
    try:
        c = conn.cursor()
        c.execute(rule_sql)
        row = c.fetchone()
        if row is None:
            return True  # If no row returned => pass
        pass_fail = row[0]
        return (pass_fail == 1)
    except Exception as e:
        logger.error(f"Rule execution error: {e}")
        return False

def execute_rules_in_order(conn):
    children_map, root_rules = build_rule_adjacency(conn)
    executed = []
    skipped = set()
    queue = list(root_rules)

    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES")
    all_rules = c.fetchall()
    rule_lookup = {r["RULE_ID"]: dict(r) for r in all_rules}

    while queue:
        rid = queue.pop(0)
        if rid in skipped:
            continue
        if rid not in rule_lookup:
            logger.warning(f"Rule {rid} not found in DB.")
            continue

        rinfo = rule_lookup[rid]
        rule_name = rinfo["RULE_NAME"]
        rule_sql = rinfo["RULE_SQL"]
        is_critical = (rinfo["CRITICAL_RULE"] == 1)
        crit_scope = rinfo["CRITICAL_SCOPE"].upper()
        grp = rinfo["OWNER_GROUP"]
        clus = rinfo.get("CLUSTER_NAME", "")

        logger.info(f"Executing rule {rid}: {rule_name}")
        passed = run_rule_sql(conn, rule_sql)
        if passed:
            logger.info(f"Rule {rid} PASSED.")
            executed.append(rid)
            if rid in children_map:
                for child_id in children_map[rid]:
                    if child_id not in skipped:
                        queue.append(child_id)
        else:
            logger.warning(f"Rule {rid} FAILED.")
            if is_critical and crit_scope != "NONE":
                logger.warning(f"Critical rule => scope={crit_scope}, skipping children.")
                stack = children_map.get(rid, [])[:]
                while stack:
                    cid = stack.pop()
                    if cid in rule_lookup:
                        cinfo = rule_lookup[cid]
                        skip_it = False
                        if crit_scope == "GLOBAL":
                            skip_it = True
                        elif crit_scope == "GROUP":
                            if cinfo["OWNER_GROUP"] == grp:
                                skip_it = True
                        elif crit_scope == "CLUSTER":
                            if cinfo.get("CLUSTER_NAME", "") == clus:
                                skip_it = True
                        if skip_it:
                            skipped.add(cid)
                            if cid in children_map:
                                stack.extend(children_map[cid])

    logger.info(f"ETL Complete. Executed={executed}, Skipped={list(skipped)}")
    return executed, skipped

##############################################################################
# MULTI-STEP APPROVAL LOGIC
##############################################################################
MULTISTEP_ORDER = ["BG1","BG2","BG3","FINAL"]

def find_impacted_business_groups(conn, rule_id):
    impacted = set()
    c = conn.cursor()
    c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    row = c.fetchone()
    if row:
        impacted.add(row["OWNER_GROUP"])

    queue = [rule_id]
    visited = set()
    while queue:
        curr = queue.pop()
        if curr in visited:
            continue
        visited.add(curr)
        c.execute("SELECT RULE_ID FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=?",(curr,))
        children = c.fetchall()
        for ch in children:
            cid = ch["RULE_ID"]
            c.execute("SELECT OWNER_GROUP FROM BRM_RULES WHERE RULE_ID=?",(cid,))
            row2 = c.fetchone()
            if row2:
                impacted.add(row2["OWNER_GROUP"])
            queue.append(cid)
    return impacted

def create_multistep_approvals(conn, rule_id, impacted_bg_list):
    c = conn.cursor()
    stage_counter = 1
    stage_list = []

    for step_bg in MULTISTEP_ORDER:
        if step_bg == "FINAL":
            stage_list.append((step_bg, stage_counter))
            stage_counter += 1
        else:
            if step_bg in impacted_bg_list:
                stage_list.append((step_bg, stage_counter))
                stage_counter += 1

    for (bg, st) in stage_list:
        if bg == "FINAL":
            user_ap = "final_approver"
            c.execute("""
              INSERT OR IGNORE INTO BRM_RULE_APPROVALS(RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVAL_STAGE)
              VALUES(?,?,?,?,?)
            """,(rule_id,bg,user_ap,0,st))
        else:
            c.execute("SELECT USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(bg,))
            row_aps = c.fetchall()
            for raps in row_aps:
                c.execute("""
                  INSERT OR IGNORE INTO BRM_RULE_APPROVALS
                  (RULE_ID,GROUP_NAME,USERNAME,APPROVED_FLAG,APPROVAL_STAGE)
                  VALUES(?,?,?,?,?)
                """,(rule_id,bg,raps["USERNAME"],0,st))
    conn.commit()

def get_current_approval_stage(conn, rule_id):
    c = conn.cursor()
    c.execute("""
      SELECT MIN(APPROVAL_STAGE) as stage
      FROM BRM_RULE_APPROVALS
      WHERE RULE_ID=? AND APPROVED_FLAG=0
    """,(rule_id,))
    row = c.fetchone()
    if row and row["stage"]:
        return row["stage"]
    return None

def check_multistep_approval_complete(conn, rule_id):
    c = conn.cursor()
    c.execute("""
      SELECT COUNT(*) as not_done
      FROM BRM_RULE_APPROVALS
      WHERE RULE_ID=? AND APPROVED_FLAG=0
    """,(rule_id,))
    row = c.fetchone()
    return (row["not_done"] == 0)

def find_child_rules(conn, parent_rule_id):
    results = []
    queue = [parent_rule_id]
    visited = set()
    c = conn.cursor()
    while queue:
        current = queue.pop()
        if current in visited:
            continue
        visited.add(current)
        c.execute("SELECT RULE_ID, RULE_NAME FROM BRM_RULES WHERE PARENT_RULE_ID=?",(current,))
        ch = c.fetchall()
        for row in ch:
            results.append(dict(row))
            queue.append(row["RULE_ID"])
    return results

##############################################################################
# CRUD with MULTI-STEP APPROVALS
##############################################################################
def add_rule(conn, rule_data, created_by, user_group):
    is_global = rule_data.get("IS_GLOBAL",0)
    if is_global==1 and user_group!="Admin":
        raise ValueError("Only Admin can create a global rule.")

    c = conn.cursor()
    c.execute("""
      INSERT INTO BRM_RULES(
        GROUP_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
        EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
        CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
        OWNER_GROUP,APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE
      ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?, ?, ?, ?)
    """,(
      rule_data.get("GROUP_ID"),
      rule_data.get("PARENT_RULE_ID"),
      rule_data["RULE_TYPE_ID"],
      rule_data["RULE_NAME"],
      rule_data["RULE_SQL"],
      rule_data["EFFECTIVE_START_DATE"],
      rule_data.get("EFFECTIVE_END_DATE"),
      "INACTIVE",
      1,
      created_by,
      rule_data.get("DESCRIPTION"),
      rule_data.get("OPERATION_TYPE"),
      rule_data.get("BUSINESS_JUSTIFICATION",""),
      rule_data["OWNER_GROUP"],
      "APPROVAL_IN_PROGRESS",
      is_global,
      rule_data.get("CRITICAL_RULE",0),
      rule_data.get("CRITICAL_SCOPE","NONE")
    ))
    new_id = c.lastrowid
    

    # Insert dependencies
def add_rule(conn, rule_data, created_by, user_group):
    """
    Example snippet focusing on 'Insert Dependencies' without syntax errors.
    """

    c = conn.cursor()

    # -- Insert the BRM_RULES record (simplified for demo) --
    c.execute("""
        INSERT INTO BRM_RULES(
            RULE_TYPE_ID,
            RULE_NAME,
            RULE_SQL,
            OWNER_GROUP
        )
        VALUES(?,?,?,?)
    """, (
        rule_data["RULE_TYPE_ID"],
        rule_data["RULE_NAME"],
        rule_data["RULE_SQL"],
        rule_data["OWNER_GROUP"]
    ))
    new_rule_id = c.lastrowid

    # -- Extract tables from the rule SQL --
    deps = extract_tables(rule_data["RULE_SQL"])

    # -- Insert dependencies for each table found --
    for (dbn, tbn) in deps:
        c.execute("""
            INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                RULE_ID,
                DATABASE_NAME,
                TABLE_NAME,
                COLUMN_NAME
            )
            VALUES(?,?,?,?)
        """, (
            new_rule_id,
            dbn,
            tbn,
            "DerivedCol"
        ))
    
    conn.commit()
    return new_rule_id

    # If global => skip multi-step approvals
    if is_global==1:
        logger.info(f"Global rule {new_id} => skipping multi-step approvals.")
    else:
        impacted = find_impacted_business_groups(conn, new_id)
        create_multistep_approvals(conn, new_id, impacted)
    return new_id

def update_rule(conn, rule_data, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_data["RULE_ID"],))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    old_data = dict(old)

    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can update a global rule.")
    if rule_data.get("IS_GLOBAL",old["IS_GLOBAL"])==1 and user_group!="Admin":
        raise ValueError("Only Admin can set a rule global.")

    c.execute("""
      UPDATE BRM_RULES
      SET
        GROUP_ID=?,
        PARENT_RULE_ID=?,
        RULE_TYPE_ID=?,
        RULE_NAME=?,
        RULE_SQL=?,
        EFFECTIVE_START_DATE=?,
        EFFECTIVE_END_DATE=?,
        STATUS='INACTIVE',
        VERSION=VERSION+1,
        UPDATED_BY=?,
        DESCRIPTION=?,
        OPERATION_TYPE=?,
        BUSINESS_JUSTIFICATION=?,
        OWNER_GROUP=?,
        APPROVAL_STATUS='APPROVAL_IN_PROGRESS',
        IS_GLOBAL=?,
        CRITICAL_RULE=?,
        CRITICAL_SCOPE=?
      WHERE RULE_ID=?
    """,(
      rule_data.get("GROUP_ID",old["GROUP_ID"]),
      rule_data.get("PARENT_RULE_ID",old["PARENT_RULE_ID"]),
      rule_data["RULE_TYPE_ID"],
      rule_data["RULE_NAME"],
      rule_data["RULE_SQL"],
      rule_data["EFFECTIVE_START_DATE"],
      rule_data.get("EFFECTIVE_END_DATE"),
      updated_by,
      rule_data.get("DESCRIPTION"),
      rule_data.get("OPERATION_TYPE"),
      rule_data.get("BUSINESS_JUSTIFICATION",""),
      rule_data["OWNER_GROUP"],
      rule_data.get("IS_GLOBAL",old["IS_GLOBAL"]),
      rule_data.get("CRITICAL_RULE",old["CRITICAL_RULE"]),
      rule_data.get("CRITICAL_SCOPE",old["CRITICAL_SCOPE"]),
      rule_data["RULE_ID"]
    ))

    # Update dependencies
    c.execute("DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rule_data["RULE_ID"],))
    deps = extract_tables(rule_data["RULE_SQL"])
    for (dbn,tbn) in deps:
        c.execute("""
          INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME)
          VALUES(?,?,?,?)
        """,(rule_data["RULE_ID"],dbn,tbn,"DerivedCol"))

    new_data = dict(old_data)
    for k,v in rule_data.items():
        new_data[k] = v
    new_data["VERSION"] = old["VERSION"]+1
    add_audit_log(conn,"UPDATE","BRM_RULES", rule_data["RULE_ID"], updated_by, old_data, new_data)
    conn.commit()

    # If global => skip multi-step approvals
    if old["IS_GLOBAL"]==1 or rule_data.get("IS_GLOBAL",0)==1:
        logger.info(f"Global rule {rule_data['RULE_ID']} updated => skipping multi-step approvals.")
    else:
        c.execute("DELETE FROM BRM_RULE_APPROVALS WHERE RULE_ID=?",(rule_data["RULE_ID"],))
        impacted = find_impacted_business_groups(conn, rule_data["RULE_ID"])
        create_multistep_approvals(conn, rule_data["RULE_ID"], impacted)

def deactivate_rule(conn, rule_id, updated_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot deactivate if not fully APPROVED.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can deactivate a global rule.")
    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=? AND STATUS='ACTIVE'",(rule_id,))
    kids = c.fetchall()
    if kids:
        raise ValueError("Child rules must be deactivated first.")

    old_data = dict(old)
    c.execute("UPDATE BRM_RULES SET STATUS='INACTIVE',UPDATED_BY=?,VERSION=VERSION+1 WHERE RULE_ID=?",
              (updated_by, rule_id))
    new_data = dict(old_data)
    new_data["STATUS"]="INACTIVE"
    new_data["VERSION"]=old["VERSION"]+1
    add_audit_log(conn,"DEACTIVATE","BRM_RULES",rule_id,updated_by,old_data,new_data)
    conn.commit()

def delete_rule(conn, rule_id, action_by, user_group):
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    old = c.fetchone()
    if not old:
        raise ValueError("Rule not found.")
    if old["IS_GLOBAL"]==1 and user_group!="Admin":
        raise ValueError("Only Admin can delete a global rule.")
    if old["APPROVAL_STATUS"]!="APPROVED":
        raise ValueError("Cannot delete unless fully APPROVED.")
    if old["STATUS"]!="INACTIVE":
        raise ValueError("Must be INACTIVE first.")

    c.execute("SELECT * FROM BRM_RULES WHERE PARENT_RULE_ID=?",(rule_id,))
    kids = c.fetchall()
    if kids:
        raise ValueError("Child rules exist.")

    c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE SOURCE_RULE_ID=? OR RULE_ID=?",(rule_id,rule_id))
    leftover = c.fetchall()
    if leftover:
        raise ValueError("Remove or re-map column references first.")

    old_data = dict(old)
    c.execute("DELETE FROM BRM_RULES WHERE RULE_ID=?",(rule_id,))
    add_audit_log(conn,"DELETE","BRM_RULES",rule_id,action_by,old_data,None)
    conn.commit()

##############################################################################
# LOGIN DIALOG
##############################################################################
class LoginDialog(QDialog):
    """
    Login dialog that checks credentials in USERS table.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_id = None
        self.user_group = None
        self.setWindowTitle("Login")
        self.setFixedSize(300, 200)

        layout = QVBoxLayout(self)

        self.user_edit = QLineEdit()
        self.user_edit.setPlaceholderText("Username")
        layout.addWidget(QLabel("Username:"))
        layout.addWidget(self.user_edit)

        self.pass_edit = QLineEdit()
        self.pass_edit.setPlaceholderText("Password")
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(QLabel("Password:"))
        layout.addWidget(self.pass_edit)

        btn = QPushButton("Login")
        btn.clicked.connect(self.do_login)
        layout.addWidget(btn)

        self.setLayout(layout)

    def do_login(self):
        usern = self.user_edit.text().strip()
        passw = self.pass_edit.text().strip()
        if not usern or not passw:
            QMessageBox.warning(self, "Error", "Enter username & password.")
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USER_GROUP FROM USERS WHERE USERNAME=? AND PASSWORD=?",(usern, passw))
        row = c.fetchone()
        if row:
            self.user_id = row["USER_ID"]
            self.user_group = row["USER_GROUP"]
            self.accept()
        else:
            QMessageBox.warning(self, "Login Failed", "Invalid username or password.")

##############################################################################
# RULE EDITOR DIALOG
##############################################################################
class RuleEditorDialog(QDialog):
    """
    Allows adding or editing a BRM_RULE record with fields for name, SQL, etc.
    """
    def __init__(self, connection, rule_types, logged_in_user, rule_data=None, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.rule_types = rule_types  # dict: {rule_type_name: type_id}
        self.logged_in_user = logged_in_user
        self.rule_data = rule_data

        title = "Edit Rule" if rule_data else "Add New Rule"
        self.setWindowTitle(title)
        self.resize(900, 500)

        main_layout = QHBoxLayout(self)

        # LEFT BOX: Basic Info
        left_box = QGroupBox("Basic Info")
        left_layout = QFormLayout(left_box)

        # group combo
        self.group_combo = QComboBox()
        self.group_combo.addItem("None", None)
        c = self.connection.cursor()
        try:
            c.execute("SELECT GROUP_ID,GROUP_NAME FROM BRM_RULE_GROUPS ORDER BY GROUP_NAME")
            rr = c.fetchall()
            for row in rr:
                self.group_combo.addItem(row["GROUP_NAME"], row["GROUP_ID"])
        except Exception as ex:
            logger.warning(f"Error loading rule groups: {ex}")
        left_layout.addRow("Rule Group:", self.group_combo)

        # parent rule combo
        self.parent_rule_combo = QComboBox()
        self.parent_rule_combo.addItem("None",None)
        try:
            c.execute("SELECT RULE_ID,RULE_NAME FROM BRM_RULES WHERE STATUS='ACTIVE'")
            for row in c.fetchall():
                self.parent_rule_combo.addItem(
                    f"{row['RULE_NAME']} (ID:{row['RULE_ID']})", row["RULE_ID"]
                )
        except Exception as ex:
            logger.warning(f"Error loading parent rules: {ex}")
        left_layout.addRow("Parent Rule:", self.parent_rule_combo)

        self.name_edit = QLineEdit()
        left_layout.addRow("Rule Name:", self.name_edit)

        self.type_combo = QComboBox()
        for rt_name in self.rule_types:
            self.type_combo.addItem(rt_name)
        left_layout.addRow("Rule Type:", self.type_combo)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["ACTIVE","INACTIVE"])
        left_layout.addRow("Status (informational):", self.status_combo)

        self.start_dt = QDateTimeEdit(QDateTime.currentDateTime())
        self.start_dt.setCalendarPopup(True)
        self.start_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("Start Date:", self.start_dt)

        self.end_dt = QDateTimeEdit(QDateTime.currentDateTime().addDays(30))
        self.end_dt.setCalendarPopup(True)
        self.end_dt.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        left_layout.addRow("End Date:", self.end_dt)

        self.owner_grp_combo = QComboBox()
        try:
            c.execute("SELECT DISTINCT GROUP_NAME FROM GROUP_PERMISSIONS ORDER BY GROUP_NAME")
            for g in c.fetchall():
                self.owner_grp_combo.addItem(g["GROUP_NAME"], g["GROUP_NAME"])
        except Exception as ex:
            logger.warning(f"Error loading group permissions: {ex}")
        left_layout.addRow("Owner Group:", self.owner_grp_combo)

        # If Admin => global checkbox
        self.global_checkbox = None
        if self.logged_in_user=="Admin":
            self.global_checkbox = QCheckBox("Global (admin-only)")
            left_layout.addRow("Global:", self.global_checkbox)

        # Critical
        self.critical_checkbox = QCheckBox("Critical (Stop-on-fail)")
        left_layout.addRow("Critical Rule:", self.critical_checkbox)

        # Scope
        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        left_layout.addRow("Critical Scope:", self.scope_combo)

        main_layout.addWidget(left_box)

        # RIGHT BOX: Details & Logic
        right_box = QGroupBox("Details & Logic")
        right_layout = QFormLayout(right_box)

        self.sql_editor = QPlainTextEdit()
        font = QtGui.QFont("Courier", 10)
        self.sql_editor.setFont(font)
        right_layout.addRow(QLabel("Rule SQL:"), self.sql_editor)

        self.description_edit = QTextEdit()
        right_layout.addRow(QLabel("Description:"), self.description_edit)

        self.justification_edit = QTextEdit()
        right_layout.addRow(QLabel("Justification:"), self.justification_edit)

        btn_box = QHBoxLayout()
        self.save_btn = QPushButton("Save" if rule_data else "Add")
        self.save_btn.clicked.connect(self.on_save)
        btn_box.addWidget(self.save_btn)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_box.addWidget(cancel_btn)
        right_layout.addRow(btn_box)

        main_layout.addWidget(right_box)
        self.setLayout(main_layout)

        if self.rule_data:
            self.load_rule_data(self.rule_data)

    def load_rule_data(self, rd):
        if rd["GROUP_ID"]:
            idx = self.group_combo.findData(rd["GROUP_ID"])
            if idx>=0:
                self.group_combo.setCurrentIndex(idx)
        if rd["PARENT_RULE_ID"]:
            idx2 = self.parent_rule_combo.findData(rd["PARENT_RULE_ID"])
            if idx2>=0:
                self.parent_rule_combo.setCurrentIndex(idx2)
        self.name_edit.setText(rd["RULE_NAME"])

        # set rule type
        for nm,tid in self.rule_types.items():
            if tid==rd["RULE_TYPE_ID"]:
                i = self.type_combo.findText(nm)
                if i>=0:
                    self.type_combo.setCurrentIndex(i)
                break

        st = rd["STATUS"]
        i_st = self.status_combo.findText(st)
        if i_st>=0:
            self.status_combo.setCurrentIndex(i_st)

        try:
            sdt = datetime.strptime(rd["EFFECTIVE_START_DATE"],"%Y-%m-%d %H:%M:%S")
            self.start_dt.setDateTime(QtCore.QDateTime(sdt))
        except Exception:
            pass

        if rd["EFFECTIVE_END_DATE"]:
            try:
                edt = datetime.strptime(rd["EFFECTIVE_END_DATE"],"%Y-%m-%d %H:%M:%S")
                self.end_dt.setDateTime(QtCore.QDateTime(edt))
            except Exception:
                pass

        og = rd["OWNER_GROUP"]
        i_og = self.owner_grp_combo.findText(og)
        if i_og>=0:
            self.owner_grp_combo.setCurrentIndex(i_og)

        self.sql_editor.setPlainText(rd["RULE_SQL"] or "")
        if rd.get("DESCRIPTION"):
            self.description_edit.setText(rd["DESCRIPTION"])
        if rd.get("BUSINESS_JUSTIFICATION"):
            self.justification_edit.setText(rd["BUSINESS_JUSTIFICATION"])

        if self.global_checkbox and rd.get("IS_GLOBAL",0)==1:
            self.global_checkbox.setChecked(True)
        if rd.get("CRITICAL_RULE",0)==1:
            self.critical_checkbox.setChecked(True)

        scope_val = rd.get("CRITICAL_SCOPE","NONE")
        idx_scope = self.scope_combo.findText(scope_val.upper())
        if idx_scope>=0:
            self.scope_combo.setCurrentIndex(idx_scope)

    def on_save(self):
        if not self.name_edit.text().strip():
            QMessageBox.warning(self,"Error","Name is empty.")
            return
        sql_text = self.sql_editor.toPlainText().strip()
        if not sql_text:
            QMessageBox.warning(self,"Error","SQL is empty.")
            return

        op_type = get_op_type_from_sql(sql_text)
        rule_dict = {
            "GROUP_ID": self.group_combo.currentData(),
            "PARENT_RULE_ID": self.parent_rule_combo.currentData(),
            "RULE_TYPE_ID": self.rule_types.get(self.type_combo.currentText()),
            "RULE_NAME": self.name_edit.text().strip(),
            "RULE_SQL": sql_text,
            "EFFECTIVE_START_DATE": self.start_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "EFFECTIVE_END_DATE": self.end_dt.dateTime().toString("yyyy-MM-dd HH:mm:ss"),
            "STATUS": self.status_combo.currentText(),
            "DESCRIPTION": self.description_edit.toPlainText().strip(),
            "OPERATION_TYPE": op_type,
            "BUSINESS_JUSTIFICATION": self.justification_edit.toPlainText().strip(),
            "OWNER_GROUP": self.owner_grp_combo.currentText().strip(),
            "IS_GLOBAL": 1 if (self.global_checkbox and self.global_checkbox.isChecked()) else 0,
            "CRITICAL_RULE": 1 if self.critical_checkbox.isChecked() else 0,
            "CRITICAL_SCOPE": self.scope_combo.currentText().upper()
        }
        created_by = self.logged_in_user
        if self.rule_data:
            rule_dict["RULE_ID"] = self.rule_data["RULE_ID"]
            confirm = QMessageBox.question(self,"Confirm","Update rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                update_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success","Rule updated. Approval re-initiated (multi-step).")
                self.accept()
            except Exception as e:
                QMessageBox.critical(self,"DB Error",str(e))
        else:
            confirm = QMessageBox.question(self,"Confirm","Add new rule?")
            if confirm!=QMessageBox.Yes:
                return
            try:
                new_id = add_rule(self.connection, rule_dict, created_by, self.logged_in_user)
                QMessageBox.information(self,"Success",f"Rule created (ID={new_id}). Approval in progress.")
                self.accept()
            except Exception as e:
                QMessageBox.critical(self,"DB Error",str(e))

##############################################################################
# RULE ANALYTICS DIALOG
##############################################################################
class RuleAnalyticsDialog(QDialog):
    """
    Displays some simple bar/pie charts about rules:
    - Count of rules by creator
    - Distribution of rule statuses
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.setWindowTitle("Rule Analytics")
        self.resize(800, 600)

        layout = QVBoxLayout(self)
        chart_hbox = QHBoxLayout()

        self.bar_chart = pg.PlotWidget(title="Number of Rules by Creator")
        self.bar_chart.setBackground('w')
        chart_hbox.addWidget(self.bar_chart)

        self.pie_chart = pg.PlotWidget(title="Rule Status Distribution")
        self.pie_chart.setBackground('w')
        chart_hbox.addWidget(self.pie_chart)

        layout.addLayout(chart_hbox)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
        self.setLayout(layout)

        self.load_charts()

    def load_charts(self):
        c = self.connection.cursor()

        # Creator distribution
        c.execute("SELECT CREATED_BY, COUNT(*) as cnt FROM BRM_RULES GROUP BY CREATED_BY")
        creators_data = c.fetchall()
        creators = {row["CREATED_BY"]: row["cnt"] for row in creators_data}

        # Status distribution
        status_counts = {"ACTIVE":0,"INACTIVE":0,"DELETED":0}
        c.execute("SELECT STATUS,COUNT(*) as sc FROM BRM_RULES GROUP BY STATUS")
        for row in c.fetchall():
            s_up = row["STATUS"].upper()
            if s_up in status_counts:
                status_counts[s_up] = row["sc"]
        # Count how many times DELETED from the audit log
        c.execute("SELECT COUNT(*) as delcnt FROM BRM_AUDIT_LOG WHERE ACTION='DELETE'")
        row2 = c.fetchone()
        if row2:
            status_counts["DELETED"] = row2["delcnt"]

        # Bar Chart
        self.bar_chart.clear()
        if creators:
            sorted_creators = sorted(creators.items(), key=lambda x:x[1],reverse=True)
            names = [sc[0] for sc in sorted_creators]
            vals = [sc[1] for sc in sorted_creators]
            bar_item = pg.BarGraphItem(x=range(len(names)), height=vals, width=0.6, brush="skyblue")
            self.bar_chart.addItem(bar_item)
            ax = self.bar_chart.getAxis("bottom")
            ax.setTicks([ list(zip(range(len(names)), names)) ])
            self.bar_chart.setLabel("left","Number of Rules")
            self.bar_chart.setLabel("bottom","Created By")
            self.bar_chart.showGrid(x=True,y=True)

        # Pie Chart
        self.pie_chart.clear()
        total = sum(status_counts.values())
        if total>0:
            angles = [360*(v/total) for v in status_counts.values()]
            start=90
            color_map = {"ACTIVE":"green","INACTIVE":"red","DELETED":"gray"}

            scene = self.pie_chart.scene()
            if not scene:
                from PyQt5.QtWidgets import QGraphicsScene
                scene = QGraphicsScene()
                self.pie_chart.setScene(scene)

            for (k,v),ang in zip(status_counts.items(), angles):
                if ang>0:
                    wedge = QtGui.QPainterPath()
                    wedge.moveTo(0,0)
                    wedge.arcTo(-100,-100,200,200,start,ang)
                    wedge.closeSubpath()
                    brush = QtGui.QBrush(QtGui.QColor(color_map.get(k,"blue")))
                    path_item = pg.QtWidgets.QGraphicsPathItem(wedge)
                    path_item.setBrush(brush)
                    path_item.setPen(pg.mkPen("black"))
                    scene.addItem(path_item)

                    mid = start+(ang/2)
                    rad = (mid*math.pi)/180
                    xx = 50*math.cos(rad)
                    yy = 50*math.sin(rad)
                    perc = math.floor((ang/360)*100)
                    lab = pg.TextItem(f"{k} ({perc}%)", anchor=(0.5,0.5))
                    lab.setPos(xx,yy)
                    scene.addItem(lab)
                    start+=ang

            self.pie_chart.setAspectLocked(True)

##############################################################################
# AUDIT LOG VIEWER
##############################################################################
class AuditLogViewer(QDialog):
    """
    Shows the last 1000 records from BRM_AUDIT_LOG. 
    Allows searching by Action, Table, or Action By.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Audit Logs")
        self.resize(800,600)

        main_layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by Action, Table, or Action By...")
        self.search_edit.textChanged.connect(self.perform_search)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.audit_table = QTableWidget(0,8)
        self.audit_table.setHorizontalHeaderLabels([
            "Audit ID","Action","Table Name","Record ID","Action By","Old Data","New Data","Timestamp"
        ])
        self.audit_table.horizontalHeader().setStretchLastSection(True)
        self.audit_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.audit_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main_layout.addWidget(self.audit_table)

        ref_btn = QPushButton("Refresh Logs")
        ref_btn.clicked.connect(self.load_logs)
        main_layout.addWidget(ref_btn)

        self.setLayout(main_layout)
        self.load_logs()

    def load_logs(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT AUDIT_ID,ACTION,TABLE_NAME,RECORD_ID,ACTION_BY,OLD_DATA,NEW_DATA,ACTION_TIMESTAMP
          FROM BRM_AUDIT_LOG
          ORDER BY ACTION_TIMESTAMP DESC
          LIMIT 1000
        """)
        rows = c.fetchall()
        self.audit_table.setRowCount(0)
        for row in rows:
            r = self.audit_table.rowCount()
            self.audit_table.insertRow(r)
            self.audit_table.setItem(r,0,QTableWidgetItem(str(row["AUDIT_ID"])))
            self.audit_table.setItem(r,1,QTableWidgetItem(row["ACTION"]))
            self.audit_table.setItem(r,2,QTableWidgetItem(row["TABLE_NAME"]))
            self.audit_table.setItem(r,3,QTableWidgetItem(row["RECORD_ID"]))
            self.audit_table.setItem(r,4,QTableWidgetItem(row["ACTION_BY"]))

            # Old Data
            if row["OLD_DATA"]:
                try:
                    parsed = json.loads(row["OLD_DATA"])
                    txt = json.dumps(parsed,indent=2)
                except:
                    txt = row["OLD_DATA"]
                self.audit_table.setItem(r,5,QTableWidgetItem(txt))
            else:
                self.audit_table.setItem(r,5,QTableWidgetItem(""))

            # New Data
            if row["NEW_DATA"]:
                try:
                    parsed = json.loads(row["NEW_DATA"])
                    txt = json.dumps(parsed,indent=2)
                except:
                    txt = row["NEW_DATA"]
                self.audit_table.setItem(r,6,QTableWidgetItem(txt))
            else:
                self.audit_table.setItem(r,6,QTableWidgetItem(""))

            self.audit_table.setItem(r,7,QTableWidgetItem(str(row["ACTION_TIMESTAMP"])))

    def perform_search(self, text):
        txt_l = text.lower()
        for row in range(self.audit_table.rowCount()):
            match=False
            for col in (1,2,4):  # ACTION, TABLE_NAME, ACTION_BY
                it = self.audit_table.item(row,col)
                if it and txt_l in it.text().lower():
                    match=True
                    break
            self.audit_table.setRowHidden(row, not match)

##############################################################################
# SEARCH RULE DIALOG
##############################################################################
class SearchRuleDialog(QDialog):
    """
    Allows user to search rules by name or SQL snippet.
    """
    def __init__(self, connection, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.user_group = user_group
        self.setWindowTitle("Search Rules")
        self.resize(800,600)

        main_layout = QVBoxLayout(self)
        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Enter name or SQL snippet...")
        self.search_edit.textChanged.connect(self.load_results)
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)
        main_layout.addLayout(top_h)

        self.res_table = QTableWidget(0,6)
        self.res_table.setHorizontalHeaderLabels(["Rule ID","Name","SQL","Status","Version","Created By"])
        self.res_table.horizontalHeader().setStretchLastSection(True)
        self.res_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.res_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main_layout.addWidget(self.res_table)

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_results)
        main_layout.addWidget(ref_btn)
        self.setLayout(main_layout)

        self.load_results()

    def load_results(self):
        c = self.connection.cursor()
        txt = self.search_edit.text().strip()
        if txt:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
              FROM BRM_RULES
              WHERE (RULE_NAME LIKE ? OR RULE_SQL LIKE ?)
              ORDER BY RULE_ID DESC
              LIMIT 1000
            """,(f"%{txt}%", f"%{txt}%"))
        else:
            c.execute("""
              SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,CREATED_BY
              FROM BRM_RULES
              ORDER BY RULE_ID DESC
              LIMIT 1000
            """)
        rows = c.fetchall()
        self.res_table.setRowCount(0)
        for row in rows:
            r = self.res_table.rowCount()
            self.res_table.insertRow(r)
            self.res_table.setItem(r,0,QTableWidgetItem(str(row["RULE_ID"])))
            self.res_table.setItem(r,1,QTableWidgetItem(row["RULE_NAME"]))
            self.res_table.setItem(r,2,QTableWidgetItem(row["RULE_SQL"]))
            self.res_table.setItem(r,3,QTableWidgetItem(row["STATUS"]))
            self.res_table.setItem(r,4,QTableWidgetItem(str(row["VERSION"])))
            self.res_table.setItem(r,5,QTableWidgetItem(row["CREATED_BY"]))

##############################################################################
# RULE DASHBOARD
##############################################################################
class RuleDashboard(QGroupBox):
    """
    Displays a paginated list of rules, with a search box and a status filter.
    Also can run ETL (execute_rules_in_order).
    """
    def __init__(self, connection, user_id, user_group, parent=None):
        super().__init__("Rule Dashboard", parent)
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group
        self.selected_rule_id = None
        self.current_page = 1
        self.records_per_page = 50
        self.total_pages = 1

        main_layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search name or SQL...")
        top_h.addWidget(QLabel("Search:"))
        top_h.addWidget(self.search_edit)

        self.status_filter = QComboBox()
        self.status_filter.addItem("All Statuses", None)
        self.status_filter.addItem("ACTIVE","ACTIVE")
        self.status_filter.addItem("INACTIVE","INACTIVE")
        self.status_filter.addItem("DELETED","DELETED")
        top_h.addWidget(QLabel("Status:"))
        top_h.addWidget(self.status_filter)
        main_layout.addLayout(top_h)

        self.rule_table = QTableWidget(0,8)
        self.rule_table.setHorizontalHeaderLabels([
            "Rule ID","Name","SQL","Status","Version","Owner Group","Created Timestamp","Approval Status"
        ])
        self.rule_table.horizontalHeader().setStretchLastSection(True)
        self.rule_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.rule_table.itemSelectionChanged.connect(self.update_selected_rule_id)
        main_layout.addWidget(self.rule_table)

        nav_h = QHBoxLayout()
        self.prev_btn = QPushButton("Previous")
        self.next_btn = QPushButton("Next")
        self.page_label = QLabel("Page 1/1")
        nav_h.addWidget(self.prev_btn)
        nav_h.addWidget(self.page_label)
        nav_h.addWidget(self.next_btn)
        main_layout.addLayout(nav_h)

        btn_h = QHBoxLayout()
        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_rules)
        btn_h.addWidget(ref_btn)

        run_etl_btn = QPushButton("Run ETL (Execute Rules)")
        run_etl_btn.clicked.connect(self.run_etl)
        btn_h.addWidget(run_etl_btn)

        analytics_btn = QPushButton("Rule Analytics")
        analytics_btn.clicked.connect(self.show_analytics_popup)
        btn_h.addWidget(analytics_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)

        self.setLayout(main_layout)

        self.search_edit.textChanged.connect(self.load_rules)
        self.status_filter.currentIndexChanged.connect(self.load_rules)
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)

        self.load_rules()

    def run_etl(self):
        executed, skipped = execute_rules_in_order(self.connection)
        msg = f"ETL Finished.\nExecuted: {executed}\nSkipped: {list(skipped)}"
        QMessageBox.information(self,"ETL",msg)
        self.load_rules()

    def show_analytics_popup(self):
        dlg = RuleAnalyticsDialog(self.connection, self)
        dlg.exec_()

    def build_filter_query(self):
        f = []
        p = []
        txt = self.search_edit.text().strip()
        if txt:
            f.append("(RULE_NAME LIKE ? OR RULE_SQL LIKE ?)")
            p.extend([f"%{txt}%", f"%{txt}%"])
        st = self.status_filter.currentData()
        if st:
            if st.upper()=="DELETED":
                f.append("RULE_ID IN (SELECT RECORD_ID FROM BRM_AUDIT_LOG WHERE ACTION='DELETE')")
            else:
                f.append("STATUS=?")
                p.append(st)
        clause = " AND ".join(f) if f else "1"
        return clause, p

    def load_rules(self):
        c = self.connection.cursor()
        clause, params = self.build_filter_query()
        c.execute(f"SELECT COUNT(*) as ccount FROM BRM_RULES WHERE {clause}", params)
        rowc = c.fetchone()
        total = rowc["ccount"] if rowc else 0
        self.total_pages = max(1, math.ceil(total/self.records_per_page))
        if self.current_page>self.total_pages:
            self.current_page=self.total_pages
        elif self.current_page<1:
            self.current_page=1
        self.page_label.setText(f"Page {self.current_page}/{self.total_pages}")

        offset = (self.current_page-1)*self.records_per_page
        c.execute(f"""
          SELECT RULE_ID,RULE_NAME,RULE_SQL,STATUS,VERSION,OWNER_GROUP,CREATED_TIMESTAMP,APPROVAL_STATUS
          FROM BRM_RULES
          WHERE {clause}
          ORDER BY RULE_ID DESC
          LIMIT ? OFFSET ?
        """, (*params, self.records_per_page, offset))
        rows = c.fetchall()
        self.rule_table.setRowCount(0)
        for rd in rows:
            r = self.rule_table.rowCount()
            self.rule_table.insertRow(r)
            self.rule_table.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_table.setItem(r,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_table.setItem(r,2,QTableWidgetItem(rd["RULE_SQL"]))

            sitem = QTableWidgetItem(rd["STATUS"])
            if rd["STATUS"].lower()=="active":
                sitem.setBackground(QColor(144,238,144))
            else:
                sitem.setBackground(QColor(255,182,193))
            self.rule_table.setItem(r,3,sitem)

            self.rule_table.setItem(r,4,QTableWidgetItem(str(rd["VERSION"])))
            self.rule_table.setItem(r,5,QTableWidgetItem(rd["OWNER_GROUP"]))
            self.rule_table.setItem(r,6,QTableWidgetItem(str(rd["CREATED_TIMESTAMP"])))
            self.rule_table.setItem(r,7,QTableWidgetItem(rd["APPROVAL_STATUS"]))

    def update_selected_rule_id(self):
        sel = self.rule_table.selectedItems()
        if not sel:
            self.selected_rule_id=None
            return
        row = sel[0].row()
        it = self.rule_table.item(row,0)
        if it:
            self.selected_rule_id = int(it.text())
        else:
            self.selected_rule_id=None

    def get_selected_rule_ids(self):
        idxs = self.rule_table.selectionModel().selectedRows()
        ids_ = []
        for i in idxs:
            row = i.row()
            it = self.rule_table.item(row,0)
            if it:
                ids_.append(int(it.text()))
        return ids_

    def prev_page(self):
        if self.current_page>1:
            self.current_page-=1
            self.load_rules()

    def next_page(self):
        if self.current_page<self.total_pages:
            self.current_page+=1
            self.load_rules()

##############################################################################
# BUSINESS RULE MANAGEMENT TAB
##############################################################################
class BusinessRuleManagementTab(QWidget):
    """
    Provides a dashboard for adding/updating/deactivating/deleting rules,
    plus shortcuts to search or view audit logs.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        main_layout = QVBoxLayout(self)
        btn_h = QHBoxLayout()

        add_btn = QPushButton("Add Rule")
        add_btn.clicked.connect(self.on_add_rule)
        btn_h.addWidget(add_btn)

        upd_btn = QPushButton("Update Rule")
        upd_btn.clicked.connect(self.on_update_rule)
        btn_h.addWidget(upd_btn)

        deact_btn = QPushButton("Deactivate Selected")
        deact_btn.clicked.connect(self.on_deactivate_rules)
        btn_h.addWidget(deact_btn)

        del_btn = QPushButton("Delete Rule")
        del_btn.clicked.connect(self.on_delete_rule)
        btn_h.addWidget(del_btn)

        aud_btn = QPushButton("View Audit Logs")
        aud_btn.clicked.connect(self.main_app.launch_audit_log_viewer)
        btn_h.addWidget(aud_btn)

        srch_btn = QPushButton("Search Rules")
        srch_btn.clicked.connect(self.main_app.launch_search_rule_dialog)
        btn_h.addWidget(srch_btn)

        btn_h.addStretch()
        main_layout.addLayout(btn_h)

        self.rule_dash = RuleDashboard(self.connection, self.user_id, self.user_group)
        main_layout.addWidget(self.rule_dash)

        main_layout.addStretch()
        self.setLayout(main_layout)

    def on_add_rule(self):
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, parent=self)
        if dlg.exec_()==QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_update_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self,"No Selection","Select a rule to update.")
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rid,))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Not Found","No rule with that ID.")
            return
        rule_data = dict(row)
        rtypes = self.main_app.get_rule_types()
        dlg = RuleEditorDialog(self.connection, rtypes, self.user_group, rule_data, self)
        if dlg.exec_()==QDialog.Accepted:
            self.rule_dash.load_rules()

    def on_deactivate_rules(self):
        rids = self.rule_dash.get_selected_rule_ids()
        if not rids:
            QMessageBox.warning(self,"None Selected","No rules selected.")
            return
        success=0
        fails=[]
        for rr in rids:
            try:
                deactivate_rule(self.connection, rr, self.user_group, self.user_group)
                success+=1
            except Exception as e:
                fails.append(f"Rule {rr}: {str(e)}")
        msg = f"Deactivation done. Success={success}"
        if fails:
            msg+= "\nFails:\n"+"\n".join(fails)
        QMessageBox.information(self,"Deactivate", msg)
        self.rule_dash.load_rules()

    def on_delete_rule(self):
        rid = self.rule_dash.selected_rule_id
        if not rid:
            QMessageBox.warning(self,"None Selected","No rule to delete.")
            return
        try:
            delete_rule(self.connection, rid, self.user_group, self.user_group)
            QMessageBox.information(self,"Deleted","Rule deleted.")
            self.rule_dash.load_rules()
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

##############################################################################
# GROUP MANAGEMENT TAB
##############################################################################
class GroupManagementTab(QWidget):
    """
    Lets Admin manage business groups, membership, permissions, and backups.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        if user_group!="Admin":
            lay = QVBoxLayout(self)
            lay.addWidget(QLabel("Access Denied: Only Admin can manage groups."))
            self.setLayout(lay)
            return

        main_layout = QVBoxLayout(self)
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # Groups & membership
        gm_tab = QWidget()
        gm_layout = QVBoxLayout(gm_tab)

        grp_box = QGroupBox("Group Details")
        grp_layout = QVBoxLayout(grp_box)
        self.groups_table = QTableWidget()
        self.groups_table.setColumnCount(3)
        self.groups_table.setHorizontalHeaderLabels(["Group Name","Description","Email"])
        self.groups_table.horizontalHeader().setStretchLastSection(True)
        grp_layout.addWidget(self.groups_table)

        btn_h = QHBoxLayout()
        add_grp_btn = QPushButton("Add Group")
        add_grp_btn.clicked.connect(self.on_add_group)
        btn_h.addWidget(add_grp_btn)

        rename_grp_btn = QPushButton("Rename Group")
        rename_grp_btn.clicked.connect(self.on_rename_group)
        btn_h.addWidget(rename_grp_btn)

        del_grp_btn = QPushButton("Delete Group")
        del_grp_btn.clicked.connect(self.on_delete_group)
        btn_h.addWidget(del_grp_btn)

        backup_grp_btn = QPushButton("Backup Group")
        backup_grp_btn.clicked.connect(self.on_backup_group)
        btn_h.addWidget(backup_grp_btn)

        restore_grp_btn = QPushButton("Restore Group")
        restore_grp_btn.clicked.connect(self.on_restore_group)
        btn_h.addWidget(restore_grp_btn)

        btn_h.addStretch()
        grp_layout.addLayout(btn_h)
        gm_layout.addWidget(grp_box)

        membership_box = QGroupBox("Membership Management")
        membership_layout = QVBoxLayout(membership_box)
        self.users_table = QTableWidget()
        self.users_table.setColumnCount(3)
        self.users_table.setHorizontalHeaderLabels(["User ID","Username","Group"])
        self.users_table.horizontalHeader().setStretchLastSection(True)
        membership_layout.addWidget(self.users_table)

        memb_btn_h = QHBoxLayout()
        add_usr_btn = QPushButton("Add User to Group")
        add_usr_btn.clicked.connect(self.on_add_user_to_group)
        memb_btn_h.addWidget(add_usr_btn)

        rem_usr_btn = QPushButton("Remove User from Group")
        rem_usr_btn.clicked.connect(self.on_remove_user_from_group)
        memb_btn_h.addWidget(rem_usr_btn)

        memb_btn_h.addStretch()
        membership_layout.addLayout(memb_btn_h)
        gm_layout.addWidget(membership_box)

        self.tabs.addTab(gm_tab,"Groups & Membership")

        # Permissions
        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        perm_box = QGroupBox("Group Permissions")
        perm_box_layout = QVBoxLayout(perm_box)

        ptop_h = QHBoxLayout()
        ptop_h.addWidget(QLabel("Select Group:"))
        self.perm_group_combo = QComboBox()
        ptop_h.addWidget(self.perm_group_combo)
        ptop_h.addStretch()
        perm_box_layout.addLayout(ptop_h)

        self.perm_table = QTableWidget()
        self.perm_table.setColumnCount(1)
        self.perm_table.setHorizontalHeaderLabels(["Target Table"])
        self.perm_table.horizontalHeader().setStretchLastSection(True)
        perm_box_layout.addWidget(self.perm_table)

        pbtn_h = QHBoxLayout()
        add_perm_btn = QPushButton("Add Permission")
        add_perm_btn.clicked.connect(self.on_add_permission)
        pbtn_h.addWidget(add_perm_btn)
        rem_perm_btn = QPushButton("Remove Permission")
        rem_perm_btn.clicked.connect(self.on_remove_permission)
        pbtn_h.addWidget(rem_perm_btn)
        pbtn_h.addStretch()
        perm_box_layout.addLayout(pbtn_h)
        perm_layout.addWidget(perm_box)
        self.tabs.addTab(perm_tab,"Group Permissions")

        # Approvers
        appr_tab = QWidget()
        appr_layout = QVBoxLayout(appr_tab)
        ah = QHBoxLayout()
        ah.addWidget(QLabel("Group:"))
        self.appr_group_combo = QComboBox()
        ah.addWidget(self.appr_group_combo)
        ah.addStretch()
        appr_layout.addLayout(ah)

        self.appr_table = QTableWidget(0,2)
        self.appr_table.setHorizontalHeaderLabels(["Approver ID","Username"])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        appr_layout.addWidget(self.appr_table)

        appr_btn_h = QHBoxLayout()
        add_appr_btn = QPushButton("Add Approver")
        add_appr_btn.clicked.connect(self.on_add_approver)
        appr_btn_h.addWidget(add_appr_btn)
        del_appr_btn = QPushButton("Remove Approver")
        del_appr_btn.clicked.connect(self.on_remove_approver)
        appr_btn_h.addWidget(del_appr_btn)
        appr_btn_h.addStretch()
        appr_layout.addLayout(appr_btn_h)

        self.tabs.addTab(appr_tab,"Approvers Management")

        ref_btn = QPushButton("Refresh")
        ref_btn.clicked.connect(self.load_data)
        main_layout.addWidget(ref_btn)
        self.setLayout(main_layout)

        self.load_data()
        self.perm_group_combo.currentIndexChanged.connect(self.load_permissions)
        self.appr_group_combo.currentIndexChanged.connect(self.load_approvers)

    def load_data(self):
        self.load_groups()
        self.load_users()
        self.load_group_combo()
        self.load_appr_group_combo()

    def load_groups(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME,DESCRIPTION,EMAIL FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.groups_table.setRowCount(0)
        for row in rows:
            r = self.groups_table.rowCount()
            self.groups_table.insertRow(r)
            self.groups_table.setItem(r,0,QTableWidgetItem(row["GROUP_NAME"]))
            self.groups_table.setItem(r,1,QTableWidgetItem(row["DESCRIPTION"] or ""))
            self.groups_table.setItem(r,2,QTableWidgetItem(row["EMAIL"] or ""))

    def load_users(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        rows = c.fetchall()
        self.users_table.setRowCount(0)
        for row in rows:
            rr = self.users_table.rowCount()
            self.users_table.insertRow(rr)
            self.users_table.setItem(rr,0,QTableWidgetItem(str(row["USER_ID"])))
            self.users_table.setItem(rr,1,QTableWidgetItem(row["USERNAME"]))
            self.users_table.setItem(rr,2,QTableWidgetItem(row["USER_GROUP"]))

    def load_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.perm_group_combo.clear()
        for r in rows:
            self.perm_group_combo.addItem(r["GROUP_NAME"],r["GROUP_NAME"])

    def load_appr_group_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        rows = c.fetchall()
        self.appr_group_combo.clear()
        for r in rows:
            self.appr_group_combo.addItem(r["GROUP_NAME"],r["GROUP_NAME"])

    def load_permissions(self):
        grp = self.perm_group_combo.currentText().strip()
        c = self.connection.cursor()
        c.execute("SELECT TARGET_TABLE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=?",(grp,))
        rows = c.fetchall()
        self.perm_table.setRowCount(0)
        for row in rows:
            rr = self.perm_table.rowCount()
            self.perm_table.insertRow(rr)
            self.perm_table.setItem(rr,0,QTableWidgetItem(row["TARGET_TABLE"]))

    def load_approvers(self):
        grp = self.appr_group_combo.currentText().strip()
        c = self.connection.cursor()
        c.execute("SELECT APPROVER_ID,USERNAME FROM BUSINESS_GROUP_APPROVERS WHERE GROUP_NAME=?",(grp,))
        rows = c.fetchall()
        self.appr_table.setRowCount(0)
        for row in rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0,QTableWidgetItem(str(row["APPROVER_ID"])))
            self.appr_table.setItem(r,1,QTableWidgetItem(row["USERNAME"]))

    def get_selected_group(self):
        idx = self.groups_table.currentRow()
        if idx<0:
            return None
        it = self.groups_table.item(idx,0)
        if not it:
            return None
        return it.text().strip()

    def on_add_group(self):
        name, ok = QInputDialog.getText(self,"Add Group","Group Name:")
        if not ok or not name.strip():
            return
        desc, ok2 = QInputDialog.getText(self,"Add Group","Description:")
        if not ok2:
            desc=""
        email, ok3 = QInputDialog.getText(self,"Add Group","Email:")
        if not ok3:
            email=""
        name = name.strip()
        if not name:
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(name,))
        if c.fetchone():
            QMessageBox.warning(self,"Error","Group already exists.")
            return
        c.execute("INSERT INTO BUSINESS_GROUPS(GROUP_NAME,DESCRIPTION,EMAIL) VALUES(?,?,?)",
                  (name, desc.strip(), email.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Success","Group added.")
        self.load_data()

    def on_rename_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        new_name, ok = QInputDialog.getText(self,"Rename Group","New group name:")
        if not ok or not new_name.strip():
            return
        new_name = new_name.strip()
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(new_name,))
        if c.fetchone():
            QMessageBox.warning(self,"Error","New group name already exists.")
            return
        try:
            c.execute("BEGIN")
            c.execute("UPDATE BUSINESS_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name,grp))
            c.execute("UPDATE BRM_RULES SET OWNER_GROUP=? WHERE OWNER_GROUP=?",(new_name,grp))
            c.execute("UPDATE BRM_RULE_GROUPS SET GROUP_NAME=? WHERE GROUP_NAME=?",(new_name,grp))
            c.execute("COMMIT")
            add_audit_log(self.connection,"RENAME_GROUP","BUSINESS_GROUPS",grp,"Admin",
                          {"old_group_name":grp},{"new_group_name":new_name})
            QMessageBox.information(self,"Success",f"Group renamed to {new_name}")
            self.load_data()
        except Exception as e:
            c.execute("ROLLBACK")
            QMessageBox.critical(self,"DB Error",str(e))

    def on_delete_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        confirm = QMessageBox.question(self,"Confirm",f"Delete group '{grp}'?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        try:
            c.execute("DELETE FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp,))
            self.connection.commit()
            QMessageBox.information(self,"Success","Group deleted.")
            self.load_data()
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

    ##########################################################################
    # GROUP BACKUP/RESTORE
    ##########################################################################
    def on_backup_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        try:
            ver = backup_group(self.connection, grp, "Admin")
            QMessageBox.information(self,"Backup Created",f"Group {grp} v{ver}")
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

    def on_restore_group(self):
        grp = self.get_selected_group()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        c = self.connection.cursor()
        c.execute("""
          SELECT BACKUP_VERSION,BACKUP_TIMESTAMP
          FROM BRM_GROUP_BACKUPS
          WHERE GROUP_NAME=?
          ORDER BY BACKUP_VERSION DESC
        """,(grp,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self,"No Backups",f"No backups for {grp}")
            return
        items = [f"Version {r['BACKUP_VERSION']} (ts {r['BACKUP_TIMESTAMP']})" for r in rows]
        sel, ok = QInputDialog.getItem(self,"Restore Group","Choose version:", items, 0, False)
        if not ok:
            return
        match = re.search(r"Version\s+(\d+)", sel)
        if not match:
            return
        chosen_ver = int(match.group(1))
        confirm = QMessageBox.question(self,"Restore",f"Restore {grp} to version {chosen_ver}? Overwrites current.")
        if confirm!=QMessageBox.Yes:
            return
        try:
            restore_group(self.connection, grp, chosen_ver, "Admin")
            QMessageBox.information(self,"Restored",f"{grp} => version {chosen_ver}")
            self.load_data()
        except Exception as e:
            QMessageBox.critical(self,"DB Error",str(e))

    ##########################################################################
    # MEMBERSHIP MANAGEMENT
    ##########################################################################
    def get_selected_user(self):
        r = self.users_table.currentRow()
        if r<0:
            return None
        it = self.users_table.item(r,0)
        if not it:
            return None
        try:
            return int(it.text())
        except:
            return None

    def on_add_user_to_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"No selection","No user.")
            return
        grp,ok = QInputDialog.getText(self,"Add to Group","Group name:")
        if not ok or not grp.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT * FROM BUSINESS_GROUPS WHERE GROUP_NAME=?",(grp.strip(),))
        if not c.fetchone():
            QMessageBox.warning(self,"Error","Group not found.")
            return
        c.execute("SELECT * FROM USERS WHERE USER_ID=?",(uid,))
        urow = c.fetchone()
        if not urow:
            QMessageBox.warning(self,"Error","User not found.")
            return
        if urow["USER_GROUP"]==grp.strip():
            QMessageBox.warning(self,"Error","User already in that group.")
            return
        c.execute("UPDATE USERS SET USER_GROUP=? WHERE USER_ID=?",(grp.strip(),uid))
        self.connection.commit()
        QMessageBox.information(self,"Success","User added to group.")
        self.load_data()

    def on_remove_user_from_group(self):
        uid = self.get_selected_user()
        if not uid:
            QMessageBox.warning(self,"No selection","No user selected.")
            return
        confirm = QMessageBox.question(self,"Confirm","Remove user from group?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        # Example logic: move user to BG1, or handle differently
        c.execute("UPDATE USERS SET USER_GROUP='BG1' WHERE USER_ID=?",(uid,))
        self.connection.commit()
        QMessageBox.information(self,"Success","User moved to BG1.")
        self.load_data()

    ##########################################################################
    # PERMISSIONS
    ##########################################################################
    def on_add_permission(self):
        grp = self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group.")
            return
        tbl,ok = QInputDialog.getText(self,"Add Permission","Target table:")
        if not ok or not tbl.strip():
            return
        c = self.connection.cursor()
        c.execute("""
          INSERT OR IGNORE INTO GROUP_PERMISSIONS(GROUP_NAME,TARGET_TABLE) VALUES(?,?)
        """,(grp,tbl.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Permission {tbl} added to {grp}")
        self.load_permissions()

    def on_remove_permission(self):
        grp = self.perm_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group.")
            return
        r = self.perm_table.currentRow()
        if r<0:
            QMessageBox.warning(self,"No selection","No permission row.")
            return
        it = self.perm_table.item(r,0)
        if not it:
            QMessageBox.warning(self,"No selection","No table name found.")
            return
        tbl = it.text().strip()
        confirm = QMessageBox.question(self,"Confirm",f"Remove {tbl} from {grp}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM GROUP_PERMISSIONS WHERE GROUP_NAME=? AND TARGET_TABLE=?",(grp,tbl))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Permission {tbl} removed from {grp}.")
        self.load_permissions()

    ##########################################################################
    # APPROVERS
    ##########################################################################
    def on_add_approver(self):
        grp = self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group selected.")
            return
        username, ok = QInputDialog.getText(self,"Add Approver","Enter username:")
        if not ok or not username.strip():
            return
        c = self.connection.cursor()
        c.execute("SELECT USER_ID FROM USERS WHERE USERNAME=?",(username.strip(),))
        row = c.fetchone()
        if not row:
            QMessageBox.warning(self,"Error","User not found.")
            return
        c.execute("""
          INSERT OR IGNORE INTO BUSINESS_GROUP_APPROVERS(GROUP_NAME,USERNAME) VALUES(?,?)
        """,(grp, username.strip()))
        self.connection.commit()
        QMessageBox.information(self,"Approver Added",f"{username} => {grp}")
        self.load_approvers()

    def on_remove_approver(self):
        grp = self.appr_group_combo.currentText().strip()
        if not grp:
            QMessageBox.warning(self,"No selection","No group.")
            return
        row = self.appr_table.currentRow()
        if row<0:
            QMessageBox.warning(self,"No selection","No approver row.")
            return
        it = self.appr_table.item(row,0)
        if not it:
            return
        appr_id = it.text().strip()
        confirm = QMessageBox.question(self,"Confirm",f"Remove Approver {appr_id}?")
        if confirm!=QMessageBox.Yes:
            return
        c = self.connection.cursor()
        c.execute("DELETE FROM BUSINESS_GROUP_APPROVERS WHERE APPROVER_ID=?",(appr_id,))
        self.connection.commit()
        QMessageBox.information(self,"Success","Approver removed.")
        self.load_approvers()

##############################################################################
# BACKUP & RESTORE GROUP HELPERS
##############################################################################
def backup_group(conn, group_name, action_by="System"):
    """
    Backs up all rules belonging to the group into BRM_GROUP_BACKUPS.
    """
    c = conn.cursor()
    c.execute("SELECT * FROM BRM_RULES WHERE OWNER_GROUP=?",(group_name,))
    rules = c.fetchall()
    backup_data = {"rules":[]}
    for rule in rules:
        rdict = dict(rule)
        rid = rule["RULE_ID"]
        c.execute("SELECT * FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        rdict["dependencies"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_RULE_LINEAGE WHERE RULE_ID=?",(rid,))
        rdict["lineage"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?",(rid,))
        rdict["column_mappings"] = [dict(x) for x in c.fetchall()]
        backup_data["rules"].append(rdict)
    js = json.dumps(backup_data, default=str)
    c.execute("SELECT COALESCE(MAX(BACKUP_VERSION),0) as mv FROM BRM_GROUP_BACKUPS WHERE GROUP_NAME=?",(group_name,))
    row = c.fetchone()
    nextv = row["mv"]+1
    c.execute("""
      INSERT INTO BRM_GROUP_BACKUPS(GROUP_NAME,BACKUP_VERSION,BACKUP_JSON)
      VALUES(?,?,?)
    """,(group_name,nextv,js))
    conn.commit()
    add_audit_log(conn,"BACKUP","BRM_GROUP_BACKUPS",group_name,action_by,
                  {"group":group_name},{"version":nextv})
    return nextv

def restore_group(conn, group_name, backup_version, action_by="System"):
    """
    Restores the groups rules from a prior backup version.
    """
    c = conn.cursor()
    c.execute("""
      SELECT BACKUP_JSON
      FROM BRM_GROUP_BACKUPS
      WHERE GROUP_NAME=? AND BACKUP_VERSION=?
    """,(group_name,backup_version))
    row = c.fetchone()
    if not row:
        raise ValueError(f"No backup for {group_name} v{backup_version}")
    backup_data = json.loads(row["BACKUP_JSON"])

    # Wipe out existing rules for that group
    c.execute("""
      DELETE FROM BRM_RULE_LINEAGE
      WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)
    """,(group_name,))
    c.execute("""
      DELETE FROM BRM_RULE_TABLE_DEPENDENCIES
      WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)
    """,(group_name,))
    c.execute("""
      DELETE FROM BRM_COLUMN_MAPPING
      WHERE RULE_ID IN (SELECT RULE_ID FROM BRM_RULES WHERE OWNER_GROUP=?)
    """,(group_name,))
    c.execute("DELETE FROM BRM_RULES WHERE OWNER_GROUP=?",(group_name,))

    # Insert from backup
    for rdict in backup_data["rules"]:
        c.execute("""
          INSERT INTO BRM_RULES(
            RULE_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
            EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
            CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
            CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,GROUP_ID,
            APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE
          ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
        """,(
          rdict["RULE_ID"], rdict["PARENT_RULE_ID"], rdict["RULE_TYPE_ID"],
          rdict["RULE_NAME"], rdict["RULE_SQL"], rdict["EFFECTIVE_START_DATE"],
          rdict["EFFECTIVE_END_DATE"], rdict["STATUS"], rdict["VERSION"],
          rdict["CREATED_BY"], rdict["DESCRIPTION"], rdict["OPERATION_TYPE"],
          rdict["BUSINESS_JUSTIFICATION"], rdict["CREATED_TIMESTAMP"],
          rdict["UPDATED_BY"], rdict["OWNER_GROUP"], rdict.get("CLUSTER_NAME",""),
          rdict.get("GROUP_ID",None), rdict.get("APPROVAL_STATUS","DRAFT"),
          rdict.get("IS_GLOBAL",0), rdict.get("CRITICAL_RULE",0),
          rdict.get("CRITICAL_SCOPE","NONE")
        ))
        rid = rdict["RULE_ID"]
        for d in rdict.get("dependencies",[]):
            c.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(d["DEPENDENCY_ID"], rid, d["DATABASE_NAME"], d["TABLE_NAME"], d["COLUMN_NAME"]))
        for l in rdict.get("lineage",[]):
            c.execute("""
              INSERT INTO BRM_RULE_LINEAGE(
                LINEAGE_ID,RULE_ID,SOURCE_INFO,TARGET_INFO,TRANSFORMATION_DETAILS,CREATED_TIMESTAMP
              ) VALUES(?,?,?,?,?,?)
            """,(l["LINEAGE_ID"], rid, l["SOURCE_INFO"], l["TARGET_INFO"],
                 l["TRANSFORMATION_DETAILS"], l["CREATED_TIMESTAMP"]))
        for m in rdict.get("column_mappings",[]):
            c.execute("""
              INSERT INTO BRM_COLUMN_MAPPING(
                MAPPING_ID,RULE_ID,SOURCE_RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(m["MAPPING_ID"], m["RULE_ID"], m["SOURCE_RULE_ID"],
                 m["SOURCE_COLUMN_NAME"], m["TARGET_COLUMN_NAME"]))
    conn.commit()
    add_audit_log(conn,"RESTORE","BRM_RULES",group_name,action_by,
                  {"group":group_name,"version":backup_version},None)

##############################################################################
# CUSTOM RULE GROUP TAB
##############################################################################
def backup_custom_group(conn, custom_group_id, action_by="System"):
    """
    Backup the custom group membership rules into BRM_CUSTOM_GROUP_BACKUPS.
    """
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)
    c = conn.cursor()
    c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
    rowg = c.fetchone()
    if not rowg:
        raise ValueError("Custom group ID not found.")

    c.execute("""
      SELECT R.*
      FROM BRM_CUSTOM_GROUP_MEMBERS M
      JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
      WHERE M.CUSTOM_GROUP_ID=?
    """,(custom_group_id,))
    rules = c.fetchall()
    backup_data = {"rules":[]}
    for rule in rules:
        rd = dict(rule)
        rid = rule["RULE_ID"]
        c.execute("SELECT * FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID=?",(rid,))
        rd["dependencies"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_RULE_LINEAGE WHERE RULE_ID=?",(rid,))
        rd["lineage"] = [dict(x) for x in c.fetchall()]
        c.execute("SELECT * FROM BRM_COLUMN_MAPPING WHERE RULE_ID=?",(rid,))
        rd["column_mappings"] = [dict(x) for x in c.fetchall()]
        backup_data["rules"].append(rd)

    c.execute("""
      SELECT COALESCE(MAX(BACKUP_VERSION),0) as mv
      FROM BRM_CUSTOM_GROUP_BACKUPS
      WHERE CUSTOM_GROUP_ID=?
    """,(custom_group_id,))
    row = c.fetchone()
    nextv = row["mv"]+1
    js = json.dumps(backup_data, default=str)
    c.execute("""
      INSERT INTO BRM_CUSTOM_GROUP_BACKUPS(CUSTOM_GROUP_ID,BACKUP_VERSION,BACKUP_JSON)
      VALUES(?,?,?)
    """,(custom_group_id,nextv,js))
    conn.commit()
    add_audit_log(conn,"BACKUP_CUSTOM_GROUP","BRM_CUSTOM_GROUP_BACKUPS",
                  custom_group_id,action_by,
                  {"cgid":custom_group_id},{"version":nextv})
    return nextv

def restore_custom_group(conn, custom_group_id, backup_version, action_by="System"):
    """
    Restore the custom group membership from a prior backup version.
    """
    conn.execute("""
    CREATE TABLE IF NOT EXISTS BRM_CUSTOM_GROUP_BACKUPS(
        BACKUP_ID INTEGER PRIMARY KEY AUTOINCREMENT,
        CUSTOM_GROUP_ID INTEGER NOT NULL,
        BACKUP_TIMESTAMP DATETIME DEFAULT CURRENT_TIMESTAMP,
        BACKUP_VERSION INTEGER NOT NULL,
        BACKUP_JSON TEXT NOT NULL,
        FOREIGN KEY(CUSTOM_GROUP_ID) REFERENCES BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_ID) ON DELETE CASCADE
    );
    """)
    c = conn.cursor()
    c.execute("SELECT CUSTOM_GROUP_NAME FROM BRM_CUSTOM_RULE_GROUPS WHERE CUSTOM_GROUP_ID=?",(custom_group_id,))
    rowg = c.fetchone()
    if not rowg:
        raise ValueError("Custom group not found.")

    c.execute("""
      SELECT BACKUP_JSON
      FROM BRM_CUSTOM_GROUP_BACKUPS
      WHERE CUSTOM_GROUP_ID=? AND BACKUP_VERSION=?
    """,(custom_group_id, backup_version))
    rowb = c.fetchone()
    if not rowb:
        raise ValueError("No backup found.")

    backup_data = json.loads(rowb["BACKUP_JSON"])
    c.execute("""
      SELECT RULE_ID
      FROM BRM_CUSTOM_GROUP_MEMBERS
      WHERE CUSTOM_GROUP_ID=?
    """,(custom_group_id,))
    mem_ids = [r["RULE_ID"] for r in c.fetchall()]
    if mem_ids:
        placeholders = ",".join(["?"]*len(mem_ids))
        c.execute(f"DELETE FROM BRM_RULE_LINEAGE WHERE RULE_ID IN ({placeholders})", mem_ids)
        c.execute(f"DELETE FROM BRM_RULE_TABLE_DEPENDENCIES WHERE RULE_ID IN ({placeholders})", mem_ids)
        c.execute(f"DELETE FROM BRM_COLUMN_MAPPING WHERE RULE_ID IN ({placeholders})", mem_ids)
        c.execute(f"DELETE FROM BRM_RULES WHERE RULE_ID IN ({placeholders})", mem_ids)

    # Insert from backup
    for rd in backup_data["rules"]:
        c.execute("""
          INSERT INTO BRM_RULES(
            RULE_ID,PARENT_RULE_ID,RULE_TYPE_ID,RULE_NAME,RULE_SQL,
            EFFECTIVE_START_DATE,EFFECTIVE_END_DATE,STATUS,VERSION,
            CREATED_BY,DESCRIPTION,OPERATION_TYPE,BUSINESS_JUSTIFICATION,
            CREATED_TIMESTAMP,UPDATED_BY,OWNER_GROUP,CLUSTER_NAME,GROUP_ID,
            APPROVAL_STATUS,IS_GLOBAL,CRITICAL_RULE,CRITICAL_SCOPE
          ) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
        """,(
          rd["RULE_ID"], rd["PARENT_RULE_ID"], rd["RULE_TYPE_ID"], rd["RULE_NAME"], rd["RULE_SQL"],
          rd["EFFECTIVE_START_DATE"], rd["EFFECTIVE_END_DATE"], rd["STATUS"], rd["VERSION"],
          rd["CREATED_BY"], rd["DESCRIPTION"], rd["OPERATION_TYPE"], rd["BUSINESS_JUSTIFICATION"],
          rd["CREATED_TIMESTAMP"], rd["UPDATED_BY"], rd["OWNER_GROUP"], rd.get("CLUSTER_NAME",""),
          rd.get("GROUP_ID",None), rd.get("APPROVAL_STATUS","DRAFT"),
          rd.get("IS_GLOBAL",0), rd.get("CRITICAL_RULE",0),
          rd.get("CRITICAL_SCOPE","NONE")
        ))
        rid = rd["RULE_ID"]
        for d in rd.get("dependencies",[]):
            c.execute("""
              INSERT INTO BRM_RULE_TABLE_DEPENDENCIES(
                DEPENDENCY_ID,RULE_ID,DATABASE_NAME,TABLE_NAME,COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(d["DEPENDENCY_ID"],rid,d["DATABASE_NAME"],d["TABLE_NAME"],d["COLUMN_NAME"]))
        for l in rd.get("lineage",[]):
            c.execute("""
              INSERT INTO BRM_RULE_LINEAGE(
                LINEAGE_ID,RULE_ID,SOURCE_INFO,TARGET_INFO,TRANSFORMATION_DETAILS,CREATED_TIMESTAMP
              ) VALUES(?,?,?,?,?,?)
            """,(l["LINEAGE_ID"],rid,l["SOURCE_INFO"],l["TARGET_INFO"],
                 l["TRANSFORMATION_DETAILS"],l["CREATED_TIMESTAMP"]))
        for m in rd.get("column_mappings",[]):
            c.execute("""
              INSERT INTO BRM_COLUMN_MAPPING(
                MAPPING_ID,RULE_ID,SOURCE_RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
              ) VALUES(?,?,?,?,?)
            """,(m["MAPPING_ID"], m["RULE_ID"], m["SOURCE_RULE_ID"],
                 m["SOURCE_COLUMN_NAME"], m["TARGET_COLUMN_NAME"]))
        c.execute("""
          INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
          VALUES(?,?)
        """,(custom_group_id, rid))
    conn.commit()
    add_audit_log(conn,"RESTORE_CUSTOM_GROUP","BRM_CUSTOM_RULE_GROUPS",
                  custom_group_id,action_by,
                  {"cgid":custom_group_id,"version":backup_version},None)

class CustomRuleGroupTab(QWidget):
    """
    Lets user create custom rule groups and manage membership.
    Supports backups/restores for the custom groups membership rules.
    """
    def __init__(self, main_app, connection, user_id, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_id = user_id
        self.user_group = user_group

        main_layout = QVBoxLayout(self)

        top_h = QHBoxLayout()
        self.new_group_name_edit = QLineEdit()
        self.new_group_name_edit.setPlaceholderText("Custom Group Name")
        top_h.addWidget(self.new_group_name_edit)
        create_btn = QPushButton("Create Custom Group")
        create_btn.clicked.connect(self.create_custom_group)
        top_h.addWidget(create_btn)
        main_layout.addLayout(top_h)

        self.custom_group_table = QTableWidget()
        self.custom_group_table.setColumnCount(3)
        self.custom_group_table.setHorizontalHeaderLabels(["Group ID","Group Name","Owner BG"])
        self.custom_group_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.custom_group_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.custom_group_table.itemSelectionChanged.connect(self.on_custom_group_selected)
        main_layout.addWidget(self.custom_group_table)

        splitter = QSplitter()
        splitter.setOrientation(Qt.Horizontal)

        self.rule_list = QTableWidget(0,3)
        self.rule_list.setHorizontalHeaderLabels(["Rule ID","Name","Owner BG"])
        self.rule_list.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.rule_list.setEditTriggers(QAbstractItemView.NoEditTriggers)

        middle_v = QVBoxLayout()
        self.add_rule_btn = QPushButton("Add Rule ")
        self.add_rule_btn.clicked.connect(self.add_rule_to_custom_group)
        self.remove_rule_btn = QPushButton(" Remove Rule")
        self.remove_rule_btn.clicked.connect(self.remove_rule_from_custom_group)
        middle_v.addWidget(self.add_rule_btn)
        middle_v.addWidget(self.remove_rule_btn)
        middle_v.addStretch()
        mid_widget = QWidget()
        mid_widget.setLayout(middle_v)

        self.group_members_view = QTableWidget(0,3)
        self.group_members_view.setHorizontalHeaderLabels(["Rule ID","Name","Owner BG"])
        self.group_members_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.group_members_view.setEditTriggers(QAbstractItemView.NoEditTriggers)

        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.addWidget(self.rule_list)

        splitter.addWidget(left_widget)
        splitter.addWidget(mid_widget)

        right_widget = QWidget()
        rw_layout = QVBoxLayout(right_widget)
        rw_layout.addWidget(self.group_members_view)
        splitter.addWidget(right_widget)

        main_layout.addWidget(splitter)

        btm_h = QHBoxLayout()
        backup_btn = QPushButton("Backup Custom Group")
        backup_btn.clicked.connect(self.backup_selected_group)
        restore_btn = QPushButton("Restore Custom Group")
        restore_btn.clicked.connect(self.restore_selected_group)
        btm_h.addWidget(backup_btn)
        btm_h.addWidget(restore_btn)
        btm_h.addStretch()
        main_layout.addLayout(btm_h)

        self.setLayout(main_layout)

        self.load_custom_groups()
        self.load_all_rules()

    def create_custom_group(self):
        gname = self.new_group_name_edit.text().strip()
        if not gname:
            QMessageBox.warning(self,"Error","No name.")
            return
        c = self.connection.cursor()
        c.execute("""
          INSERT INTO BRM_CUSTOM_RULE_GROUPS(CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP,CREATED_BY)
          VALUES(?,?,?)
        """,(gname, self.user_group, f"UserID:{self.user_id}"))
        self.connection.commit()
        QMessageBox.information(self,"Success",f"Created custom group {gname}.")
        self.new_group_name_edit.clear()
        self.load_custom_groups()

    def load_custom_groups(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT CUSTOM_GROUP_ID,CUSTOM_GROUP_NAME,OWNER_BUSINESS_GROUP
          FROM BRM_CUSTOM_RULE_GROUPS
          ORDER BY CUSTOM_GROUP_ID DESC
        """)
        rows = c.fetchall()
        self.custom_group_table.setRowCount(0)
        for row in rows:
            r = self.custom_group_table.rowCount()
            self.custom_group_table.insertRow(r)
            self.custom_group_table.setItem(r,0,QTableWidgetItem(str(row["CUSTOM_GROUP_ID"])))
            self.custom_group_table.setItem(r,1,QTableWidgetItem(row["CUSTOM_GROUP_NAME"]))
            self.custom_group_table.setItem(r,2,QTableWidgetItem(row["OWNER_BUSINESS_GROUP"]))

    def load_all_rules(self):
        c = self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME,OWNER_GROUP
          FROM BRM_RULES
          ORDER BY RULE_ID DESC
        """)
        rows = c.fetchall()
        self.rule_list.setRowCount(0)
        for rd in rows:
            r = self.rule_list.rowCount()
            self.rule_list.insertRow(r)
            self.rule_list.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.rule_list.setItem(r,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.rule_list.setItem(r,2,QTableWidgetItem(rd["OWNER_GROUP"]))

    def on_custom_group_selected(self):
        sel = self.custom_group_table.selectedItems()
        if not sel:
            self.group_members_view.setRowCount(0)
            return
        row = sel[0].row()
        it = self.custom_group_table.item(row,0)
        if not it:
            self.group_members_view.setRowCount(0)
            return
        cgid = int(it.text())
        self.load_custom_group_members(cgid)

    def load_custom_group_members(self, cgid):
        c = self.connection.cursor()
        c.execute("""
          SELECT R.RULE_ID,R.RULE_NAME,R.OWNER_GROUP
          FROM BRM_CUSTOM_GROUP_MEMBERS M
          JOIN BRM_RULES R ON M.RULE_ID=R.RULE_ID
          WHERE M.CUSTOM_GROUP_ID=?
          ORDER BY R.RULE_ID
        """,(cgid,))
        rows = c.fetchall()
        self.group_members_view.setRowCount(0)
        for rd in rows:
            r = self.group_members_view.rowCount()
            self.group_members_view.insertRow(r)
            self.group_members_view.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.group_members_view.setItem(r,1,QTableWidgetItem(rd["RULE_NAME"]))
            self.group_members_view.setItem(r,2,QTableWidgetItem(rd["OWNER_GROUP"]))

    def get_selected_custom_group_id(self):
        sel = self.custom_group_table.selectedItems()
        if not sel:
            return None
        row = sel[0].row()
        it = self.custom_group_table.item(row,0)
        if not it:
            return None
        return int(it.text())

    def add_rule_to_custom_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        sel_rows = self.rule_list.selectionModel().selectedRows()
        if not sel_rows:
            QMessageBox.warning(self,"No Selection","No rule selected in 'All Rules'.")
            return
        c = self.connection.cursor()
        added_count=0
        for sr in sel_rows:
            row = sr.row()
            it = self.rule_list.item(row,0)
            if not it:
                continue
            rid = int(it.text())
            try:
                c.execute("""
                  INSERT OR IGNORE INTO BRM_CUSTOM_GROUP_MEMBERS(CUSTOM_GROUP_ID,RULE_ID)
                  VALUES(?,?)
                """,(cgid, rid))
                added_count+=1
            except Exception as e:
                logger.error(str(e))
        self.connection.commit()
        QMessageBox.information(self,"Added",f"{added_count} rule(s) added.")
        self.load_custom_group_members(cgid)

    def remove_rule_from_custom_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        sel_rows = self.group_members_view.selectionModel().selectedRows()
        if not sel_rows:
            QMessageBox.warning(self,"No Selection","No rule in membership.")
            return
        c = self.connection.cursor()
        removed=0
        for sr in sel_rows:
            row = sr.row()
            it = self.group_members_view.item(row,0)
            if not it:
                continue
            rid = int(it.text())
            try:
                c.execute("""
                  DELETE FROM BRM_CUSTOM_GROUP_MEMBERS
                  WHERE CUSTOM_GROUP_ID=? AND RULE_ID=?
                """,(cgid, rid))
                removed+=1
            except Exception as e:
                logger.error(str(e))
        self.connection.commit()
        QMessageBox.information(self,"Removed",f"{removed} rule(s) removed.")
        self.load_custom_group_members(cgid)

    def backup_selected_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        try:
            ver = backup_custom_group(self.connection, cgid, f"User:{self.user_id}")
            QMessageBox.information(self,"Backup",f"Custom group backup version {ver} created.")
        except Exception as e:
            QMessageBox.critical(self,"Error",str(e))

    def restore_selected_group(self):
        cgid = self.get_selected_custom_group_id()
        if not cgid:
            QMessageBox.warning(self,"No Selection","No custom group.")
            return
        c = self.connection.cursor()
        c.execute("""
          SELECT BACKUP_VERSION,BACKUP_TIMESTAMP
          FROM BRM_CUSTOM_GROUP_BACKUPS
          WHERE CUSTOM_GROUP_ID=?
          ORDER BY BACKUP_VERSION DESC
        """,(cgid,))
        rows = c.fetchall()
        if not rows:
            QMessageBox.information(self,"No Backups",f"No backups for custom group {cgid}")
            return
        items = [f"Version {r['BACKUP_VERSION']} (ts {r['BACKUP_TIMESTAMP']})" for r in rows]
        sel,ok = QInputDialog.getItem(self,"Restore","Pick version:", items,0,False)
        if not ok:
            return
        m = re.search(r"Version\s+(\d+)", sel)
        if not m:
            return
        ver = int(m.group(1))
        confirm = QMessageBox.question(self,"Restore",
            f"Restore custom group {cgid} to version {ver}? Overwrites membership rules.")
        if confirm!=QMessageBox.Yes:
            return
        try:
            restore_custom_group(self.connection, cgid, ver, f"User:{self.user_id}")
            QMessageBox.information(self,"Restored",f"Custom group {cgid} => version {ver}")
            self.load_custom_group_members(cgid)
        except Exception as e:
            QMessageBox.critical(self,"Error",str(e))

##############################################################################
# APPROVAL PIPELINE WIDGET
##############################################################################
class ApprovalPipelineWidget(QWidget):
    """
    Shows a horizontal pipeline of circles for BG1 -> BG2 -> BG3 -> FINAL,
    coloring each stage based on Approved=Green, Pending=Yellow, Rejected=Red,
    or NotStarted=Gray.
    """
    def __init__(self, stage_status_map, parent=None):
        super().__init__(parent)
        self.setLayout(QHBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(5)

        stages = ["BG1","BG2","BG3","FINAL"]
        for st in stages:
            circle = QLabel()
            circle.setFixedSize(20,20)
            circle.setStyleSheet("border-radius:10px;border:1px solid black;")
            status = stage_status_map.get(st,"NotStarted")
            if status=="Approved":
                circle.setStyleSheet("background-color:green;border-radius:10px;border:1px solid black;")
            elif status=="Pending":
                circle.setStyleSheet("background-color:yellow;border-radius:10px;border:1px solid black;")
            elif status=="Rejected":
                circle.setStyleSheet("background-color:red;border-radius:10px;border:1px solid black;")
            else:
                circle.setStyleSheet("background-color:lightgray;border-radius:10px;border:1px solid black;")

            circle.setToolTip(f"{st}: {status}")
            self.layout().addWidget(circle)

##############################################################################
# MULTI-STEP APPROVAL TAB
##############################################################################
class MultiStepApprovalTab(QWidget):
    """
    Shows rules that still require the logged-in user's approval (lowest stage).
    Clicking "Approve" marks them as approved; once all stages are done, 
    the rule is set to APPROVED/ACTIVE.
    """
    def __init__(self, connection, logged_in_username, user_group, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.logged_in_username = logged_in_username
        self.user_group = user_group

        main_layout = QVBoxLayout(self)
        self.appr_table = QTableWidget(0,7)
        self.appr_table.setHorizontalHeaderLabels([
            "Rule ID","Group Name","Rule Name","Stage","Approved?","Action","Pipeline"
        ])
        self.appr_table.horizontalHeader().setStretchLastSection(True)
        self.appr_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.appr_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        main_layout.addWidget(self.appr_table)

        ref_btn = QPushButton("Refresh Approvals")
        ref_btn.clicked.connect(self.load_approvals)
        main_layout.addWidget(ref_btn)

        self.setLayout(main_layout)

        self.load_approvals()

    def load_approvals(self):
        c = self.connection.cursor()
        c.execute("""
        SELECT A.RULE_ID,A.GROUP_NAME,A.USERNAME,A.APPROVED_FLAG,A.APPROVED_TIMESTAMP,A.APPROVAL_STAGE,
               R.RULE_NAME,R.APPROVAL_STATUS
        FROM BRM_RULE_APPROVALS A
        JOIN BRM_RULES R ON A.RULE_ID=R.RULE_ID
        WHERE A.USERNAME=? AND A.APPROVED_FLAG=0
        ORDER BY A.RULE_ID
        """,(self.logged_in_username,))
        rows = c.fetchall()

        # Build pipeline data
        pipeline_data = {}
        all_app = self.connection.cursor()
        all_app.execute("SELECT * FROM BRM_RULE_APPROVALS")
        all_rows = all_app.fetchall()
        for apr in all_rows:
            rid = apr["RULE_ID"]
            grp = apr["GROUP_NAME"]
            stage = apr["APPROVAL_STAGE"]
            flag = apr["APPROVED_FLAG"]
            pipeline_data.setdefault(rid, {"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})
            if flag==1:
                pipeline_data[rid][grp] = "Approved"
            else:
                cur_st = get_current_approval_stage(self.connection, rid)
                if cur_st==stage:
                    pipeline_data[rid][grp] = "Pending"
                else:
                    pipeline_data[rid][grp] = "NotStarted"

        # filter to minimal stage for each rule
        minimal_rows = []
        for rd in rows:
            rid = rd["RULE_ID"]
            st = rd["APPROVAL_STAGE"]
            min_st = get_current_approval_stage(self.connection, rid)
            if min_st==st:
                minimal_rows.append(rd)

        self.appr_table.setRowCount(0)
        for rd in minimal_rows:
            r = self.appr_table.rowCount()
            self.appr_table.insertRow(r)
            self.appr_table.setItem(r,0,QTableWidgetItem(str(rd["RULE_ID"])))
            self.appr_table.setItem(r,1,QTableWidgetItem(rd["GROUP_NAME"]))
            self.appr_table.setItem(r,2,QTableWidgetItem(rd["RULE_NAME"]))
            self.appr_table.setItem(r,3,QTableWidgetItem(str(rd["APPROVAL_STAGE"])))
            self.appr_table.setItem(r,4,QTableWidgetItem(str(rd["APPROVED_FLAG"])))

            approve_btn = QPushButton("Approve")
            approve_btn.clicked.connect(lambda _, row_index=r: self.do_approve(row_index))
            self.appr_table.setCellWidget(r,5,approve_btn)

            pipe_map = pipeline_data.get(rd["RULE_ID"],{"BG1":"NotStarted","BG2":"NotStarted","BG3":"NotStarted","FINAL":"NotStarted"})
            pipe_widget = ApprovalPipelineWidget(pipe_map)
            self.appr_table.setCellWidget(r,6,pipe_widget)

    def do_approve(self, row_index):
        rid_item = self.appr_table.item(row_index,0)
        grp_item = self.appr_table.item(row_index,1)
        if not rid_item or not grp_item:
            return
        rule_id = int(rid_item.text())
        group_name = grp_item.text()

        c = self.connection.cursor()
        c.execute("""
          UPDATE BRM_RULE_APPROVALS
          SET APPROVED_FLAG=1, APPROVED_TIMESTAMP=CURRENT_TIMESTAMP
          WHERE RULE_ID=? AND GROUP_NAME=? AND USERNAME=?
        """,(rule_id, group_name, self.logged_in_username))

        nxt = get_current_approval_stage(self.connection, rule_id)
        if nxt is None:
            c.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS='APPROVED', STATUS='ACTIVE'
              WHERE RULE_ID=?
            """,(rule_id,))
        else:
            c.execute("""
              UPDATE BRM_RULES
              SET APPROVAL_STATUS='APPROVAL_IN_PROGRESS', STATUS='INACTIVE'
              WHERE RULE_ID=?
            """,(rule_id,))

        self.connection.commit()
        QMessageBox.information(self,"Approved",f"You approved rule {rule_id}.")
        self.load_approvals()

##############################################################################
# LINEAGE GRAPH VISUALIZATION
##############################################################################
class RuleRectItem(QtWidgets.QGraphicsRectItem):
    def __init__(self, x,y,w,h, rule_data, cluster_name="", parent=None):
        super().__init__(x,y,w,h,parent)
        self.rule_data = rule_data
        self.cluster_name = cluster_name
        self.highlighted=False

    def setHighlight(self, highlight):
        self.highlighted=highlight
        if highlight:
            self.setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
        else:
            self.setPen(QtGui.QPen(QtCore.Qt.black,2))

class RuleEllipseItem(QtWidgets.QGraphicsEllipseItem):
    def __init__(self, x,y,w,h, rule_data, cluster_name="", parent=None):
        super().__init__(x,y,w,h,parent)
        self.rule_data = rule_data
        self.cluster_name = cluster_name
        self.highlighted=False

    def setHighlight(self, highlight):
        self.highlighted=highlight
        if highlight:
            self.setPen(QtGui.QPen(QtGui.QColor("yellow"),4))
        else:
            self.setPen(QtGui.QPen(QtCore.Qt.black,2))

class EnhancedLineageGraphWidget(QtWidgets.QGraphicsView):
    """
    Displays a BFS-based lineage graph of all rules. 
    DQ rules => Rectangle, DM rules => Ellipse, color-coded by status, etc.
    Right-click context menu for highlight ancestors/descendants or edit rule.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        self.scene = QtWidgets.QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QtGui.QPainter.Antialiasing)
        self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)

        self.node_map={}
        self.children_map={}
        self.parents_map={}

        # Minimap not strictly necessary, but shown in code
        self.minimap = QtWidgets.QGraphicsView(self.scene)
        self.minimap.setRenderHint(QtGui.QPainter.Antialiasing)
        self.minimap.setFixedSize(200,150)
        self.minimap.setStyleSheet("background:rgba(255,255,255,0.7);border:1px solid gray;")
        self.minimap.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.minimap.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)

        self.detail_dock = QDockWidget("Rule Details", self.parentWidget())
        self.detail_panel = QTextEdit()
        self.detail_panel.setReadOnly(True)
        self.detail_dock.setWidget(self.detail_panel)
        self.detail_dock.setAllowedAreas(Qt.LeftDockWidgetArea|Qt.RightDockWidgetArea)
        mw = self.find_main_window()
        if mw:
            mw.addDockWidget(Qt.RightDockWidgetArea, self.detail_dock)

        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def find_main_window(self):
        w = self.parent()
        while w:
            if isinstance(w, QMainWindow):
                return w
            w = w.parent()
        return None

    def resizeEvent(self, event):
        super().resizeEvent(event)
        x = self.width()-self.minimap.width()-20
        y = 20
        self.minimap.move(x,y)

    def populate_graph(self):
        self.scene.clear()
        self.node_map.clear()
        self.children_map.clear()
        self.parents_map.clear()

        c = self.connection.cursor()
        c.execute("""
          SELECT RULE_ID,RULE_NAME,PARENT_RULE_ID,STATUS,RULE_TYPE_ID,CLUSTER_NAME,IS_GLOBAL,CRITICAL_RULE
          FROM BRM_RULES
          ORDER BY RULE_ID
        """)
        rules = c.fetchall()
        if not rules:
            no_data = QtWidgets.QGraphicsTextItem("No rules found.")
            self.scene.addItem(no_data)
            return

        # build adjacency
        for r in rules:
            rid = r["RULE_ID"]
            pid = r["PARENT_RULE_ID"]
            if pid:
                self.children_map.setdefault(pid,[]).append(rid)
                self.parents_map[rid] = pid

        rule_lookup = {r["RULE_ID"]:r for r in rules}
        roots = [r for r in rules if not r["PARENT_RULE_ID"]]

        from collections import deque
        queue = deque()
        level_map={}
        visited=set()

        for rt in roots:
            queue.append((rt["RULE_ID"],0))

        while queue:
            (rid, depth) = queue.popleft()
            if rid in visited:
                continue
            visited.add(rid)
            rinfo = rule_lookup[rid]
            c_so_far = level_map.get(depth,0)
            level_map[depth]=c_so_far+1
            x = depth*220
            y = c_so_far*120
            node_item = self.create_node(rinfo)
            node_item.setPos(x,y)
            self.scene.addItem(node_item)
            self.node_map[rid]=node_item

            if rid in self.children_map:
                for ch in self.children_map[rid]:
                    queue.append((ch, depth+1))

        # edges
        for r in rules:
            pid = r["PARENT_RULE_ID"]
            rid = r["RULE_ID"]
            if pid and pid in self.node_map and rid in self.node_map:
                self.draw_edge(pid, rid)

        self.scene.setSceneRect(self.scene.itemsBoundingRect())
        self.reset_minimap()

    def create_node(self, rinfo):
        rtype = rinfo["RULE_TYPE_ID"]
        status = rinfo["STATUS"]
        cluster = rinfo.get("CLUSTER_NAME","") or ""
        isg = rinfo["IS_GLOBAL"]
        icrit = rinfo["CRITICAL_RULE"]

        # rectangle for DQ, ellipse for DM
        if rtype==1:
            node = RuleRectItem(0,0,120,50,rinfo,cluster)
        else:
            node = RuleEllipseItem(0,0,120,50,rinfo,cluster)

        # color fill
        if status.lower()=="active":
            basecol = QtGui.QColor("lightgreen")
        else:
            basecol = QtGui.QColor("tomato")

        # Optionally vary color by cluster or do your own logic
        if cluster:
            hval = abs(hash(cluster))%360
            basecol = QtGui.QColor.fromHsv(hval,128,255)

        node.setBrush(QtGui.QBrush(basecol))

        # border if critical
        pen = QtGui.QPen(QtCore.Qt.black,2)
        if icrit==1:
            pen = QtGui.QPen(QtGui.QColor("red"),3)
        node.setPen(pen)

        # If global => prefix name
        if isg==1:
            rinfo["RULE_NAME"] = f"(G) {rinfo['RULE_NAME']}"

        return node

    def draw_edge(self, parent_id, child_id):
        p_item = self.node_map[parent_id]
        c_item = self.node_map[child_id]
        p_rect = p_item.sceneBoundingRect()
        c_rect = c_item.sceneBoundingRect()
        p_center = p_rect.center()
        c_center = c_rect.center()
        line = QtWidgets.QGraphicsLineItem(p_center.x(), p_center.y(), c_center.x(), c_center.y())
        line.setPen(QtGui.QPen(QtGui.QColor("darkblue"),2))
        self.scene.addItem(line)

    def reset_minimap(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.minimap.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

    def resetView(self):
        if self.scene and self.scene.sceneRect().isValid():
            self.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)
        self.reset_minimap()

    def mousePressEvent(self, event):
        if event.button()==Qt.LeftButton:
            item = self.itemAt(event.pos())
            if isinstance(item, (RuleRectItem,RuleEllipseItem)):
                self.show_rule_details(item.rule_data)
        super().mousePressEvent(event)

    def show_rule_details(self, rinfo):
        msg = (
            f"Rule ID: {rinfo['RULE_ID']}\n"
            f"Name: {rinfo['RULE_NAME']}\n"
            f"Status: {rinfo['STATUS']}\n"
            f"Type ID: {rinfo['RULE_TYPE_ID']}\n"
            f"Parent: {rinfo['PARENT_RULE_ID']}\n"
            f"Global?: {rinfo['IS_GLOBAL']}\n"
            f"Critical?: {rinfo['CRITICAL_RULE']}\n"
        )
        self.detail_panel.setPlainText(msg)

    def show_context_menu(self, pos):
        item = self.itemAt(pos)
        menu = QtWidgets.QMenu()
        if isinstance(item, (RuleRectItem,RuleEllipseItem)):
            rinfo = item.rule_data
            edit_act = QtWidgets.QAction("Edit Rule", menu)
            def on_edit():
                c = self.connection.cursor()
                c.execute("SELECT * FROM BRM_RULES WHERE RULE_ID=?",(rinfo["RULE_ID"],))
                row = c.fetchone()
                if not row:
                    QMessageBox.warning(self,"Not Found","Rule not found.")
                    return
                rowd = dict(row)
                c2 = self.connection.cursor()
                c2.execute("SELECT RULE_TYPE_NAME,RULE_TYPE_ID FROM BRM_RULE_TYPES")
                rts = c2.fetchall()
                rmap = {r_["RULE_TYPE_NAME"]: r_["RULE_TYPE_ID"] for r_ in rts}
                dlg = RuleEditorDialog(self.connection, rmap, "Admin", rowd, parent=self)
                dlg.exec_()
                self.populate_graph()

            edit_act.triggered.connect(on_edit)
            menu.addAction(edit_act)

            ance_act = QtWidgets.QAction("Highlight Ancestors", menu)
            def on_ance():
                self.highlight_ancestors(rinfo["RULE_ID"])
            ance_act.triggered.connect(on_ance)
            menu.addAction(ance_act)

            desc_act = QtWidgets.QAction("Highlight Descendants", menu)
            def on_desc():
                self.highlight_descendants(rinfo["RULE_ID"])
            desc_act.triggered.connect(on_desc)
            menu.addAction(desc_act)

        else:
            clear_act = QtWidgets.QAction("Clear Highlights", menu)
            def on_clear():
                self.clear_highlights()
            clear_act.triggered.connect(on_clear)
            menu.addAction(clear_act)

        menu.exec_(self.mapToGlobal(pos))

    def highlight_ancestors(self, start_id):
        self.clear_highlights()
        cur = start_id
        while cur in self.parents_map:
            node = self.node_map.get(cur)
            if node:
                node.setHighlight(True)
            par = self.parents_map[cur]
            if par in self.node_map:
                self.node_map[par].setHighlight(True)
            cur = par if par else None

    def highlight_descendants(self, start_id):
        self.clear_highlights()
        from collections import deque
        queue = deque([start_id])
        visited=set()
        while queue:
            cid = queue.popleft()
            if cid in visited:
                continue
            visited.add(cid)
            if cid in self.node_map:
                self.node_map[cid].setHighlight(True)
            if cid in self.children_map:
                for ch in self.children_map[cid]:
                    queue.append(ch)

    def clear_highlights(self):
        for nd in self.node_map.values():
            nd.setHighlight(False)

    def search_nodes(self, query):
        self.clear_highlights()
        c = self.connection.cursor()
        ql = query.lower()
        found_any=False

        # Check rule name or ID
        for rid,node in self.node_map.items():
            nm = node.rule_data["RULE_NAME"].lower()
            rid_str = str(node.rule_data["RULE_ID"])
            if ql in nm or ql==rid_str:
                node.setHighlight(True)
                found_any=True

        # Check column mappings
        c.execute("""
          SELECT RULE_ID,SOURCE_COLUMN_NAME,TARGET_COLUMN_NAME
          FROM BRM_COLUMN_MAPPING
          WHERE LOWER(SOURCE_COLUMN_NAME) LIKE ? OR LOWER(TARGET_COLUMN_NAME) LIKE ?
        """,(f"%{ql}%", f"%{ql}%"))
        matches = c.fetchall()
        for row in matches:
            cid = row["RULE_ID"]
            if cid in self.node_map:
                self.node_map[cid].setHighlight(True)
                found_any=True

        if not found_any:
            QMessageBox.information(self,"No Match",f"No rule or column found for '{query}'")
        else:
            self.reset_minimap()

##############################################################################
# CONTROL TABLES TAB
##############################################################################
class CtrlTablesTab(QWidget):
    """
    Lets the user view raw data from any table in the DB.
    """
    def __init__(self, connection, parent=None):
        super().__init__(parent)
        self.connection = connection
        layout = QVBoxLayout(self)

        self.table_list = [
            "USERS",
            "BUSINESS_GROUPS",
            "GROUP_PERMISSIONS",
            "BRM_RULE_TYPES",
            "BRM_RULE_GROUPS",
            "BRM_RULES",
            "BRM_RULE_TABLE_DEPENDENCIES",
            "BRM_AUDIT_LOG",
            "BRM_RULE_LINEAGE",
            "BRM_GROUP_BACKUPS",
            "BRM_COLUMN_MAPPING",
            "BRM_CUSTOM_RULE_GROUPS",
            "BRM_CUSTOM_GROUP_MEMBERS",
            "BUSINESS_GROUP_APPROVERS",
            "BRM_RULE_APPROVALS",
            "BRM_CUSTOM_GROUP_BACKUPS"
        ]
        self.table_combo = QComboBox()
        for t in self.table_list:
            self.table_combo.addItem(t)
        layout.addWidget(QLabel("Select Table:"))
        layout.addWidget(self.table_combo)

        self.load_btn = QPushButton("Load Data")
        self.load_btn.clicked.connect(self.on_load_data)
        layout.addWidget(self.load_btn)

        self.table_view = QTableWidget(0,0)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.table_view)

        self.setLayout(layout)

    def on_load_data(self):
        tbl = self.table_combo.currentText()
        if not tbl:
            return
        c = self.connection.cursor()
        c.execute(f"PRAGMA table_info({tbl})")
        info = c.fetchall()
        col_names = [x["name"] for x in info]
        if not col_names:
            c.execute(f"SELECT * FROM {tbl} LIMIT 1")
            col_names = [d[0] for d in c.description]
        c.execute(f"SELECT * FROM {tbl}")
        rows = c.fetchall()

        self.table_view.setRowCount(0)
        self.table_view.setColumnCount(len(col_names))
        self.table_view.setHorizontalHeaderLabels(col_names)

        for rd in rows:
            r = self.table_view.rowCount()
            self.table_view.insertRow(r)
            for j,cn in enumerate(col_names):
                val = rd[cn]
                item_str = str(val) if val is not None else ""
                self.table_view.setItem(r, j, QTableWidgetItem(item_str))

##############################################################################
# GLOBAL/CRITICAL ADMIN TAB
##############################################################################
class GlobalCriticalAdminTab(QWidget):
    """
    Allows Admin to quickly create Global or Critical rules.
    """
    def __init__(self, main_app, connection, user_group, parent=None):
        super().__init__(parent)
        self.main_app = main_app
        self.connection = connection
        self.user_group = user_group

        layout = QVBoxLayout(self)

        if self.user_group!="Admin":
            layout.addWidget(QLabel("Access Denied: Only Admin can manage global/critical rules."))
            self.setLayout(layout)
            return

        form = QFormLayout()
        self.rule_name_edit = QLineEdit()
        form.addRow("Rule Name:", self.rule_name_edit)

        self.rule_sql_edit = QPlainTextEdit()
        self.rule_sql_edit.setPlainText("SELECT 1;")
        form.addRow("Rule SQL:", self.rule_sql_edit)

        self.global_check = QCheckBox("Is Global Rule?")
        form.addRow("Global?", self.global_check)

        self.critical_check = QCheckBox("Is Critical Rule?")
        form.addRow("Critical?", self.critical_check)

        self.scope_combo = QComboBox()
        self.scope_combo.addItems(["NONE","GROUP","CLUSTER","GLOBAL"])
        form.addRow("Critical Scope:", self.scope_combo)

        rtypes_map = self.main_app.get_rule_types()
        self.rule_type_combo = QComboBox()
        for k in rtypes_map:
            self.rule_type_combo.addItem(k)
        form.addRow("Rule Type:", self.rule_type_combo)

        self.owner_grp_combo = QComboBox()
        c = self.connection.cursor()
        c.execute("SELECT GROUP_NAME FROM BUSINESS_GROUPS ORDER BY GROUP_NAME")
        for row in c.fetchall():
            self.owner_grp_combo.addItem(row["GROUP_NAME"])
        form.addRow("Owner Group:", self.owner_grp_combo)

        layout.addLayout(form)

        btn_h = QHBoxLayout()
        create_btn = QPushButton("Create Global/Critical Rule")
        create_btn.clicked.connect(self.on_create_rule)
        btn_h.addWidget(create_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        self.setLayout(layout)

    def on_create_rule(self):
        is_g = 1 if self.global_check.isChecked() else 0
        is_c = 1 if self.critical_check.isChecked() else 0
        cscope = self.scope_combo.currentText()
        rname = self.rule_name_edit.text().strip()
        rsql = self.rule_sql_edit.toPlainText().strip()
        if not rname or not rsql:
            QMessageBox.warning(self,"Error","Rule name & SQL required.")
            return

        rt_map = self.main_app.get_rule_types()
        sel_rt = self.rule_type_combo.currentText()
        rt_id = rt_map.get(sel_rt, 1)

        ow_grp = self.owner_grp_combo.currentText()

        rule_data = {
            "RULE_NAME": rname,
            "RULE_SQL": rsql,
            "RULE_TYPE_ID": rt_id,
            "OWNER_GROUP": ow_grp,
            "IS_GLOBAL": is_g,
            "CRITICAL_RULE": is_c,
            "CRITICAL_SCOPE": cscope,
            "EFFECTIVE_START_DATE": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "EFFECTIVE_END_DATE": (datetime.now() + timedelta(days=30)).strftime("%Y-%m-%d %H:%M:%S"),
            "OPERATION_TYPE": "OTHER"
        }
        try:
            new_id = add_rule(self.connection, rule_data, "Admin", "Admin")
            QMessageBox.information(self,"Created",
                                    f"Global/Critical rule {new_id} created successfully.")
        except Exception as e:
            QMessageBox.critical(self,"Error",str(e))

##############################################################################
# MAIN WINDOW
##############################################################################
class BRMTool(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BRM Tool - Multi-Step Approvals (Fully Integrated)")
        self.resize(1200,800)
        self.connection = setup_in_memory_db()

        # Show the login dialog
        self.login_dialog = LoginDialog(self.connection)
        if self.login_dialog.exec_() == QDialog.Accepted:
            self.user_id = self.login_dialog.user_id
            c = self.connection.cursor()
            c.execute("SELECT USERNAME FROM USERS WHERE USER_ID=?",(self.user_id,))
            row = c.fetchone()
            self.logged_in_username = row["USERNAME"] if row else "Unknown"

            c.execute("SELECT USER_GROUP FROM USERS WHERE USER_ID=?",(self.user_id,))
            row2 = c.fetchone()
            self.user_group = row2["USER_GROUP"] if row2 else "Unknown"
            self.init_ui()
        else:
            sys.exit()

    def init_ui(self):
        cw = QWidget()
        lay = QVBoxLayout(cw)

        # If Admin => user impersonation
        if self.user_group=="Admin":
            self.switch_combo = QComboBox()
            self.populate_switch_combo()
            self.switch_btn = QPushButton("Switch User")
            self.switch_btn.clicked.connect(self.on_switch_user)
            top_h = QHBoxLayout()
            top_h.addWidget(QLabel("Impersonate:"))
            top_h.addWidget(self.switch_combo)
            top_h.addWidget(self.switch_btn)
            top_h.addStretch()
            lay.addLayout(top_h)

        self.tabs = QTabWidget()
        lay.addWidget(self.tabs)

        # 1) Biz Rule Management
        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab,"Business Rule Management")

        # 2) Group Management (admin-only)
        if self.user_group=="Admin":
            self.grp_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_tab,"Group Management")

        # 3) BFS-based Lineage Visualization
        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        line_w = QWidget()
        lw_layout = QVBoxLayout(line_w)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        lw_layout.addWidget(self.lineage_tab)

        s_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule or column...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        s_h.addWidget(self.lineage_search)
        s_h.addWidget(s_btn)
        s_h.addWidget(rst_btn)
        s_h.addWidget(ref_btn)
        s_h.addStretch()
        lw_layout.addLayout(s_h)
        line_w.setLayout(lw_layout)
        self.tabs.addTab(line_w,"Lineage Visualization")
        self.lineage_tab.populate_graph()

        # 4) Custom Rule Groups
        self.custom_tab = CustomRuleGroupTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Rule Groups")

        # 5) Multi-step Approvals
        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        # 6) Global/Critical Admin (admin-only)
        if self.user_group=="Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        # 7) Control Tables
        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

        cw.setLayout(lay)
        self.setCentralWidget(cw)

        self.init_timer()
        self.show()

    def populate_switch_combo(self):
        c = self.connection.cursor()
        c.execute("SELECT USER_ID,USERNAME,USER_GROUP FROM USERS ORDER BY USER_ID")
        for row in c.fetchall():
            disp = f"{row['USERNAME']} ({row['USER_GROUP']})"
            self.switch_combo.addItem(disp,(row["USER_ID"], row["USER_GROUP"]))

    def on_switch_user(self):
        data = self.switch_combo.currentData()
        if not data:
            return
        new_uid, new_ug = data
        if new_uid==self.user_id and new_ug==self.user_group:
            return
        self.user_id = new_uid
        self.user_group = new_ug
        self.reinit_tabs()

    def reinit_tabs(self):
        self.tabs.clear()

        self.brm_tab = BusinessRuleManagementTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.brm_tab,"Business Rule Management")

        if self.user_group=="Admin":
            self.grp_tab = GroupManagementTab(self, self.connection, self.user_id, self.user_group)
            self.tabs.addTab(self.grp_tab,"Group Management")

        self.lineage_tab = EnhancedLineageGraphWidget(self.connection)
        line_w = QWidget()
        lw_layout = QVBoxLayout(line_w)
        lb = QLabel("Lineage Visualization")
        lb.setStyleSheet("font-weight:bold;")
        lw_layout.addWidget(lb)
        lw_layout.addWidget(self.lineage_tab)

        s_h = QHBoxLayout()
        self.lineage_search = QLineEdit()
        self.lineage_search.setPlaceholderText("Search rule or column...")
        s_btn = QPushButton("Search")
        s_btn.clicked.connect(lambda: self.lineage_tab.search_nodes(self.lineage_search.text()))
        rst_btn = QPushButton("Reset View")
        rst_btn.clicked.connect(self.lineage_tab.resetView)
        ref_btn = QPushButton("Refresh Graph")
        ref_btn.clicked.connect(self.lineage_tab.populate_graph)
        s_h.addWidget(self.lineage_search)
        s_h.addWidget(s_btn)
        s_h.addWidget(rst_btn)
        s_h.addWidget(ref_btn)
        s_h.addStretch()
        lw_layout.addLayout(s_h)
        line_w.setLayout(lw_layout)
        self.tabs.addTab(line_w, "Lineage Visualization")
        self.lineage_tab.populate_graph()

        self.custom_tab = CustomRuleGroupTab(self, self.connection, self.user_id, self.user_group)
        self.tabs.addTab(self.custom_tab,"Custom Rule Groups")

        self.approv_tab = MultiStepApprovalTab(self.connection, self.logged_in_username, self.user_group)
        self.tabs.addTab(self.approv_tab,"Approvals")

        if self.user_group=="Admin":
            self.gc_admin_tab = GlobalCriticalAdminTab(self, self.connection, self.user_group)
            self.tabs.addTab(self.gc_admin_tab, "Global/Critical Admin")

        self.ctrl_tab = CtrlTablesTab(self.connection)
        self.tabs.addTab(self.ctrl_tab, "Control Tables")

    def init_timer(self):
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.refresh_approvals)
        self.timer.start(5000)

    def refresh_approvals(self):
        self.approv_tab.load_approvals()

    def get_rule_types(self):
        c = self.connection.cursor()
        c.execute("SELECT RULE_TYPE_NAME,RULE_TYPE_ID FROM BRM_RULE_TYPES")
        rows = c.fetchall()
        return {r["RULE_TYPE_NAME"]: r["RULE_TYPE_ID"] for r in rows}

    def launch_audit_log_viewer(self):
        dlg = AuditLogViewer(self.connection, self.user_group, self)
        dlg.exec_()

    def launch_search_rule_dialog(self):
        dlg = SearchRuleDialog(self.connection, self.user_group, self)
        dlg.exec_()

    def closeEvent(self, event):
        if self.connection:
            try:
                self.connection.close()
            except Exception:
                pass
        event.accept()

##############################################################################
# MAIN
##############################################################################
def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    w = BRMTool()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()