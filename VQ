#!/usr/bin/env python3
# vqb_federated_merged.py
#
# Single-file Python/PyQt Visual Query Builder with:
#   - Multi-DB ODBC connections (Teradata / SQL Server, etc.)
#   - BFS multi-join & column-to-column lines
#   - Collapsible BFS source + target for DML (INSERT/UPDATE/DELETE)
#   - Filter/Group/Sort panels, pivot-like wizard
#   - Advanced Expression Builder => token-based, CASE wizard, subquery insertion
#   - Window Function Wizard
#   - Data Profiler => ERR(...) + outlier chart
#   - Nested subqueries & Sub-VQB
#   - CTE panel => "virtual tables" on BFS canvas
#   - "SQL Import" => partial BFS rebuild using sqlglot
#   - Cross-DB federation => linked server rewriting
#   - No forced LIMIT in run_sql
#   - DML modes (SELECT/INSERT/UPDATE/DELETE)
#
# Requirements:
#   pip install pyqt5 pyodbc sqlparse sqlglot matplotlib

import sys
import traceback
import logging
import pyodbc
import sqlparse
import sqlglot
from sqlglot import exp

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (
    Qt, QPointF, QTimer, QThreadPool, QRunnable, pyqtSignal, QObject,
    QRegularExpression
)
from PyQt5.QtGui import (
    QPalette, QColor, QPen, QBrush, QFont, QSyntaxHighlighter, QTextCharFormat
)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTreeWidget, QTreeWidgetItem, QTextEdit, QPushButton, QSplitter,
    QLineEdit, QLabel, QDialog, QFormLayout, QComboBox, QTableWidget,
    QTableWidgetItem, QTabWidget, QMessageBox, QGraphicsView,
    QGraphicsScene, QGraphicsRectItem, QGraphicsTextItem, QGraphicsItem,
    QGraphicsLineItem, QProgressBar, QDialogButtonBox, QStatusBar,
    QGroupBox, QAbstractItemView, QSpinBox, QMenu, QFrame, QAction,
    QListWidget, QCheckBox, QHeaderView
)

import matplotlib
matplotlib.use("Agg")  # Avoid needing a display environment
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure

###############################################################################
# Logging + "Fusion" style
###############################################################################
logging.basicConfig(
    filename="vqb.log",
    filemode="a",
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.DEBUG
)
pyodbc.pooling = True

def apply_fusion_style():
    QApplication.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(240,240,240))
    palette.setColor(QPalette.WindowText, Qt.black)
    palette.setColor(QPalette.Base, QColor(255,255,255))
    palette.setColor(QPalette.AlternateBase, QColor(225,225,225))
    palette.setColor(QPalette.Button, QColor(230,230,230))
    palette.setColor(QPalette.ButtonText, Qt.black)
    palette.setColor(QPalette.Highlight, QColor(76,163,224))
    palette.setColor(QPalette.HighlightedText, Qt.white)
    QApplication.setPalette(palette)

    style_sheet = """
        QCheckBox::indicator, QRadioButton::indicator {
            width: 12px;
            height: 12px;
            spacing: 2px;
        }
    """
    QApplication.instance().setStyleSheet(style_sheet)

###############################################################################
# ODBCConnectDialog + MultiODBCConnectDialog
###############################################################################
class ODBCConnectDialog(QDialog):
    """
    Single DSN connect.  Tries to detect DB type (Teradata / SQL Server / etc.)
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self._conn = None
        self._db_type = None
        self.setWindowTitle("Connect to ODBC")
        self.resize(400,230)

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Pick an ODBC DSN (Teradata / SQL Server / etc.):"))
        self.dsn_combo = QComboBox()
        try:
            dsns = pyodbc.dataSources()
            for d in sorted(dsns.keys()):
                self.dsn_combo.addItem(d)
        except:
            pass
        layout.addWidget(self.dsn_combo)

        layout.addWidget(QLabel("Username (optional):"))
        self.user_edit = QLineEdit()
        layout.addWidget(self.user_edit)

        layout.addWidget(QLabel("Password (optional):"))
        self.pass_edit = QLineEdit()
        self.pass_edit.setEchoMode(QLineEdit.Password)
        layout.addWidget(self.pass_edit)

        btns = QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        dsn = self.dsn_combo.currentText().strip()
        if not dsn:
            QMessageBox.warning(self, "No DSN", "Please pick a DSN.")
            return
        user = self.user_edit.text().strip()
        pwd  = self.pass_edit.text().strip()

        conn_str = f"DSN={dsn};"
        if user:
            conn_str += f"UID={user};"
        if pwd:
            conn_str += f"PWD={pwd};"

        try:
            cn = pyodbc.connect(conn_str, autocommit=True)
            self._conn = cn
            try:
                dbms = cn.getinfo(pyodbc.SQL_DBMS_NAME) or ""
                if "TERADATA" in dbms.upper():
                    self._db_type = "Teradata"
                elif "SQL SERVER" in dbms.upper():
                    self._db_type = "SQLServer"
                else:
                    self._db_type = dbms.strip()
            except:
                self._db_type = "Unknown"
            self.accept()
        except Exception as ex:
            QMessageBox.critical(self,"Connect Error",f"Failed:\n{ex}")

    def get_connection(self):
        return self._conn

    def get_db_type(self):
        return self._db_type


class MultiODBCConnectDialog(QDialog):
    """
    Dialog to manage multiple ODBC connections, each with an alias => {connection, db_type}
    """
    def __init__(self, existing_conns=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Manage DB Connections")
        self.resize(500,300)
        self._connections = existing_conns if existing_conns else {}

        layout = QVBoxLayout(self)
        instruct = QLabel("Add or Remove ODBC connections (Teradata / SQL Server / etc.).")
        layout.addWidget(instruct)

        self.conn_table = QTableWidget(0,3)
        self.conn_table.setHorizontalHeaderLabels(["Alias","DB Type","Status"])
        self.conn_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.conn_table)

        # populate table with existing
        for alias, info in self._connections.items():
            r = self.conn_table.rowCount()
            self.conn_table.insertRow(r)
            self.conn_table.setItem(r,0,QTableWidgetItem(alias))
            dbt=info.get("db_type","Unknown")
            self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
            st="OK" if info.get("connection") else "NoConn"
            self.conn_table.setItem(r,2,QTableWidgetItem(st))

        btns=QHBoxLayout()
        add_btn=QPushButton("Add Connection")
        rm_btn=QPushButton("Remove Connection")
        ok_btn=QPushButton("Close")
        btns.addWidget(add_btn)
        btns.addWidget(rm_btn)
        btns.addStretch()
        btns.addWidget(ok_btn)
        layout.addLayout(btns)

        add_btn.clicked.connect(self.on_add)
        rm_btn.clicked.connect(self.on_rm)
        ok_btn.clicked.connect(self.accept)
        self.setLayout(layout)

    def on_add(self):
        d=ODBCConnectDialog(self)
        if d.exec_()==QDialog.Accepted:
            c=d.get_connection()
            dbt=d.get_db_type()
            if c:
                alias=f"{dbt}_{len(self._connections)+1}"
                self._connections[alias]={"connection":c,"db_type":dbt}
                r=self.conn_table.rowCount()
                self.conn_table.insertRow(r)
                self.conn_table.setItem(r,0,QTableWidgetItem(alias))
                self.conn_table.setItem(r,1,QTableWidgetItem(dbt))
                self.conn_table.setItem(r,2,QTableWidgetItem("OK"))

    def on_rm(self):
        rows=self.conn_table.selectionModel().selectedRows()
        if not rows:
            return
        for rr in sorted([x.row() for x in rows], reverse=True):
            alias_item=self.conn_table.item(rr,0)
            if alias_item:
                alias=alias_item.text()
                if alias in self._connections:
                    del self._connections[alias]
            self.conn_table.removeRow(rr)

    def get_connections(self):
        return self._connections

###############################################################################
# LinkedServerConfigDialog => cross-DB rewriting
###############################################################################
class LinkedServerConfigDialog(QDialog):
    """
    Let user map each DB alias => a 'linked server name' for cross-DB queries.
    """
    def __init__(self, existing_map=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Linked Server / Federation Config")
        self.resize(500,300)
        self._map = existing_map.copy() if existing_map else {}

        lay = QVBoxLayout(self)
        instruct=QLabel(
            "Define how each DB alias is mapped to a 'linked server name' for cross-DB queries.\n"
            "For example: 'SQLServer_1' => 'LinkedSrv'. Then 'SQLServer_1.db.tbl'\n"
            " becomes '[LinkedSrv].[db].dbo.[tbl]'."
        )
        lay.addWidget(instruct)

        self.table=QTableWidget(0,2)
        self.table.setHorizontalHeaderLabels(["DB Alias","LinkedServerName"])
        self.table.horizontalHeader().setStretchLastSection(True)
        lay.addWidget(self.table)

        for alias,lsn in self._map.items():
            r=self.table.rowCount()
            self.table.insertRow(r)
            self.table.setItem(r,0,QTableWidgetItem(alias))
            self.table.setItem(r,1,QTableWidgetItem(lsn))

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add Mapping")
        rm_btn=QPushButton("Remove Mapping")
        close_btn=QPushButton("Close")
        btn_h.addWidget(add_btn)
        btn_h.addWidget(rm_btn)
        btn_h.addStretch()
        btn_h.addWidget(close_btn)
        lay.addLayout(btn_h)

        add_btn.clicked.connect(self.on_add)
        rm_btn.clicked.connect(self.on_rm)
        close_btn.clicked.connect(self.accept)
        self.setLayout(lay)

    def on_add(self):
        r=self.table.rowCount()
        self.table.insertRow(r)
        self.table.setItem(r,0,QTableWidgetItem("AliasXYZ"))
        self.table.setItem(r,1,QTableWidgetItem("LinkedSrvName"))

    def on_rm(self):
        rows=self.table.selectionModel().selectedRows()
        if not rows: return
        for rr in sorted([r.row() for r in rows], reverse=True):
            self.table.removeRow(rr)

    def accept(self):
        newmap={}
        for r in range(self.table.rowCount()):
            alias_item=self.table.item(r,0)
            ls_item=self.table.item(r,1)
            if alias_item and ls_item:
                alias=alias_item.text().strip()
                ls=ls_item.text().strip()
                if alias:
                    newmap[alias]=ls
        self._map=newmap
        super().accept()

    def get_map(self):
        return self._map

###############################################################################
# load_tables/load_columns => multi DB
###############################################################################
def load_tables(connection, db_type, db_name):
    out=[]
    if not connection:
        return out
    try:
        cur=connection.cursor()
        if "TERADATA" in db_type.upper():
            q=f"SELECT TableName FROM DBC.TablesV WHERE DatabaseName='{db_name}' AND TableKind='T' ORDER BY TableName"
            cur.execute(q)
            rows=cur.fetchall()
            out=[row[0].strip() for row in rows]
        elif "SQLSERVER" in db_type.upper():
            q=f"SELECT TABLE_NAME FROM {db_name}.INFORMATION_SCHEMA.TABLES ORDER BY TABLE_NAME"
            cur.execute(q)
            rows=cur.fetchall()
            out=[row[0].strip() for row in rows]
        else:
            # fallback or other DB
            pass
    except Exception as ex:
        logging.warning(f"Failed to load tables for {db_name}: {ex}")
    return out

def load_columns(connection, db_type, db_name, tbl_name):
    out=[]
    if not connection:
        return out
    try:
        cur=connection.cursor()
        if "TERADATA" in db_type.upper():
            q=f"SELECT ColumnName FROM DBC.ColumnsV WHERE DatabaseName='{db_name}' AND TableName='{tbl_name}' ORDER BY ColumnId"
            cur.execute(q)
            rows=cur.fetchall()
            out=[row[0].strip() for row in rows]
        elif "SQLSERVER" in db_type.upper():
            q=f"SELECT COLUMN_NAME FROM {db_name}.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='{tbl_name}' ORDER BY ORDINAL_POSITION"
            cur.execute(q)
            rows=cur.fetchall()
            out=[row[0].strip() for row in rows]
        else:
            # fallback or other DB
            pass
    except Exception as ex:
        logging.warning(f"Failed to load columns for {db_name}.{tbl_name}: {ex}")
    return out

###############################################################################
# SchemaLoader => lazy load threads
###############################################################################
class SchemaLoaderSignals(QtCore.QObject):
    finished=pyqtSignal(str,list)
    error=pyqtSignal(str,str)

class SchemaLoader(QtCore.QRunnable):
    def __init__(self, connection, db_type, db_name):
        super().__init__()
        self.connection=connection
        self.db_type=db_type
        self.db_name=db_name
        self.signals=SchemaLoaderSignals()

    @QtCore.pyqtSlot()
    def run(self):
        try:
            t=load_tables(self.connection,self.db_type,self.db_name)
            self.signals.finished.emit(self.db_name,t)
        except Exception as ex:
            err=f"{ex}\n{traceback.format_exc()}"
            self.signals.error.emit(self.db_name, err)

###############################################################################
# MultiDBLazySchemaTreeWidget => lazy loading
###############################################################################
class MultiDBLazySchemaTreeWidget(QTreeWidget):
    """
    Displays multiple DB connections => each DB => each table => columns
    with lazy expansion on double-click.
    """
    def __init__(self, connections, parent_builder=None, parent=None):
        super().__init__(parent)
        self.connections=connections
        self.parent_builder=parent_builder
        self.setHeaderHidden(False)
        self.setColumnCount(1)
        self.setHeaderLabel("Databases / Tables")
        self.setDragEnabled(True)
        self.threadpool=QThreadPool.globalInstance()
        self.populate_roots()

    def populate_roots(self):
        self.clear()
        if not self.connections:
            self.addTopLevelItem(QTreeWidgetItem(["No Connections"]))
            return
        for alias,info in self.connections.items():
            top=QTreeWidgetItem([f"{alias} ({info.get('db_type','Unknown')})"])
            top.setData(0, Qt.UserRole, ("connAlias", alias))
            self.addTopLevelItem(top)
            conn=info.get("connection")
            dbt=info.get("db_type","")
            if not conn:
                top.addChild(QTreeWidgetItem(["(No connection)"]))
                continue
            try:
                c=conn.cursor()
                if "TERADATA" in dbt.upper():
                    c.execute("SELECT DISTINCT DatabaseName FROM DBC.TablesV ORDER BY DatabaseName")
                    rows=c.fetchall()
                    for row in rows:
                        dbn=row[0].strip()
                        db_item=QTreeWidgetItem([dbn])
                        db_item.setData(0, Qt.UserRole, ("db", alias, dbn))
                        db_item.setData(0, Qt.UserRole+1, False)
                        db_item.addChild(QTreeWidgetItem(["Loading..."]))
                        top.addChild(db_item)
                elif "SQLSERVER" in dbt.upper():
                    c.execute("SELECT name FROM sys.databases ORDER BY name")
                    rows=c.fetchall()
                    for row in rows:
                        dbn=row[0].strip()
                        db_item=QTreeWidgetItem([dbn])
                        db_item.setData(0, Qt.UserRole, ("db", alias, dbn))
                        db_item.setData(0, Qt.UserRole+1, False)
                        db_item.addChild(QTreeWidgetItem(["Loading..."]))
                        top.addChild(db_item)
                else:
                    top.addChild(QTreeWidgetItem(["(Unknown DB type)"]))
            except Exception as ex:
                top.addChild(QTreeWidgetItem([f"(Error: {ex})"]))
        self.expandAll()

    def mouseDoubleClickEvent(self,e):
        it=self.itemAt(e.pos())
        if it:
            d=it.data(0,Qt.UserRole)
            if d and d[0]=="db":
                loaded=it.data(0,Qt.UserRole+1)
                if not loaded:
                    it.takeChildren()
                    alias, dbn=d[1], d[2]
                    info=self.connections.get(alias)
                    if info and info.get("connection"):
                        c=info["connection"]
                        dbt=info["db_type"]
                        worker=SchemaLoader(c,dbt,dbn)
                        def on_finish(dbname,tables):
                            self.populate_tables(it, dbname,tables)
                        def on_error(dbname,err):
                            QMessageBox.critical(self,"Schema Error",f"{dbname} => {err}")
                        worker.signals.finished.connect(on_finish)
                        worker.signals.error.connect(on_error)
                        self.threadpool.start(worker)
        super().mouseDoubleClickEvent(e)

    def populate_tables(self, parent_item, dbname, tables):
        if not tables:
            parent_item.addChild(QTreeWidgetItem(["<No Tables>"]))
            parent_item.setData(0, Qt.UserRole+1, True)
            return
        parent_item.takeChildren()
        d=parent_item.data(0,Qt.UserRole)
        alias=d[1]
        for t in tables:
            t_item=QTreeWidgetItem([t])
            t_item.setData(0, Qt.UserRole, ("table",alias,dbname,t))
            t_item.setData(0, Qt.UserRole+1, False)
            t_item.addChild(QTreeWidgetItem(["Loading..."]))
            parent_item.addChild(t_item)
        parent_item.setData(0,Qt.UserRole+1,True)

    def expand_table(self, table_item):
        loaded=table_item.data(0,Qt.UserRole+1)
        if not loaded:
            table_item.takeChildren()
            d=table_item.data(0,Qt.UserRole)
            alias,dbn,tbn=d[1],d[2],d[3]
            info=self.connections.get(alias)
            if info:
                c=info["connection"]
                dbt=info["db_type"]
                cols=load_columns(c,dbt,dbn,tbn)
                if cols:
                    for cc in cols:
                        child=QTreeWidgetItem([cc])
                        child.setData(0, Qt.UserRole, ("column",alias,dbn,tbn,cc))
                        table_item.addChild(child)
                else:
                    table_item.addChild(QTreeWidgetItem(["<No columns>"]))
            table_item.setData(0,Qt.UserRole+1,True)

    def mousePressEvent(self,e):
        it=self.itemAt(e.pos())
        if it:
            d=it.data(0,Qt.UserRole)
            if d and d[0]=="table":
                self.expand_table(it)
        super().mousePressEvent(e)

    def startDrag(self,actions):
        it=self.currentItem()
        if it:
            d=it.data(0,Qt.UserRole)
            if d and d[0]=="table":
                alias,dbn,tbl=d[1],d[2],d[3]
                full_key=f"{alias}.{dbn}.{tbl}"
                drag=QtGui.QDrag(self)
                mime=QtCore.QMimeData()
                mime.setText(full_key)
                drag.setMimeData(mime)
                drag.exec_(actions)

###############################################################################
# FullSQLParser + SQLHighlighter
###############################################################################
class FullSQLParser:
    def __init__(self, sql):
        self.sql=sql
    def parse(self):
        st=sqlparse.parse(self.sql)
        if not st:
            raise ValueError("No valid SQL found.")

class SQLHighlighter(QSyntaxHighlighter):
    def __init__(self, doc):
        super().__init__(doc)
        self.rules=[]
        kwfmt=QTextCharFormat()
        kwfmt.setForeground(Qt.darkBlue)
        kwfmt.setFontWeight(QFont.Bold)

        keywords=[
            "SELECT","FROM","WHERE","JOIN","INNER","LEFT","RIGHT","FULL","OUTER",
            "GROUP","BY","HAVING","ORDER","LIMIT","OFFSET","UNION","ALL","INTERSECT",
            "EXCEPT","AS","ON","AND","OR","NOT","IN","IS","NULL","EXISTS","COUNT",
            "SUM","AVG","MIN","MAX","INSERT","UPDATE","DELETE","VALUES","OVER",
            "PARTITION","ROWS","RANGE","CURRENT ROW","ROW_NUMBER","RANK","DENSE_RANK",
            "NTILE","LAG","LEAD","CASE","COALESCE","TRIM","FIRST_VALUE","LAST_VALUE",
            "WITH"
        ]
        for w in keywords:
            pattern=QRegularExpression(r'\b'+w+r'\b',QRegularExpression.CaseInsensitiveOption)
            self.rules.append((pattern, kwfmt))

        strfmt=QTextCharFormat()
        strfmt.setForeground(Qt.darkRed)
        self.rules.append((QRegularExpression(r"'[^']*'"),strfmt))
        self.rules.append((QRegularExpression(r'"[^"]*"'),strfmt))

        cfmt=QTextCharFormat()
        cfmt.setForeground(Qt.green)
        self.rules.append((QRegularExpression(r'--[^\n]*'), cfmt))
        self.rules.append((QRegularExpression(r'/\*.*\*/', QRegularExpression.DotMatchesEverythingOption), cfmt))

    def highlightBlock(self, text):
        for pat,fmt in self.rules:
            matches=pat.globalMatch(text)
            while matches.hasNext():
                m=matches.next()
                st=m.capturedStart()
                ln=m.capturedLength()
                self.setFormat(st,ln,fmt)
        self.setCurrentBlockState(0)

###############################################################################
# BFS Items: JoinLine, MappingLine, CollapsibleTableGraphicsItem, BFS-Item, etc.
###############################################################################
class ColumnJoinWizardDialog(QDialog):
    """
    Used when dragging one column onto another => define join type + condition.
    """
    def __init__(self, source_full, source_type, target_full, target_type, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Column Join Wizard")
        self.resize(400,200)

        self.source_col=source_full
        self.source_type=source_type
        self.target_col=target_full
        self.target_type=target_type
        self.join_type="INNER"
        self.condition=f"{self.source_col} = {self.target_col}"

        layout=QVBoxLayout(self)
        info=QLabel(
            f"Source: {self.source_col} (type={self.source_type})\n"
            f"Target: {self.target_col} (type={self.target_type})"
        )
        layout.addWidget(info)
        if self.source_type.lower()!=self.target_type.lower():
            warn=QLabel("<b>Warning:</b> Different data types (may need cast).")
            warn.setStyleSheet("color:red;")
            layout.addWidget(warn)

        form=QFormLayout()
        self.join_combo=QComboBox()
        self.join_combo.addItems(["INNER","LEFT","RIGHT","FULL"])
        form.addRow("Join Type:", self.join_combo)

        self.cond_edit=QLineEdit(self.condition)
        form.addRow("Condition:", self.cond_edit)
        layout.addLayout(form)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        jt=self.join_combo.currentText()
        cond=self.cond_edit.text().strip()
        if not cond:
            QMessageBox.warning(self,"No condition","Condition must not be empty.")
            return
        self.join_type=jt
        self.condition=cond
        self.accept()

    def get_join_data(self):
        return (self.join_type, self.condition)

class MappingLine(QGraphicsLineItem):
    """
    Red line connecting BFS source column => Target table column
    """
    def __init__(self, source_text_item, target_text_item, parent_canvas,
                 source_type=None, target_type=None):
        super().__init__()
        self.canvas=parent_canvas
        self.source_text_item=source_text_item
        self.target_text_item=target_text_item
        self.source_col=source_text_item.toPlainText()
        self.target_col=target_text_item.toPlainText()
        self.source_type=source_type
        self.target_type=target_type

        self.setPen(QPen(Qt.darkRed,2,Qt.SolidLine))
        self.setZValue(5)
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptHoverEvents(True)
        self.update_pos()

    def update_pos(self):
        s=self.source_text_item.mapToScene(self.source_text_item.boundingRect().center())
        t=self.target_text_item.mapToScene(self.target_text_item.boundingRect().center())
        self.setLine(QtCore.QLineF(s,t))

    def paint(self, painter, option, widget):
        self.update_pos()
        super().paint(painter,option,widget)

    def contextMenuEvent(self,event):
        menu=QMenu()
        rm=menu.addAction("Remove Column Mapping")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            if self in self.canvas.mapping_lines:
                self.canvas.mapping_lines.remove(self)
            sc=self.scene()
            if sc:
                sc.removeItem(self)

class JoinLine(QGraphicsLineItem):
    """
    Blue/green line connecting two BFS table items => join type & condition
    Possibly includes references to the actual column text items for clarity
    """
    def __init__(self, start_item, end_item, join_type="INNER", condition="",
                 start_col_text_item=None, end_col_text_item=None):
        super().__init__()
        self.start_item=start_item
        self.end_item=end_item
        self.join_type=join_type
        self.condition=condition
        self.start_col_text_item=start_col_text_item
        self.end_col_text_item=end_col_text_item
        self.setZValue(-1)
        self.setAcceptHoverEvents(True)

        self.pen_map={
            "INNER":(Qt.darkBlue, Qt.SolidLine),
            "LEFT": (Qt.darkGreen, Qt.SolidLine),
            "RIGHT":(Qt.magenta,Qt.DotLine),
            "FULL": (Qt.red,Qt.DashLine),
        }
        self.label=QGraphicsTextItem(f"{self.join_type} JOIN",self)
        self.label.setDefaultTextColor(Qt.blue)
        self.update_line()

    def update_line(self):
        if self.start_col_text_item:
            sr=self.start_col_text_item.boundingRect()
            scn=self.start_col_text_item.mapToScene(sr.center())
        else:
            sr=self.start_item.boundingRect()
            scn=self.start_item.mapToScene(sr.center())

        if self.end_col_text_item:
            er=self.end_col_text_item.boundingRect()
            ecn=self.end_col_text_item.mapToScene(er.center())
        else:
            er=self.end_item.boundingRect()
            ecn=self.end_item.mapToScene(er.center())

        self.setLine(QtCore.QLineF(scn, ecn))
        mx=(scn.x()+ecn.x())/2
        my=(scn.y()+ecn.y())/2
        self.label.setPos(mx,my)
        color,style=self.pen_map.get(self.join_type,(Qt.gray,Qt.SolidLine))
        self.setPen(QPen(color,2,style))

    def hoverEnterEvent(self,e):
        p=self.pen()
        p.setColor(Qt.yellow)
        p.setWidth(3)
        self.setPen(p)
        super().hoverEnterEvent(e)

    def hoverLeaveEvent(self,e):
        self.update_line()
        super().hoverLeaveEvent(e)

class DraggableColumnTextItem(QGraphicsTextItem):
    """
    Column label item inside a CollapsibleTableGraphicsItem.  
    Allows dragging to another column => wizard => BFS join line.
    """
    def __init__(self, parent_table_item, column_name, column_type):
        super().__init__(column_name, parent_table_item)
        self.parent_table_item=parent_table_item
        self.column_name=column_name
        self.column_type=column_type
        self.setFlags(QGraphicsItem.ItemIsSelectable|QGraphicsItem.ItemIsFocusable)
        self.setAcceptDrops(True)

    def mousePressEvent(self,event):
        if event.button()==Qt.LeftButton:
            drag=QtGui.QDrag(event.widget())
            mime=QtCore.QMimeData()
            full_col=f"{self.parent_table_item.table_fullname}.{self.column_name}"
            mime.setText(f"{full_col}||{self.column_type}")
            drag.setMimeData(mime)
            drag.exec_(Qt.MoveAction)
        else:
            super().mousePressEvent(event)

    def dragEnterEvent(self,event):
        if event.mimeData().hasText() and "||" in event.mimeData().text():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dragMoveEvent(self,event):
        event.acceptProposedAction()

    def dropEvent(self,event):
        txt=event.mimeData().text()
        if "||" not in txt:
            event.ignore()
            return
        source_full, source_type=txt.split("||",1)
        target_full=f"{self.parent_table_item.table_fullname}.{self.column_name}"
        target_type=self.column_type

        if source_full==target_full:
            QMessageBox.information(None,"Same Column","Cannot join a column onto itself.")
            event.ignore()
            return
        if source_full.startswith(self.parent_table_item.table_fullname+"."):
            QMessageBox.information(None,"Same Table","Join across different tables only.")
            event.ignore()
            return

        dlg=ColumnJoinWizardDialog(source_full,source_type,target_full,target_type)
        if dlg.exec_()==QDialog.Accepted:
            jtype,cond=dlg.get_join_data()
            builder=self.parent_table_item.parent_builder
            cv=builder.canvas

            sf_tab=".".join(source_full.split(".")[:3])
            tf_tab=".".join(target_full.split(".")[:3])

            source_item=cv.table_items.get(sf_tab,None)
            target_item=cv.table_items.get(tf_tab,None)
            if not source_item or not target_item:
                QMessageBox.warning(None,"Join Error","Could not find BFS table items for source/target.")
                event.ignore()
                return

            s_col_name=source_full.split(".")[-1]
            t_col_name=target_full.split(".")[-1]
            src_col_text_item=source_item.column_text_items.get(s_col_name)
            tgt_col_text_item=target_item.column_text_items.get(t_col_name)

            jl=JoinLine(source_item,target_item,jtype,cond,src_col_text_item,tgt_col_text_item)
            cv.scene_.addItem(jl)
            cv.join_lines.append(jl)
            jl.update_line()
            QMessageBox.information(None,"Join Created",f"{jtype} JOIN line:\n{cond}")
            event.acceptProposedAction()
        else:
            event.ignore()

class CollapsibleTableGraphicsItem(QGraphicsRectItem):
    """
    BFS rectangle representing a single table or CTE on the canvas.
    Collapsible => click on the small rectangles to 'check' columns for SELECT.
    """
    def __init__(self, table_fullname, columns, parent_builder, x=0, y=0):
        super().__init__(0,0,220,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(220,220,255)))
        self.setPen(QPen(Qt.darkGray,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.table_fullname=table_fullname
        self.columns=columns
        self.parent_builder=parent_builder

        self.is_collapsed=True
        self.title_height=20
        self.column_items=[]
        self.column_text_items={}

        self.close_btn=QGraphicsTextItem("[X]", self)
        self.close_btn.setPos(190,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn=QGraphicsTextItem("[+]", self)
        self.toggle_btn.setPos(170,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f=QFont("Arial",9,QFont.Bold)
        self.title_text=QGraphicsTextItem(table_fullname, self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        # mock types
        self.mock_column_types={}
        for c in columns:
            if c.lower().startswith("id") or c.lower().endswith("id"):
                self.mock_column_types[c]="INT"
            else:
                self.mock_column_types[c]="VARCHAR"

        yOff=self.title_height
        for c in columns:
            cRect=QGraphicsRectItem(5,yOff+4,10,10,self)
            cRect.setBrush(QBrush(Qt.white))
            cRect.setPen(QPen(Qt.black,1))
            cText=DraggableColumnTextItem(self,c,self.mock_column_types[c])
            cText.setPos(20,yOff)
            self.column_items.append([cRect,cText,False])
            self.column_text_items[c]=cText
            yOff+=20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,220,self.title_height)
            for (r,t,_) in self.column_items:
                r.setVisible(False)
                t.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded=self.title_height+len(self.column_items)*20
            self.setRect(0,0,220,expanded)
            for (r,t,_) in self.column_items:
                r.setVisible(True)
                t.setVisible(True)
            self.toggle_btn.setPlainText("[-]")

        self.close_btn.setPos(190,2)
        self.toggle_btn.setPos(170,2)

    def mousePressEvent(self,event):
        pos=event.pos()
        close_rect=self.close_btn.mapToParent(self.close_btn.boundingRect())
        if close_rect.boundingRect().contains(pos):
            if self.parent_builder:
                self.parent_builder.handle_remove_table(self)
            event.accept()
            return

        toggle_rect=self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if toggle_rect.boundingRect().contains(pos):
            self.is_collapsed=not self.is_collapsed
            self.update_layout()
            event.accept()
            return

        for i,(cRect,cText,checked) in enumerate(self.column_items):
            rRect=cRect.mapToParent(cRect.boundingRect()).boundingRect()
            if rRect.contains(pos):
                self.column_items[i][2]=not checked
                cRect.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def contextMenuEvent(self,event):
        menu=QMenu()
        rm=menu.addAction("Remove Table/CTE")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            if self.parent_builder:
                self.parent_builder.handle_remove_table(self)

    def get_selected_columns(self):
        sel=[]
        for (r,t,checked) in self.column_items:
            if checked:
                colName=t.toPlainText().strip()
                sel.append(f"{self.table_fullname}.{colName}")
        return sel

###############################################################################
# BFS CollapsibleBFSGraphicsItem => "source" item in DML
###############################################################################
class CollapsibleBFSGraphicsItem(QGraphicsRectItem):
    """
    BFS source item for DML. Similar to CollapsibleTable but styled differently.
    """
    def __init__(self, title, columns, parent_builder, x=100, y=100):
        super().__init__(0,0,240,40)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(250,250,180)))
        self.setPen(QPen(Qt.red,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.item_title=title
        self.columns=columns
        self.parent_builder=parent_builder

        self.is_collapsed=False
        self.title_height=20
        self.column_items=[]

        self.close_btn=QGraphicsTextItem("[X]", self)
        self.close_btn.setPos(215,2)
        self.close_btn.setDefaultTextColor(Qt.red)

        self.toggle_btn=QGraphicsTextItem("[-]", self)
        self.toggle_btn.setPos(195,2)
        self.toggle_btn.setDefaultTextColor(Qt.blue)

        f=QFont("Arial",9,QFont.Bold)
        self.title_text=QGraphicsTextItem(title, self)
        self.title_text.setFont(f)
        self.title_text.setPos(5,2)

        yOff=self.title_height
        for c in columns:
            r=QGraphicsRectItem(5,yOff+4,10,10,self)
            r.setBrush(QBrush(Qt.blue))
            r.setPen(QPen(Qt.black,1))
            t=QGraphicsTextItem(c,self)
            t.setPos(20,yOff)
            self.column_items.append([r,t,True])
            yOff+=20

        self.update_layout()

    def update_layout(self):
        if self.is_collapsed:
            self.setRect(0,0,240,self.title_height)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(False)
                ct.setVisible(False)
            self.toggle_btn.setPlainText("[+]")
        else:
            expanded=self.title_height+len(self.column_items)*20
            self.setRect(0,0,240,expanded)
            for (cb,ct,chk) in self.column_items:
                cb.setVisible(True)
                ct.setVisible(True)
            self.toggle_btn.setPlainText("[-]")

    def mousePressEvent(self,event):
        pos=event.pos()
        cbr=self.close_btn.mapToParent(self.close_btn.boundingRect())
        if cbr.boundingRect().contains(pos):
            sc=self.scene()
            if sc:
                sc.removeItem(self)
            event.accept()
            return
        tbr=self.toggle_btn.mapToParent(self.toggle_btn.boundingRect())
        if tbr.boundingRect().contains(pos):
            self.is_collapsed=not self.is_collapsed
            self.update_layout()
            event.accept()
            return
        for i,(cb,ct,chk) in enumerate(self.column_items):
            rr=cb.mapToParent(cb.boundingRect()).boundingRect()
            if rr.contains(pos):
                self.column_items[i][2]=not chk
                cb.setBrush(QBrush(Qt.blue if self.column_items[i][2] else Qt.white))
                if self.parent_builder and self.parent_builder.auto_generate:
                    self.parent_builder.generate_sql()
                event.accept()
                return
        super().mousePressEvent(event)

    def get_checked_columns(self):
        arr=[]
        for (cb,ct,chk) in self.column_items:
            if chk:
                arr.append(ct.toPlainText().strip())
        return arr

###############################################################################
# Nested subqueries & Sub-VQB stubs
###############################################################################
class NestedVQBDialog(QDialog):
    def __init__(self, existing_sql="", parent_builder=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Nested Sub-VQB")
        self.resize(900,600)
        self.existing_sql=existing_sql
        self.parent_builder=parent_builder
        self.result_sql=""

        layout=QVBoxLayout(self)
        self.subq_edit = QTextEdit()
        self.subq_edit.setPlainText(self.existing_sql)
        layout.addWidget(self.subq_edit)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        raw_sql=self.subq_edit.toPlainText().strip()
        if raw_sql:
            self.result_sql=raw_sql
            self.accept()
        else:
            QMessageBox.warning(self,"No SubQuery","Subquery is empty.")

    def get_subquery_sql(self):
        return self.result_sql

class NestedSubqueryItem(QGraphicsRectItem):
    def __init__(self, parent_builder=None, x=0, y=0):
        super().__init__(0,0,220,80)
        self.setPos(x,y)
        self.setBrush(QBrush(QColor(200,255,200)))
        self.setPen(QPen(Qt.darkGreen,2))
        self.setFlags(QGraphicsItem.ItemIsMovable|QGraphicsItem.ItemIsSelectable)
        self.parent_builder=parent_builder
        self.subquery_sql="-- SubQuery"
        self.label=QGraphicsTextItem("Nested SubQuery\n(double-click)",self)
        self.label.setPos(5,5)
        f=QFont("Arial",9,QFont.Bold)
        self.label.setFont(f)

    def mouseDoubleClickEvent(self,event):
        dlg=NestedVQBDialog(existing_sql=self.subquery_sql, parent_builder=self.parent_builder)
        if dlg.exec_()==QDialog.Accepted:
            new_sql=dlg.get_subquery_sql()
            if new_sql:
                self.subquery_sql=new_sql
                self.label.setPlainText("Nested SubQuery\n(Has SQL)")
        event.accept()

    def contextMenuEvent(self,event):
        menu=QMenu()
        rm=menu.addAction("Remove SubQuery")
        chosen=menu.exec_(event.screenPos())
        if chosen==rm:
            sc=self.scene()
            if sc:
                sc.removeItem(self)

    def get_subquery_sql(self):
        return self.subquery_sql

class SubVQBDialog(QDialog):
    def __init__(self, parent_vqb=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Combine Query (Sub VQB)")
        self.resize(900,600)
        self.operator="UNION"
        self.second_sql=""
        self.parent_vqb=parent_vqb

        layout=QVBoxLayout(self)
        op_h=QHBoxLayout()
        op_h.addWidget(QLabel("Combine Operator:"))
        self.op_combo=QComboBox()
        self.op_combo.addItems(["UNION","UNION ALL","INTERSECT","EXCEPT"])
        op_h.addWidget(self.op_combo)
        op_h.addStretch()
        layout.addLayout(op_h)

        self.sub_vqb_edit=QTextEdit()
        layout.addWidget(self.sub_vqb_edit)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        op=self.op_combo.currentText()
        built_sql=self.sub_vqb_edit.toPlainText().strip()
        if not built_sql:
            QMessageBox.warning(self,"No Query","No sub query built.")
            return
        self.operator=op
        self.second_sql=built_sql
        self.accept()

    def getResult(self):
        return (self.operator,self.second_sql)

###############################################################################
# Data Profiler => min/max/avg + outlier boxplot
###############################################################################
class ProfilerChartCanvas(FigureCanvasQTAgg):
    def __init__(self, data_list, col_name="", parent=None):
        fig=Figure()
        super().__init__(fig)
        self.setParent(parent)
        self.axes=fig.add_subplot(111)
        self.data=data_list
        self.col_name=col_name
        self.plot_data()

    def plot_data(self):
        self.axes.clear()
        if not self.data:
            self.axes.text(0.5,0.5,"No numeric data",ha='center',va='center')
            self.draw()
            return
        self.axes.boxplot(self.data,labels=[self.col_name])
        self.axes.set_title(f"Outlier Chart: {self.col_name}")
        self.draw()

class DataProfilerDialog(QDialog):
    def __init__(self, table_key, columns, connection, parent=None):
        super().__init__(parent)
        self.table_key=table_key
        self.columns=columns
        self.connection=connection
        self.setWindowTitle(f"Data Profiler - {table_key}")
        self.resize(900,500)

        main=QVBoxLayout(self)
        info=QLabel(
            f"Profiling {table_key} => COUNT(*), DISTINCT, MIN, MAX, AVG => 'ERR' on fail.\n"
            "Use 'Outlier Chart' for numeric columns."
        )
        main.addWidget(info)

        self.prof_table=QTableWidget(0,7)
        self.prof_table.setHorizontalHeaderLabels(["Column","COUNT","DISTINCT","MIN","MAX","AVG","Error"])
        main.addWidget(self.prof_table)

        btn_h=QHBoxLayout()
        chart_btn=QPushButton("Outlier Chart")
        chart_btn.clicked.connect(self.show_outlier_chart)
        close_btn=QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        btn_h.addWidget(chart_btn)
        btn_h.addStretch()
        btn_h.addWidget(close_btn)
        main.addLayout(btn_h)

        self.setLayout(main)
        self.run_profiler()

    def run_profiler(self):
        if not self.connection:
            QMessageBox.warning(self,"No Connection","No DB connection for profiling.")
            return
        c=self.connection.cursor()
        self.prof_table.setRowCount(0)

        # We'll do a single COUNT(*) once at top to avoid repeated queries
        # for demonstration, though not perfect for large DBs
        total_count="(unknown)"
        try:
            c.execute(f"SELECT COUNT(*) FROM {self.table_key}")
            rr=c.fetchone()
            if rr:
                total_count=str(rr[0])
        except:
            pass

        for col in self.columns:
            short_col=col.split(".")[-1]
            r_idx=self.prof_table.rowCount()
            self.prof_table.insertRow(r_idx)
            self.prof_table.setItem(r_idx,0,QTableWidgetItem(short_col))

            # COUNT(*)
            co_val = total_count  # reuse from above
            if not total_count:
                co_val="ERR"
            self.prof_table.setItem(r_idx,1,QTableWidgetItem(co_val))

            # DISTINCT
            dist_val=""
            try:
                c.execute(f"SELECT COUNT(DISTINCT {short_col}) FROM {self.table_key}")
                rr=c.fetchone()
                dist_val=str(rr[0]) if rr else "0"
            except Exception as ex:
                dist_val=f"ERR({ex})"
            self.prof_table.setItem(r_idx,2,QTableWidgetItem(dist_val))

            minv,maxv,avgv="N/A","N/A","N/A"
            err_msg=""
            try:
                c.execute(f"SELECT MIN({short_col}), MAX({short_col}), AVG({short_col}) FROM {self.table_key}")
                r=c.fetchone()
                if r:
                    if r[0] is not None: minv=str(r[0])
                    else: minv="NULL"
                    if r[1] is not None: maxv=str(r[1])
                    else: maxv="NULL"
                    if r[2] is not None: avgv=str(r[2])
                    else: avgv="NULL"
            except Exception as ex:
                minv="ERR"
                maxv="ERR"
                avgv="ERR"
                err_msg=str(ex)

            self.prof_table.setItem(r_idx,3,QTableWidgetItem(minv))
            self.prof_table.setItem(r_idx,4,QTableWidgetItem(maxv))
            self.prof_table.setItem(r_idx,5,QTableWidgetItem(avgv))
            self.prof_table.setItem(r_idx,6,QTableWidgetItem(err_msg))

    def show_outlier_chart(self):
        rows=self.prof_table.selectionModel().selectedRows()
        if not rows:
            QMessageBox.information(self,"No Selection","Pick a row first.")
            return
        row_idx=rows[0].row()
        col_name=self.prof_table.item(row_idx,0).text()

        data_list=[]
        try:
            c=self.connection.cursor()
            sql=f"SELECT {col_name} FROM {self.table_key} WHERE {col_name} IS NOT NULL"
            c.execute(sql)
            rr=c.fetchall()
            for r in rr:
                val=r[0]
                fval=float(val)
                data_list.append(fval)
        except Exception as ex:
            QMessageBox.warning(self,"Outlier Error",f"Could not fetch numeric data:\n{ex}")
            return

        if not data_list:
            QMessageBox.information(self,"No Data","No numeric data or table is empty.")
            return

        d=QDialog(self)
        d.setWindowTitle(f"Outlier Chart: {col_name}")
        d.resize(600,400)
        lay=QVBoxLayout(d)
        canvas=ProfilerChartCanvas(data_list,col_name,d)
        lay.addWidget(canvas)
        btns=QDialogButtonBox(QDialogButtonBox.Ok)
        lay.addWidget(btns)
        btns.accepted.connect(d.accept)
        d.setLayout(lay)
        d.exec_()

###############################################################################
# EnhancedCanvasGraphicsView => BFS
###############################################################################
class EnhancedCanvasGraphicsView(QGraphicsView):
    """
    The BFS canvas. No panning/zooming, but handles drag/drop from the schema tree.
    """
    def __init__(self, builder, parent=None):
        super().__init__(parent)
        self.builder=builder
        self.setAcceptDrops(True)

        self.scene_=QGraphicsScene(self)
        self.setScene(self.scene_)

        self.table_items={}
        self.join_lines=[]
        self.mapping_lines=[]
        self.operation_red_line=None
        self.collapsible_bfs_item=None
        self.target_table_item=None

        self.validation_timer=QTimer()
        self.validation_timer.setInterval(400)
        self.validation_timer.setSingleShot(True)
        self.validation_timer.timeout.connect(self.builder.validate_sql)

    def dragEnterEvent(self,e):
        if e.mimeData().hasText():
            e.acceptProposedAction()

    def dragMoveEvent(self,e):
        e.acceptProposedAction()

    def dropEvent(self,e):
        txt=e.mimeData().text()
        pos=self.mapToScene(e.pos())
        self.builder.handle_drop(txt,pos)
        e.acceptProposedAction()

    def add_table_item(self, table_key, columns, x, y):
        it=CollapsibleTableGraphicsItem(table_key, columns, self.builder, x, y)
        self.scene_.addItem(it)
        self.table_items[table_key]=it
        if self.builder.auto_generate:
            self.builder.generate_sql()
        self.validation_timer.start()

    def add_bfs_item(self, title, columns, x, y):
        bfs=CollapsibleBFSGraphicsItem(title, columns, self.builder, x, y)
        self.scene_.addItem(bfs)
        self.collapsible_bfs_item=bfs

    def add_target_item(self, title, columns, x, y):
        full="Target:"+title
        t=CollapsibleTableGraphicsItem(full, columns, self.builder, x, y)
        self.scene_.addItem(t)
        self.target_table_item=t

    def remove_table_item(self, table_key):
        if table_key in self.table_items:
            itm=self.table_items[table_key]
            lines_rm=[]
            for jl in self.join_lines:
                if jl.start_item==itm or jl.end_item==itm:
                    lines_rm.append(jl)
            for ln in lines_rm:
                self.scene_.removeItem(ln)
                self.join_lines.remove(ln)
            self.scene_.removeItem(itm)
            del self.table_items[table_key]
            self.validation_timer.start()
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_mapping_lines(self):
        for ml in self.mapping_lines:
            self.scene_.removeItem(ml)
        self.mapping_lines.clear()

    def add_vertical_red_line(self, x=450):
        if self.operation_red_line:
            self.scene_.removeItem(self.operation_red_line)
            self.operation_red_line=None
        ln=QGraphicsLineItem(x,0,x,3000)
        ln.setPen(QPen(Qt.red,2,Qt.DashDotLine))
        ln.setZValue(-10)
        self.scene_.addItem(ln)
        self.operation_red_line=ln

    def create_mapping_line(self, source_text_item, target_text_item, src_type=None, tgt_type=None):
        ml=MappingLine(source_text_item,target_text_item,self,src_type,tgt_type)
        self.scene_.addItem(ml)
        self.mapping_lines.append(ml)
        if self.builder.auto_generate:
            self.builder.generate_sql()
        self.validation_timer.start()

    def add_subquery_item(self, x, y):
        sq=NestedSubqueryItem(self.builder, x, y)
        self.scene_.addItem(sq)
        key=f"SubQueryItem_{id(sq)}"
        self.table_items[key]=sq
        self.validation_timer.start()

    def mouseReleaseEvent(self,event):
        super().mouseReleaseEvent(event)
        for jl in self.join_lines:
            jl.update_line()
        for ml in self.mapping_lines:
            ml.update_pos()

###############################################################################
# FilterPanel, GroupByPanel, Aggregates, SortLimitPanel
###############################################################################
class AddFilterDialog(QDialog):
    def __init__(self, available_columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Filter")
        self.selected_col=None
        self.selected_op=None
        self.selected_val=None

        layout=QFormLayout(self)
        self.col_combo=QComboBox()
        self.col_combo.addItems(available_columns)
        layout.addRow("Column:", self.col_combo)

        self.op_combo=QComboBox()
        self.op_combo.addItems(["=","<>","<",">","<=",">=","IS NULL","IS NOT NULL"])
        layout.addRow("Operator:", self.op_combo)

        self.val_edit=QLineEdit("'ABC'")
        layout.addRow("Value:", self.val_edit)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        c=self.col_combo.currentText()
        if not c:
            QMessageBox.warning(self,"No Column","Must pick a column.")
            return
        self.selected_col=c
        self.selected_op=self.op_combo.currentText()
        self.selected_val=self.val_edit.text().strip()
        self.accept()

    def get_filter(self):
        return (self.selected_col,self.selected_op,self.selected_val)

class FilterPanel(QGroupBox):
    def __init__(self,builder,parent=None):
        super().__init__("Filters",parent)
        self.builder=builder
        layout=QVBoxLayout(self)
        self.setLayout(layout)
        self.tabs=QTabWidget()
        layout.addWidget(self.tabs)

        self.where_tab=QWidget()
        self.having_tab=QWidget()
        self.tabs.addTab(self.where_tab,"WHERE")
        self.tabs.addTab(self.having_tab,"HAVING")

        self.where_layout=QVBoxLayout(self.where_tab)
        self.where_table=QTableWidget(0,3)
        self.where_table.setHorizontalHeaderLabels(["Column","Operator","Value"])
        self.where_table.horizontalHeader().setStretchLastSection(True)
        self.where_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.where_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.where_layout.addWidget(self.where_table)

        wh_btn=QHBoxLayout()
        add_w=QPushButton("Add WHERE")
        add_w.clicked.connect(lambda: self.add_filter("WHERE"))
        rm_w=QPushButton("Remove WHERE")
        rm_w.clicked.connect(lambda: self.remove_filter("WHERE"))
        wh_btn.addWidget(add_w)
        wh_btn.addWidget(rm_w)
        self.where_layout.addLayout(wh_btn)

        self.having_layout=QVBoxLayout(self.having_tab)
        self.having_table=QTableWidget(0,3)
        self.having_table.setHorizontalHeaderLabels(["Column","Operator","Value"])
        self.having_table.horizontalHeader().setStretchLastSection(True)
        self.having_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.having_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.having_layout.addWidget(self.having_table)

        hv_btn=QHBoxLayout()
        add_h=QPushButton("Add HAVING")
        add_h.clicked.connect(lambda: self.add_filter("HAVING"))
        rm_h=QPushButton("Remove HAVING")
        rm_h.clicked.connect(lambda: self.remove_filter("HAVING"))
        hv_btn.addWidget(add_h)
        hv_btn.addWidget(rm_h)
        self.having_layout.addLayout(hv_btn)

    def add_filter(self, clause):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No Columns","No columns available.")
            return
        dlg=AddFilterDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            c,o,v=dlg.get_filter()
            if clause=="WHERE":
                tb=self.where_table
            else:
                tb=self.having_table
            r=tb.rowCount()
            tb.insertRow(r)
            tb.setItem(r,0,QTableWidgetItem(c))
            tb.setItem(r,1,QTableWidgetItem(o))
            tb.setItem(r,2,QTableWidgetItem(v))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_filter(self, clause):
        if clause=="WHERE":
            tb=self.where_table
        else:
            tb=self.having_table
        rows=sorted([x.row() for x in tb.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            tb.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def get_filters(self, clause):
        if clause=="WHERE":
            tb=self.where_table
        else:
            tb=self.having_table
        arr=[]
        for r in range(tb.rowCount()):
            col=tb.item(r,0).text()
            op =tb.item(r,1).text()
            val=tb.item(r,2).text()
            arr.append((col,op,val))
        return arr

class GroupByPanel(QGroupBox):
    def __init__(self,builder,parent=None):
        super().__init__("Group By",parent)
        self.builder=builder
        layout=QVBoxLayout(self)
        self.setLayout(layout)

        self.gb_table=QTableWidget(0,1)
        self.gb_table.setHorizontalHeaderLabels(["GroupBy Column"])
        self.gb_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.gb_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.gb_table)

        gb_h=QHBoxLayout()
        add_gb=QPushButton("Add GroupBy")
        add_gb.clicked.connect(self.add_group_by)
        rm_gb=QPushButton("Remove GroupBy")
        rm_gb.clicked.connect(self.remove_group_by)
        gb_h.addWidget(add_gb)
        gb_h.addWidget(rm_gb)
        layout.addLayout(gb_h)

    def add_group_by(self):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No Columns","No columns available.")
            return
        c,ok=QtWidgets.QInputDialog.getItem(self,"Add GroupBy","Pick column:",cols,0,False)
        if ok and c:
            r=self.gb_table.rowCount()
            self.gb_table.insertRow(r)
            self.gb_table.setItem(r,0,QTableWidgetItem(c))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_group_by(self):
        rows=sorted([x.row() for x in self.gb_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            self.gb_table.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def get_group_by(self):
        arr=[]
        for r in range(self.gb_table.rowCount()):
            it=self.gb_table.item(r,0)
            arr.append(it.text())
        return arr

class GroupAggPanel(QGroupBox):
    def __init__(self,builder,parent=None):
        super().__init__("Aggregates",parent)
        self.builder=builder
        layout=QVBoxLayout(self)
        self.setLayout(layout)

        self.agg_table=QTableWidget(0,3)
        self.agg_table.setHorizontalHeaderLabels(["Function","Column","Alias"])
        self.agg_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.agg_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.agg_table)

        agg_h=QHBoxLayout()
        add_agg=QPushButton("Add Agg")
        add_agg.clicked.connect(self.add_agg)
        rm_agg=QPushButton("Remove Agg")
        rm_agg.clicked.connect(self.remove_agg)
        agg_h.addWidget(add_agg)
        agg_h.addWidget(rm_agg)
        layout.addLayout(agg_h)

    def add_agg(self):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No cols","No columns available.")
            return
        d=QDialog(self.builder)
        d.setWindowTitle("Add Aggregate")
        fl=QFormLayout(d)
        func_cb=QComboBox()
        func_cb.addItems(["COUNT","SUM","AVG","MIN","MAX","CUSTOM"])
        col_cb=QComboBox()
        col_cb.addItems(cols)
        alias_ed=QLineEdit("AggVal")
        fl.addRow("Function:",func_cb)
        fl.addRow("Column:",col_cb)
        fl.addRow("Alias:",alias_ed)
        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(btns)
        def on_ok():
            if not col_cb.currentText() and func_cb.currentText()!="CUSTOM":
                QMessageBox.warning(d,"Error","Pick a column or use CUSTOM.")
                return
            d.accept()
        btns.accepted.connect(on_ok)
        btns.rejected.connect(d.reject)
        d.setLayout(fl)
        if d.exec_()==QDialog.Accepted:
            f=func_cb.currentText()
            c=col_cb.currentText()
            a=alias_ed.text().strip()
            r=self.agg_table.rowCount()
            self.agg_table.insertRow(r)
            self.agg_table.setItem(r,0,QTableWidgetItem(f))
            self.agg_table.setItem(r,1,QTableWidgetItem(c))
            self.agg_table.setItem(r,2,QTableWidgetItem(a))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_agg(self):
        rows=sorted([x.row() for x in self.agg_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            self.agg_table.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def get_aggregates(self):
        ags=[]
        for r in range(self.agg_table.rowCount()):
            f=self.agg_table.item(r,0).text()
            c=self.agg_table.item(r,1).text()
            a=self.agg_table.item(r,2).text()
            ags.append((f,c,a))
        return ags

class SortLimitPanel(QGroupBox):
    def __init__(self,builder,parent=None):
        super().__init__("Sort & Limit",parent)
        self.builder=builder
        layout=QVBoxLayout(self)
        self.setLayout(layout)

        self.sort_table=QTableWidget(0,2)
        self.sort_table.setHorizontalHeaderLabels(["Column","Direction"])
        self.sort_table.horizontalHeader().setStretchLastSection(True)
        self.sort_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.sort_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        layout.addWidget(self.sort_table)

        btn_h=QHBoxLayout()
        add_s=QPushButton("Add Sort")
        add_s.clicked.connect(self.add_sort_dialog)
        rm_s=QPushButton("Remove Sort")
        rm_s.clicked.connect(self.remove_sort)
        btn_h.addWidget(add_s)
        btn_h.addWidget(rm_s)
        layout.addLayout(btn_h)

        lo_h=QHBoxLayout()
        self.limit_spin=QSpinBox()
        self.limit_spin.setRange(0,9999999)
        self.limit_spin.setValue(0)
        self.limit_spin.setSuffix(" (Limit)")
        self.limit_spin.setSpecialValueText("No Limit")
        self.limit_spin.valueChanged.connect(self._maybe_regen)
        lo_h.addWidget(self.limit_spin)

        self.offset_spin=QSpinBox()
        self.offset_spin.setRange(0,9999999)
        self.offset_spin.setValue(0)
        self.offset_spin.setSuffix(" (Offset)")
        self.offset_spin.setSpecialValueText("No Offset")
        self.offset_spin.valueChanged.connect(self._maybe_regen)
        lo_h.addWidget(self.offset_spin)
        layout.addLayout(lo_h)

    def _maybe_regen(self):
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def add_sort_dialog(self):
        cols=self.builder.get_all_possible_columns_for_dialog()
        if not cols:
            QMessageBox.warning(self,"No columns","No columns available.")
            return
        d=QDialog(self)
        d.setWindowTitle("Add Sort")
        fl=QFormLayout(d)
        col_cb=QComboBox()
        col_cb.addItems(cols)
        dir_cb=QComboBox()
        dir_cb.addItems(["ASC","DESC"])
        fl.addRow("Column:",col_cb)
        fl.addRow("Direction:",dir_cb)
        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        fl.addWidget(btns)
        def on_ok():
            if not col_cb.currentText():
                QMessageBox.warning(d,"No col","Pick a column.")
                return
            d.accept()
        btns.accepted.connect(on_ok)
        btns.rejected.connect(d.reject)
        d.setLayout(fl)
        if d.exec_()==QDialog.Accepted:
            c=col_cb.currentText()
            dd=dir_cb.currentText()
            row=self.sort_table.rowCount()
            self.sort_table.insertRow(row)
            self.sort_table.setItem(row,0,QTableWidgetItem(c))
            self.sort_table.setItem(row,1,QTableWidgetItem(dd))
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def remove_sort(self):
        rows=sorted([x.row() for x in self.sort_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            self.sort_table.removeRow(rr)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def get_order_bys(self):
        arr=[]
        for r in range(self.sort_table.rowCount()):
            col=self.sort_table.item(r,0).text()
            dr=self.sort_table.item(r,1).text()
            arr.append(f"{col} {dr}")
        return arr

    def get_limit(self):
        v=self.limit_spin.value()
        return v if v>0 else None

    def get_offset(self):
        v=self.offset_spin.value()
        return v if v>0 else None

###############################################################################
# Advanced Expression Builder => token-based, CASE wizard, subquery insertion
###############################################################################
class CaseWizardDialog(QDialog):
    def __init__(self, available_columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("CASE Wizard")
        self.resize(500, 400)
        self.available_columns = available_columns

        self.when_clauses = []  # list of (condition, result)
        self.else_expr = ""

        main_layout = QVBoxLayout(self)

        self.case_preview = QTextEdit()
        self.case_preview.setReadOnly(True)
        main_layout.addWidget(self.case_preview)

        btn_h = QHBoxLayout()
        add_btn = QPushButton("Add WHEN")
        add_btn.clicked.connect(self.on_add_when)
        remove_btn = QPushButton("Remove WHEN")
        remove_btn.clicked.connect(self.on_remove_when)
        btn_h.addWidget(add_btn)
        btn_h.addWidget(remove_btn)
        main_layout.addLayout(btn_h)

        else_h = QHBoxLayout()
        else_h.addWidget(QLabel("ELSE:"))
        self.else_edit = QLineEdit()
        else_h.addWidget(self.else_edit)
        main_layout.addLayout(else_h)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        main_layout.addWidget(dbb)

        self.setLayout(main_layout)
        self.update_preview()

    def on_add_when(self):
        cond, ok = QtWidgets.QInputDialog.getText(self, "Add WHEN condition",
                                        "Enter condition (e.g. colA = 100):")
        if not ok or not cond.strip():
            return
        res, ok2 = QtWidgets.QInputDialog.getText(self, "Add THEN result",
                                        "Enter result (e.g. 'High'):")
        if not ok2:
            return
        self.when_clauses.append((cond.strip(), res.strip()))
        self.update_preview()

    def on_remove_when(self):
        if self.when_clauses:
            self.when_clauses.pop()
        self.update_preview()

    def update_preview(self):
        txt = "CASE\n"
        for (c, r) in self.when_clauses:
            txt += f"  WHEN {c} THEN {r}\n"
        if self.else_expr.strip():
            txt += f"  ELSE {self.else_expr}\n"
        txt += "END"
        self.case_preview.setPlainText(txt)

    def on_ok(self):
        self.else_expr = self.else_edit.text().strip()
        self.update_preview()
        self.accept()

    def get_case_expression(self):
        lines = ["CASE"]
        for (c, r) in self.when_clauses:
            lines.append(f"  WHEN {c} THEN {r}")
        if self.else_expr.strip():
            lines.append(f"  ELSE {self.else_expr}")
        lines.append("END")
        return "\n".join(lines)

class SubqueryStubDialog(QDialog):
    """
    Minimal subquery insertion. You could integrate a full SubVQBDialog instead.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Subquery Editor")
        self.resize(600, 400)
        self.result_sql = ""

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Type a single-column SELECT subquery:"))
        self.subq_edit = QTextEdit()
        layout.addWidget(self.subq_edit)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        layout.addWidget(dbb)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        raw = self.subq_edit.toPlainText().strip()
        if not raw.lower().startswith("select"):
            QMessageBox.warning(self, "No SELECT", "Must start with SELECT.")
            return
        self.result_sql = f"({raw})"
        self.accept()

    def get_subquery(self):
        return self.result_sql

class ExprTokenWidget(QFrame):
    def __init__(self, token_text, parent=None):
        super().__init__(parent)
        self.token_text = token_text
        self.setFrameShape(QFrame.Box)
        self.setLineWidth(1)
        self.setStyleSheet("background-color: #f0f0f0;")
        lay = QHBoxLayout(self)
        self.lbl = QLabel(token_text)
        self.lbl.setStyleSheet("padding: 2px;")
        lay.addWidget(self.lbl)
        self.setLayout(lay)

    def contextMenuEvent(self, event):
        menu = QMenu(self)
        rm_act = menu.addAction("Remove Token")
        chosen = menu.exec_(event.globalPos())
        if chosen == rm_act:
            self.setParent(None)

class TokenFlowArea(QWidget):
    """
    A horizontal flow of tokens (QFrame items) for building an expression
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.main_layout = QHBoxLayout(self)
        self.main_layout.addStretch()
        self.setLayout(self.main_layout)

    def add_token(self, token_str):
        tw = ExprTokenWidget(token_str, self)
        idx = self.main_layout.count() - 1
        self.main_layout.insertWidget(idx, tw)

    def get_token_list(self):
        tokens = []
        for i in range(self.main_layout.count()):
            w = self.main_layout.itemAt(i).widget()
            if isinstance(w, ExprTokenWidget):
                tokens.append(w.token_text)
        return tokens

class AdvancedExpressionBuilderDialog(QDialog):
    """
    The advanced expression builder with:
      - Token palette
      - Column list
      - TokenFlowArea for expression
      - CASE wizard, Subquery insertion
      - Real-time parse check (sqlparse)
      - Optional alias
    """
    def __init__(self, available_columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Advanced Expression Builder (Tokens + Wizards)")
        self.resize(900, 600)
        self.available_columns = available_columns or []

        self.main_layout = QHBoxLayout(self)
        self.setLayout(self.main_layout)

        # left side: columns + palette
        left_panel = QVBoxLayout()
        self.column_list = QListWidget()
        for c in self.available_columns:
            self.column_list.addItem(c)
        self.column_list.itemDoubleClicked.connect(self.on_column_dblclick)
        left_panel.addWidget(QLabel("Columns (double-click to insert):"))
        left_panel.addWidget(self.column_list, stretch=1)

        self.palette_list = QListWidget()
        palette_items = [
            "(", ")", "+", "-", "*", "/", "=",
            "<", ">", "<=", ">=", "<>", "AND", "OR", "NOT",
            "LIKE", "IN", "IS NULL", "IS NOT NULL",
            "SUM(", "AVG(", "MIN(", "MAX(", "COUNT(",
            "UPPER(", "LOWER(", "TRIM(", "COALESCE(",
            "CASE (Wizard)", "SUBQUERY"
        ]
        for it in palette_items:
            self.palette_list.addItem(it)
        self.palette_list.itemDoubleClicked.connect(self.on_palette_dblclick)
        left_panel.addWidget(QLabel("Operators / Functions:"))
        left_panel.addWidget(self.palette_list, stretch=1)

        left_panel.addWidget(QLabel("Double-click to insert tokens.\n"
                                    "'CASE (Wizard)' => CASE wizard.\n"
                                    "'SUBQUERY' => subquery.\n"
                                    "For functions like SUM(, add a ) token yourself."))

        left_container = QWidget()
        left_container.setLayout(left_panel)
        self.main_layout.addWidget(left_container, 2)

        # center
        center_panel = QVBoxLayout()
        self.token_flow = TokenFlowArea()
        center_panel.addWidget(QLabel("Expression Tokens:"))
        center_panel.addWidget(self.token_flow, stretch=1)

        self.syntax_label = QLabel("Syntax OK or not?")
        center_panel.addWidget(self.syntax_label)

        form = QFormLayout()
        self.alias_edit = QLineEdit()
        form.addRow("Alias (optional):", self.alias_edit)
        center_panel.addLayout(form)

        dbb = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        dbb.accepted.connect(self.on_ok)
        dbb.rejected.connect(self.reject)
        center_panel.addWidget(dbb)

        center_container = QWidget()
        center_container.setLayout(center_panel)
        self.main_layout.addWidget(center_container, 4)

    def on_column_dblclick(self, item):
        col_str = item.text()
        self.token_flow.add_token(col_str)
        self.do_parse_check()

    def on_palette_dblclick(self, item):
        txt = item.text()
        if txt == "CASE (Wizard)":
            cw = CaseWizardDialog(self.available_columns, self)
            if cw.exec_() == QDialog.Accepted:
                self.token_flow.add_token(cw.get_case_expression())
        elif txt == "SUBQUERY":
            sq = SubqueryStubDialog(self)
            if sq.exec_() == QDialog.Accepted:
                self.token_flow.add_token(sq.get_subquery())
        else:
            self.token_flow.add_token(txt)
        self.do_parse_check()

    def build_expression_string(self):
        tokens = self.token_flow.get_token_list()
        out=[]
        for t in tokens:
            if t.endswith("(") or t.startswith(")"):
                out.append(t)
            else:
                out.append(" "+t+" ")
        return "".join(out).strip()

    def do_parse_check(self):
        expr_str = self.build_expression_string()
        if not expr_str:
            self.syntax_label.setText("No expression.")
            self.syntax_label.setStyleSheet("color: black;")
            return
        try:
            st = sqlparse.parse(expr_str)
            if not st:
                raise ValueError("No parse result.")
            self.syntax_label.setText("Expression Syntax: OK")
            self.syntax_label.setStyleSheet("color: green;")
        except Exception as ex:
            self.syntax_label.setText(f"Expression Syntax: ERROR => {ex}")
            self.syntax_label.setStyleSheet("color: red;")

    def on_ok(self):
        expr_str=self.build_expression_string()
        if not expr_str.strip():
            QMessageBox.warning(self,"No Expression","Empty expression.")
            return
        self.accept()

    def get_expression_data(self):
        a=self.alias_edit.text().strip()
        return (a, self.build_expression_string())

###############################################################################
# Window Function Wizard
###############################################################################
class AdvancedWindowFunctionDialog(QDialog):
    def __init__(self, available_columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Advanced Window Function Wizard")
        self.resize(500,500)
        self.available_columns=available_columns
        self.function=""
        self.main_col=""
        self.partition_cols=[]
        self.order_cols=[]
        self.frame_clause=""
        self.offset=1
        self.default_val="0"
        self.buckets=4
        self.alias="winfun"

        main=QVBoxLayout(self)
        form=QFormLayout()

        self.func_cb=QComboBox()
        self.func_cb.addItems([
            "ROW_NUMBER","RANK","DENSE_RANK","NTILE","LAG","LEAD",
            "FIRST_VALUE","LAST_VALUE","SUM","AVG","MIN","MAX"
        ])
        form.addRow("Function:", self.func_cb)

        self.col_cb=QComboBox()
        self.col_cb.addItems(["(No specific col)"]+self.available_columns)
        form.addRow("Main Column:", self.col_cb)

        self.ntile_sb=QSpinBox()
        self.ntile_sb.setRange(2,999)
        self.ntile_sb.setValue(4)
        form.addRow("NTILE Buckets:", self.ntile_sb)

        self.offset_sb=QSpinBox()
        self.offset_sb.setRange(1,999)
        self.offset_sb.setValue(1)
        form.addRow("LAG/LEAD Offset:", self.offset_sb)

        self.default_ed=QLineEdit("0")
        form.addRow("LAG/LEAD Default:", self.default_ed)

        self.alias_ed=QLineEdit("winfun")
        form.addRow("Alias:", self.alias_ed)
        main.addLayout(form)

        main.addWidget(QLabel("Partition By (multi-select):"))
        self.part_list=QListWidget()
        self.part_list.setSelectionMode(QAbstractItemView.MultiSelection)
        self.part_list.addItems(self.available_columns)
        main.addWidget(self.part_list)

        main.addWidget(QLabel("Order By (multi-select):"))
        self.order_list=QListWidget()
        self.order_list.setSelectionMode(QAbstractItemView.MultiSelection)
        self.order_list.addItems(self.available_columns)
        main.addWidget(self.order_list)

        self.frame_ed=QLineEdit("ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW")
        main.addWidget(QLabel("Frame Clause (optional):"))
        main.addWidget(self.frame_ed)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        main.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(main)

    def on_ok(self):
        fn=self.func_cb.currentText()
        mc=self.col_cb.currentText()
        parts=[it.text() for it in self.part_list.selectedItems()]
        orders=[it.text() for it in self.order_list.selectedItems()]
        fr=self.frame_ed.text().strip()
        a=self.alias_ed.text().strip()
        offs=self.offset_sb.value()
        df=self.default_ed.text().strip()
        ntil=self.ntile_sb.value()
        if not a:
            QMessageBox.warning(self,"No alias","Alias needed.")
            return
        self.function=fn
        if mc!="(No specific col)":
            self.main_col=mc
        self.partition_cols=parts
        self.order_cols=orders
        self.frame_clause=fr
        self.alias=a
        self.offset=offs
        self.default_val=df
        self.buckets=ntil
        self.accept()

    def get_expression(self):
        parts=[]
        if self.partition_cols:
            parts.append("PARTITION BY "+", ".join(self.partition_cols))
        if self.order_cols:
            parts.append("ORDER BY "+", ".join(self.order_cols))
        if self.frame_clause:
            parts.append(self.frame_clause)
        inside="()"
        if parts:
            inside="("+ " ".join(parts) +")"

        fn=self.function.upper()
        col = self.main_col if self.main_col else "0"
        if fn in ["ROW_NUMBER","RANK","DENSE_RANK"]:
            return f"{fn}() OVER {inside} AS {self.alias}"
        elif fn=="NTILE":
            return f"NTILE({self.buckets}) OVER {inside} AS {self.alias}"
        elif fn in ["LAG","LEAD"]:
            return f"{fn}({col}, {self.offset}, {self.default_val}) OVER {inside} AS {self.alias}"
        elif fn in ["FIRST_VALUE","LAST_VALUE","SUM","AVG","MIN","MAX"]:
            return f"{fn}({col}) OVER {inside} AS {self.alias}"
        else:
            return f"ROW_NUMBER() OVER {inside} AS {self.alias}"

###############################################################################
# SQLImportTab => partial BFS rebuild with sqlglot
###############################################################################
class SQLImportTab(QWidget):
    def __init__(self,builder=None,parent=None):
        super().__init__(parent)
        self.builder=builder
        layout=QVBoxLayout(self)

        instruct=QLabel(
            "Paste or type your SQL, then click 'Import & Rebuild'.\n"
            "We'll parse with sqlglot. Complex queries might partially import."
        )
        layout.addWidget(instruct)

        self.sql_edit=QTextEdit()
        layout.addWidget(self.sql_edit)

        btn_h=QHBoxLayout()
        self.import_btn=QPushButton("Import & Rebuild")
        self.import_btn.clicked.connect(self.on_import_rebuild)
        btn_h.addWidget(self.import_btn)
        layout.addLayout(btn_h)

        self.setLayout(layout)

    def on_import_rebuild(self):
        raw_sql=self.sql_edit.toPlainText().strip()
        if not raw_sql:
            QMessageBox.information(self,"Empty SQL","No SQL to parse.")
            return
        try:
            st=sqlparse.parse(raw_sql)
            if not st:
                QMessageBox.warning(self,"No valid SQL","sqlparse found no statements.")
                return
        except Exception as e:
            QMessageBox.warning(self,"Syntax Error",f"sqlparse error:\n{e}")
            return

        try:
            expr=sqlglot.parse_one(raw_sql)
        except Exception as ex:
            QMessageBox.warning(self,"sqlglot Parse Error",f"Could not parse SQL:\n{ex}")
            return

        self.builder.import_and_rebuild_canvas(expr, raw_sql)
        QMessageBox.information(self,"Import OK","Canvas has been rebuilt from the SQL.")

###############################################################################
# CTE Panel => "virtual tables" BFS
###############################################################################
class CTEDialog(QDialog):
    def __init__(self, parent_builder, existing_name="", existing_sql="", parent=None):
        super().__init__(parent)
        self.setWindowTitle("Define CTE")
        self.resize(900,600)
        self.builder_ref=parent_builder
        self.cte_name=existing_name
        self.cte_sql=existing_sql

        layout=QVBoxLayout(self)
        form=QFormLayout()
        self.name_edit=QLineEdit(self.cte_name)
        form.addRow("CTE Name:", self.name_edit)
        layout.addLayout(form)

        self.sub_vqb_edit=QTextEdit()
        self.sub_vqb_edit.setPlainText(self.cte_sql)
        layout.addWidget(self.sub_vqb_edit)

        btns=QDialogButtonBox(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        layout.addWidget(btns)
        btns.accepted.connect(self.on_ok)
        btns.rejected.connect(self.reject)
        self.setLayout(layout)

    def on_ok(self):
        nm=self.name_edit.text().strip()
        if not nm:
            QMessageBox.warning(self,"No name","CTE name cannot be empty.")
            return
        raw_sql=self.sub_vqb_edit.toPlainText().strip()
        if not raw_sql:
            QMessageBox.warning(self,"No subquery","CTE SQL cannot be empty.")
            return
        self.cte_name=nm
        self.cte_sql=raw_sql
        self.accept()

    def get_cte_data(self):
        return (self.cte_name, self.cte_sql)

class CTEPanel(QGroupBox):
    def __init__(self, builder, parent=None):
        super().__init__("CTEs", parent)
        self.builder=builder
        self.cte_data=[]
        layout=QVBoxLayout(self)
        self.setLayout(layout)

        self.cte_table=QTableWidget(0,3)
        self.cte_table.setHorizontalHeaderLabels(["CTE Name","Sub-VQB","Preview"])
        self.cte_table.horizontalHeader().setSectionResizeMode(0,QHeaderView.ResizeToContents)
        self.cte_table.horizontalHeader().setSectionResizeMode(1,QHeaderView.ResizeToContents)
        self.cte_table.horizontalHeader().setSectionResizeMode(2,QHeaderView.Stretch)
        self.cte_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.cte_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        layout.addWidget(self.cte_table)

        btn_h=QHBoxLayout()
        add_btn=QPushButton("Add CTE")
        edit_btn=QPushButton("Edit CTE")
        remove_btn=QPushButton("Remove CTE")
        btn_h.addWidget(add_btn)
        btn_h.addWidget(edit_btn)
        btn_h.addWidget(remove_btn)
        btn_h.addStretch()
        layout.addLayout(btn_h)

        add_btn.clicked.connect(self.on_add_cte)
        edit_btn.clicked.connect(self.on_edit_cte)
        remove_btn.clicked.connect(self.on_remove_cte)

    def on_add_cte(self):
        dlg=CTEDialog(self.builder,"","",self)
        if dlg.exec_()==QDialog.Accepted:
            name,sql=dlg.get_cte_data()
            if name:
                self._add_cte_row(name,sql)
                self.builder.show_cte_as_virtual_table(name,["col1","col2"])
                if self.builder.auto_generate:
                    self.builder.generate_sql()

    def on_edit_cte(self):
        rows=self.cte_table.selectionModel().selectedRows()
        if not rows:
            QMessageBox.information(self,"No selection","Select a CTE row to edit.")
            return
        row_idx=rows[0].row()
        cur_name=self.cte_table.item(row_idx,0).text()
        cur_sql =self.cte_table.item(row_idx,2).text()

        dlg=CTEDialog(self.builder,cur_name,cur_sql,self)
        if dlg.exec_()==QDialog.Accepted:
            new_name,new_sql=dlg.get_cte_data()
            self.cte_table.setItem(row_idx,0,QTableWidgetItem(new_name))
            self.cte_table.setItem(row_idx,2,QTableWidgetItem(new_sql))
            self.cte_data[row_idx]['name']=new_name
            self.cte_data[row_idx]['sql']=new_sql
            if new_name!=cur_name:
                self.builder.remove_virtual_cte_table(cur_name)
            self.builder.show_cte_as_virtual_table(new_name,["col1","col2"])
            if self.builder.auto_generate:
                self.builder.generate_sql()

    def on_remove_cte(self):
        rows=sorted([r.row() for r in self.cte_table.selectionModel().selectedRows()],reverse=True)
        for rr in rows:
            nm=self.cte_table.item(rr,0).text()
            self.cte_table.removeRow(rr)
            del self.cte_data[rr]
            self.builder.remove_virtual_cte_table(nm)
        if self.builder.auto_generate:
            self.builder.generate_sql()

    def _add_cte_row(self, cte_name, cte_sql):
        row=self.cte_table.rowCount()
        self.cte_table.insertRow(row)
        self.cte_table.setItem(row,0,QTableWidgetItem(cte_name))
        self.cte_table.setItem(row,1,QTableWidgetItem("Use Edit CTE"))
        self.cte_table.setItem(row,2,QTableWidgetItem(cte_sql))
        self.cte_data.append({'name': cte_name, 'sql': cte_sql})

    def get_ctes(self):
        out=[]
        for r in range(self.cte_table.rowCount()):
            n=self.cte_table.item(r,0).text()
            s=self.cte_table.item(r,2).text()
            out.append((n,s))
        return out

###############################################################################
# ResultDataDialog => show query results
###############################################################################
class ResultDataDialog(QDialog):
    def __init__(self, rows, columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("SQL Results")
        self.resize(800,400)
        main=QVBoxLayout(self)
        tbl=QTableWidget(len(rows), len(columns))
        tbl.setHorizontalHeaderLabels(columns)
        for r_idx,rowval in enumerate(rows):
            for c_idx,val in enumerate(rowval):
                it=QTableWidgetItem(str(val))
                tbl.setItem(r_idx,c_idx,it)
        main.addWidget(tbl)
        btns=QDialogButtonBox(QDialogButtonBox.Ok)
        btns.accepted.connect(self.accept)
        main.addWidget(btns)
        self.setLayout(main)

###############################################################################
# The main VQB tab => merges all features
###############################################################################
class VisualQueryBuilderTab(QWidget):
    def __init__(self, multi_connections=None, linked_map=None, parent=None):
        super().__init__(parent)
        self.connections=multi_connections if multi_connections else {}
        self.linked_server_map=linked_map if linked_map else {}
        self.auto_generate=True
        self.operation_mode="SELECT"
        self.table_columns_map={}
        self.init_ui()
        self.threadpool=QThreadPool.globalInstance()

    def init_ui(self):
        main=QVBoxLayout(self)

        conn_h=QHBoxLayout()
        self.status_light=QFrame()
        self.status_light.setFixedSize(15,15)
        self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
        self.server_label=QLabel("Not Connected")
        conn_h.addWidget(self.status_light)
        conn_h.addWidget(self.server_label)

        self.auto_chk=QCheckBox("Auto-Generate")
        self.auto_chk.setChecked(True)
        self.auto_chk.stateChanged.connect(self.on_auto_gen_changed)
        conn_h.addWidget(self.auto_chk)
        conn_h.addStretch()
        main.addLayout(conn_h)

        tb_h=QHBoxLayout()
        subq_btn=QPushButton("Add SubQuery to Canvas")
        subq_btn.clicked.connect(self.add_subquery_to_canvas)
        tb_h.addWidget(subq_btn)

        expr_btn=QPushButton("Expression Builder")
        expr_btn.clicked.connect(self.launch_expr_builder)
        tb_h.addWidget(expr_btn)

        wfunc_btn=QPushButton("Window Function Wizard")
        wfunc_btn.clicked.connect(self.launch_window_func)
        tb_h.addWidget(wfunc_btn)

        comb_btn=QPushButton("Combine Query (Full Sub VQB)")
        comb_btn.clicked.connect(self.combine_with_subvqb)
        tb_h.addWidget(comb_btn)

        self.op_combo=QComboBox()
        self.op_combo.addItems(["SELECT","INSERT","UPDATE","DELETE"])
        self.op_combo.currentIndexChanged.connect(self.on_op_mode_changed)
        tb_h.addWidget(self.op_combo)

        tb_h.addStretch()
        main.addLayout(tb_h)

        self.tabs=QTabWidget()
        main.addWidget(self.tabs)

        self.schema_tab=QWidget()
        self.config_tab=QWidget()
        self.sql_tab=QWidget()
        self.import_tab=SQLImportTab(builder=self)

        self.tabs.addTab(self.schema_tab,"Schema & Canvas")
        self.tabs.addTab(self.config_tab,"Query Config")
        self.tabs.addTab(self.sql_tab,"SQL Preview")
        self.tabs.addTab(self.import_tab,"SQL Import")

        self.status_bar=QStatusBar()
        main.addWidget(self.status_bar)
        self.setLayout(main)

        self.setup_schema_tab()
        self.setup_config_tab()
        self.setup_sql_tab()

    def setup_schema_tab(self):
        lay=QVBoxLayout(self.schema_tab)
        self.search_ed=QLineEdit()
        self.search_ed.setPlaceholderText("Filter in the schema tree...")
        self.search_ed.textChanged.connect(self.on_schema_filter)
        lay.addWidget(self.search_ed)

        splitter=QSplitter(Qt.Horizontal)
        self.schema_tree=MultiDBLazySchemaTreeWidget(self.connections, parent_builder=self)
        leftp=QWidget()
        lp=QVBoxLayout(leftp)
        lp.addWidget(self.schema_tree)
        splitter.addWidget(leftp)

        self.canvas=EnhancedCanvasGraphicsView(self)
        splitter.addWidget(self.canvas)
        splitter.setStretchFactor(0,1)
        splitter.setStretchFactor(1,3)
        lay.addWidget(splitter)

        self.progress=QProgressBar()
        self.progress.setVisible(False)
        lay.addWidget(self.progress)

    def setup_config_tab(self):
        h=QHBoxLayout(self.config_tab)

        self.cte_panel=CTEPanel(self)
        h.addWidget(self.cte_panel,2)

        self.filter_panel=FilterPanel(self)
        h.addWidget(self.filter_panel,2)

        group_vbox=QVBoxLayout()
        self.group_panel=GroupByPanel(self)
        self.agg_panel=GroupAggPanel(self)
        group_vbox.addWidget(self.group_panel)
        group_vbox.addWidget(self.agg_panel)
        grp_container=QWidget()
        grp_container.setLayout(group_vbox)
        h.addWidget(grp_container,3)

        self.sort_panel=SortLimitPanel(self)
        h.addWidget(self.sort_panel,2)
        self.config_tab.setLayout(h)

    def setup_sql_tab(self):
        lay=QVBoxLayout(self.sql_tab)
        top_h=QHBoxLayout()
        top_h.addWidget(QLabel("Generated SQL:"))
        run_btn=QPushButton("Run SQL")
        run_btn.clicked.connect(self.run_sql)
        top_h.addWidget(run_btn,alignment=Qt.AlignRight)
        lay.addLayout(top_h)

        self.sql_display=QTextEdit()
        self.sql_display.setReadOnly(False)
        self.sql_highlighter=SQLHighlighter(self.sql_display.document())
        lay.addWidget(self.sql_display)

        self.validation_lbl=QLabel("SQL Status: Unknown")
        lay.addWidget(self.validation_lbl)

        prof_btn=QPushButton("Data Profiler")
        prof_btn.clicked.connect(self.launch_data_profiler)
        lay.addWidget(prof_btn,alignment=Qt.AlignRight)

        self.sql_tab.setLayout(lay)

    def set_connections(self, conns):
        self.connections=conns
        if conns:
            self.update_conn_status(True,"Multiple DBs connected")
        else:
            self.update_conn_status(False,"No Connections")
        self.schema_tree.connections=conns
        self.schema_tree.populate_roots()

    def set_federation_map(self,newmap):
        self.linked_server_map=newmap

    def update_conn_status(self, st, info=""):
        if st:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: green;}")
            self.server_label.setText(info)
        else:
            self.status_light.setStyleSheet("QFrame { border-radius:7px; background-color: red;}")
            self.server_label.setText("Not Connected")

    def on_schema_filter(self, txt):
        def filter_item(it, text):
            show=False
            if text.lower() in it.text(0).lower():
                show=True
            for c in range(it.childCount()):
                if filter_item(it.child(c), text):
                    show=True
            it.setHidden(not show)
            return show
        for i in range(self.schema_tree.topLevelItemCount()):
            topi=self.schema_tree.topLevelItem(i)
            filter_item(topi, txt)

    def on_auto_gen_changed(self, st):
        self.auto_generate=(st==Qt.Checked)

    def on_op_mode_changed(self, idx):
        modes=["SELECT","INSERT","UPDATE","DELETE"]
        self.operation_mode=modes[idx]
        self.toggle_dml_canvas()
        if self.auto_generate:
            self.generate_sql()

    def add_subquery_to_canvas(self):
        self.canvas.add_subquery_item(200,200)
        if self.auto_generate:
            self.generate_sql()

    def launch_expr_builder(self):
        cols=self.get_all_possible_columns_for_dialog()
        dlg=AdvancedExpressionBuilderDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            alias,expr=dlg.get_expression_data()
            old=self.sql_display.toPlainText().strip()
            if alias:
                new_part=f"({expr}) AS {alias}"
            else:
                new_part=expr
            self.sql_display.setPlainText(old+"\n-- Derived expression:\n"+new_part)
            self.validate_sql()

    def launch_window_func(self):
        cols=self.get_all_possible_columns_for_dialog()
        dlg=AdvancedWindowFunctionDialog(cols,self)
        if dlg.exec_()==QDialog.Accepted:
            expression=dlg.get_expression()
            old=self.sql_display.toPlainText()
            self.sql_display.setPlainText(old+f"\n-- WindowFunc:\n{expression}")
            self.validate_sql()

    def combine_with_subvqb(self):
        d=SubVQBDialog(parent_vqb=self,parent=self)
        if d.exec_()==QDialog.Accepted:
            op, second_sql=d.getResult()
            old=self.sql_display.toPlainText().strip()
            if old:
                new_sql=old+f"\n{op}\n(\n{second_sql}\n)"
            else:
                new_sql=f"{op}\n(\n{second_sql}\n)"
            self.sql_display.setPlainText(new_sql)
            self.validate_sql()

    def launch_data_profiler(self):
        real_tables=[]
        for k,v in self.canvas.table_items.items():
            if hasattr(v,"columns") and not k.startswith("SubQueryItem_") \
               and not k.startswith("BFS") and not k.startswith("Target:") \
               and not k.startswith("CTE."):
                real_tables.append(k)
        if not real_tables:
            QMessageBox.information(self,"No Table","No real table items on BFS to profile.")
            return
        chosen,ok=QtWidgets.QInputDialog.getItem(
            self,"Pick Table","Choose a table to profile:",real_tables,0,False
        )
        if not ok or not chosen:
            return
        titem=self.canvas.table_items.get(chosen)
        if not titem or not hasattr(titem,"columns"):
            QMessageBox.information(self,"No columns?","That BFS item has no columns to profile.")
            return
        alias=chosen.split(".")[0]
        conn=None
        if alias in self.connections:
            conn=self.connections[alias]["connection"]
        if not conn:
            QMessageBox.warning(self,"No Connection","No DB connection found for that table.")
            return
        colkeys=[]
        for c in titem.columns:
            colkeys.append(f"{chosen}.{c}")

        d=DataProfilerDialog(chosen,colkeys,conn,self)
        d.exec_()

    def run_sql(self):
        sql=self.sql_display.toPlainText().strip()
        if not sql:
            QMessageBox.information(self,"Empty SQL","No SQL to run.")
            return
        if not self.connections:
            QMessageBox.information(self,"No Connections","No DB connection found.")
            return
        first_key=list(self.connections.keys())[0]
        conn=self.connections[first_key]["connection"]
        if not conn:
            QMessageBox.warning(self,"No Conn","Connection invalid.")
            return
        try:
            c=conn.cursor()
            c.execute(sql)
            rows=c.fetchall()
            cols=[desc[0] for desc in c.description] if c.description else []
            dlg=ResultDataDialog(rows,cols,self)
            dlg.exec_()
        except Exception as ex:
            QMessageBox.warning(self,"SQL Error",f"Failed:\n{ex}")

    def get_all_possible_columns_for_dialog(self):
        arr=[]
        for k,v in self.canvas.table_items.items():
            if hasattr(v,"columns"):
                for c in v.columns:
                    arr.append(f"{k}.{c}")
        if self.canvas.collapsible_bfs_item:
            for c in self.canvas.collapsible_bfs_item.columns:
                arr.append(f"BFS.{c}")
        return arr

    def toggle_dml_canvas(self):
        if self.operation_mode=="SELECT":
            self.canvas.remove_mapping_lines()
            if self.canvas.operation_red_line:
                self.canvas.scene_.removeItem(self.canvas.operation_red_line)
                self.canvas.operation_red_line=None
            if self.canvas.collapsible_bfs_item:
                self.canvas.scene_.removeItem(self.canvas.collapsible_bfs_item)
                self.canvas.collapsible_bfs_item=None
            if self.canvas.target_table_item:
                self.canvas.scene_.removeItem(self.canvas.target_table_item)
                self.canvas.target_table_item=None
        else:
            self.canvas.add_vertical_red_line(450)
            if not self.canvas.collapsible_bfs_item:
                bfsCols=["srcCol1","srcCol2","key"]
                bfs=CollapsibleBFSGraphicsItem("BFS Source",bfsCols,self,50,100)
                self.canvas.scene_.addItem(bfs)
                self.canvas.collapsible_bfs_item=bfs
            if not self.canvas.target_table_item:
                targCols=["colA","colB","key"]
                targ=CollapsibleTableGraphicsItem("Target:db.tbl",targCols,self,600,100)
                self.canvas.scene_.addItem(targ)
                self.canvas.target_table_item=targ

    def generate_sql(self):
        if not self.auto_generate:
            return
        if self.operation_mode=="INSERT":
            body=self._generate_insert()
        elif self.operation_mode=="UPDATE":
            body=self._generate_update()
        elif self.operation_mode=="DELETE":
            body=self._generate_delete()
        else:
            body=self._generate_select()

        ctes=self.cte_panel.get_ctes()
        if ctes:
            cparts=[]
            for (n,s) in ctes:
                cparts.append(f"{n} AS (\n{s}\n)")
            cblock="WITH "+",\n    ".join(cparts)+"\n"
            final_sql=cblock+body
        else:
            final_sql=body
        self.sql_display.setPlainText(final_sql)
        self.validate_sql()

    def validate_sql(self):
        txt=self.sql_display.toPlainText().strip()
        if not txt:
            self.validation_lbl.setText("SQL Status: No SQL.")
            self.validation_lbl.setStyleSheet("color:orange;")
            return
        try:
            parser=FullSQLParser(txt)
            parser.parse()
            self.validation_lbl.setText("SQL Status: Valid.")
            self.validation_lbl.setStyleSheet("color:green;")
        except Exception as ex:
            self.validation_lbl.setText(f"SQL Status: Invalid - {ex}")
            self.validation_lbl.setStyleSheet("color:red;")

    def import_and_rebuild_canvas(self, root_expr, full_sql):
        # Clear BFS items, lines, filters, groups, sorts, ctes
        for k in list(self.canvas.table_items.keys()):
            self.canvas.remove_table_item(k)
        self.canvas.remove_mapping_lines()

        while self.filter_panel.where_table.rowCount()>0:
            self.filter_panel.where_table.removeRow(0)
        while self.filter_panel.having_table.rowCount()>0:
            self.filter_panel.having_table.removeRow(0)

        while self.group_panel.gb_table.rowCount()>0:
            self.group_panel.gb_table.removeRow(0)
        while self.agg_panel.agg_table.rowCount()>0:
            self.agg_panel.agg_table.removeRow(0)

        while self.sort_panel.sort_table.rowCount()>0:
            self.sort_panel.sort_table.removeRow(0)
        self.sort_panel.limit_spin.setValue(0)
        self.sort_panel.offset_spin.setValue(0)

        while self.cte_panel.cte_table.rowCount()>0:
            self.cte_panel.cte_table.removeRow(0)
        self.cte_panel.cte_data.clear()

        main_expr=root_expr
        if root_expr.key=="WITH":
            cte_exps=root_expr.args.get("expressions") or []
            for cexp in cte_exps:
                cName=cexp.alias
                cSelect=cexp.this
                cSQL=cSelect.sql()
                self.cte_panel._add_cte_row(cName,cSQL)
            main_expr=root_expr.this

        # If it's not a simple SELECT, we won't attempt BFS reconstruction
        if not isinstance(main_expr, exp.Select):
            self.sql_display.setPlainText(full_sql)
            self.validate_sql()
            return

        self.sql_display.setPlainText(full_sql)
        self.validate_sql()
        # Additional BFS reconstruction logic can go here if desired.

    def _transform_table_key_for_federation(self, table_key):
        parts=table_key.split(".")
        if len(parts)<3:
            return table_key
        alias=parts[0]
        ls=self.linked_server_map.get(alias,None)
        if not ls:
            return table_key
        dbName=parts[1]
        tblName=parts[2]
        # rewrite to [ls].[dbName].dbo.[tblName]
        return f"[{ls}].[{dbName}].dbo.[{tblName}]"

    def _build_bfs_from(self):
        invert={v:k for k,v in self.canvas.table_items.items()}
        adj={}
        for k in self.canvas.table_items.keys():
            adj[k]=[]
        for jl in self.canvas.join_lines:
            s=invert.get(jl.start_item,None)
            e=invert.get(jl.end_item,None)
            if s and e:
                adj[s].append((e,jl))
                adj[e].append((s,jl))
        visited=set()
        blocks=[]
        for root in adj:
            if root not in visited:
                queue=[root]
                visited.add(root)
                seg=[root]
                while queue:
                    node=queue.pop(0)
                    for (nbr,ln) in adj[node]:
                        if nbr not in visited:
                            visited.add(nbr)
                            queue.append(nbr)
                            seg.append(f"{ln.join_type} JOIN {nbr} ON {ln.condition}")
                block="\n  ".join(seg)
                if not blocks:
                    blocks.append("FROM "+block)
                else:
                    blocks.append("-- Another subgraph:\nFROM "+block)
        if not blocks:
            return "-- no tables on canvas"

        final_blocks=[]
        for blk in blocks:
            lines=blk.split("\n")
            newBlock=[]
            for line in lines:
                tokens=line.split()
                out=[]
                for t in tokens:
                    if t.count(".")>=2 and t.upper() not in ["FROM","JOIN","ON","INNER","LEFT","RIGHT","FULL"]:
                        newt=self._transform_table_key_for_federation(t)
                        out.append(newt)
                    else:
                        out.append(t)
                newBlock.append(" ".join(out))
            final_blocks.append("\n".join(newBlock))
        return "\n".join(final_blocks)

    def get_selected_columns(self):
        arr=[]
        for k,itm in self.canvas.table_items.items():
            if hasattr(itm,"get_selected_columns"):
                arr.extend(itm.get_selected_columns())
        if self.canvas.collapsible_bfs_item:
            bfs_cols=self.canvas.collapsible_bfs_item.get_checked_columns()
            arr.extend([f"BFS.{c}" for c in bfs_cols])
        return arr

    def _generate_select(self):
        scols=self.get_selected_columns()
        if not scols:
            scols=["*"]
        ags=self.agg_panel.get_aggregates()
        final_cols=list(scols)
        for (f,c,a) in ags:
            if f.upper()=="CUSTOM":
                final_cols.append(c)
            else:
                final_cols.append(f"{f}({c}) AS {a}")

        lines=[]
        lines.append("SELECT "+", ".join(final_cols))
        lines.append(self._build_bfs_from())
        wfs=self.filter_panel.get_filters("WHERE")
        if wfs:
            conds=[f"{x[0]} {x[1]} {x[2]}" for x in wfs]
            lines.append("WHERE "+" AND ".join(conds))

        gb=self.group_panel.get_group_by()
        if gb:
            lines.append("GROUP BY "+", ".join(gb))

        hv=self.filter_panel.get_filters("HAVING")
        if hv:
            conds=[f"{x[0]} {x[1]} {x[2]}" for x in hv]
            lines.append("HAVING "+" AND ".join(conds))

        ob=self.sort_panel.get_order_bys()
        if ob:
            lines.append("ORDER BY "+", ".join(ob))
        lm=self.sort_panel.get_limit()
        if lm is not None:
            lines.append(f"LIMIT {lm}")
        off=self.sort_panel.get_offset()
        if off is not None:
            lines.append(f"OFFSET {off}")
        return "\n".join(lines)

    def _generate_select_sql_only(self):
        scols=self.get_selected_columns()
        if not scols:
            scols=["*"]
        lines=[]
        lines.append("SELECT "+", ".join(scols))
        lines.append(self._build_bfs_from())
        wfs=self.filter_panel.get_filters("WHERE")
        if wfs:
            conds=[f"{x[0]} {x[1]} {x[2]}" for x in wfs]
            lines.append("WHERE "+" AND ".join(conds))
        return "\n".join(lines)

    def _parse_target_info(self):
        if not self.canvas.target_table_item:
            return (None,None)
        tText=self.canvas.target_table_item.title_text.toPlainText()
        if tText.startswith("Target:"):
            raw=tText.replace("Target:","").strip()
            if "." in raw:
                parts=raw.split(".",1)
                return (parts[0].strip(), parts[1].strip())
        return (None,None)

    def _parse_mapped_columns(self):
        arr=[]
        for ml in self.canvas.mapping_lines:
            arr.append((ml.source_col, ml.target_col))
        return arr

    def _generate_insert(self):
        db,tbl=self._parse_target_info()
        if not db or not tbl:
            return "-- No target => no INSERT"
        mapped=self._parse_mapped_columns()
        if not mapped:
            return "-- No column mapping => no INSERT"
        sub=self._generate_select_sql_only()
        target_cols=[m[1] for m in mapped]
        lines=[
            f"INSERT INTO {db}.{tbl} ({', '.join(target_cols)})",
            sub
        ]
        return "\n".join(lines)

    def _generate_update(self):
        db,tbl=self._parse_target_info()
        if not db or not tbl:
            return "-- No target => no UPDATE"
        mapped=self._parse_mapped_columns()
        if not mapped:
            return "-- No column mapping => no UPDATE"
        sub=self._generate_select_sql_only()
        key_col="key"
        sets=[]
        for (src,tgt) in mapped:
            if tgt.lower()!=key_col:
                sets.append(f"{tgt}=src.{src}")
        lines=[
            f"UPDATE {db}.{tbl}",
            f"SET {', '.join(sets)}",
            "FROM (",
            sub,
            ") AS src",
            f"WHERE {db}.{tbl}.{key_col}=src.{key_col}"
        ]
        return "\n".join(lines)

    def _generate_delete(self):
        db,tbl=self._parse_target_info()
        if not db or not tbl:
            return "-- No target => no DELETE"
        sub=self._generate_select_sql_only()
        key_col="key"
        lines=[
            f"DELETE FROM {db}.{tbl}",
            f"WHERE {key_col} IN (",
            sub,
            ")"
        ]
        return "\n".join(lines)

    def handle_drop(self, full_name, pos):
        if not self.connections:
            if full_name not in self.table_columns_map:
                self.table_columns_map[full_name]=["id","col1","col2"]
        else:
            parts=full_name.split(".")
            if len(parts)>=3:
                alias=parts[0]
                dbn=parts[1]
                tbl=parts[2]
                info=self.connections.get(alias)
                if info:
                    c=info["connection"]
                    dbt=info["db_type"]
                    realCols=load_columns(c,dbt,dbn,tbl)
                    if not realCols:
                        realCols=["id","col1","col2"]
                    self.table_columns_map[full_name]=realCols
            else:
                self.table_columns_map[full_name]=["id","col1","col2"]

        cols=self.table_columns_map[full_name]
        self.canvas.add_table_item(full_name, cols, pos.x(), pos.y())

    def show_cte_as_virtual_table(self, cte_name, columns):
        table_key=f"CTE.{cte_name}"
        if table_key in self.canvas.table_items:
            self.canvas.remove_table_item(table_key)
        if not columns:
            columns=["col1","col2"]
        self.canvas.add_table_item(table_key, columns, 600,100)

    def remove_virtual_cte_table(self, cte_name):
        table_key=f"CTE.{cte_name}"
        self.canvas.remove_table_item(table_key)

    def handle_remove_table(self, table_item):
        for k,v in list(self.canvas.table_items.items()):
            if v==table_item:
                self.canvas.remove_table_item(k)
                break

###############################################################################
# MainVQBWindow => entire VQB app
###############################################################################
class MainVQBWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Merged VQB Federated - BFS, DML, DataProfiler, Advanced ExprBuilder, etc.")
        self.resize(1200,800)

        self.connections={}
        self.linked_server_map={}
        self.builder_tab=VisualQueryBuilderTab(
            multi_connections=self.connections,
            linked_map=self.linked_server_map
        )
        self.setCentralWidget(self.builder_tab)
        self.init_toolbar()

    def init_toolbar(self):
        tb=self.addToolBar("Main Toolbar")

        conn_act=QAction("Connections", self)
        conn_act.triggered.connect(self.on_manage_connections)
        tb.addAction(conn_act)

        fed_act=QAction("Linked Server Config", self)
        fed_act.triggered.connect(self.on_fed_config)
        tb.addAction(fed_act)

        fit_act=QAction("Fit to View", self)
        fit_act.triggered.connect(self.on_fit_view)
        tb.addAction(fit_act)

        layout_act=QAction("Auto-Layout", self)
        layout_act.triggered.connect(self.on_auto_layout)
        tb.addAction(layout_act)

        demo_act=QAction("Demo BFS Map (srcCol1->colA)", self)
        demo_act.triggered.connect(self.demo_map)
        tb.addAction(demo_act)

    def on_manage_connections(self):
        d=MultiODBCConnectDialog(self.connections,self)
        if d.exec_()==QDialog.Accepted:
            self.connections=d.get_connections()
            self.builder_tab.set_connections(self.connections)

    def on_fed_config(self):
        d=LinkedServerConfigDialog(existing_map=self.linked_server_map, parent=self)
        if d.exec_()==QDialog.Accepted:
            newmap=d.get_map()
            self.linked_server_map=newmap
            self.builder_tab.set_federation_map(newmap)
            QMessageBox.information(self,"Linked Config Saved","Cross-DB references are now rewritten accordingly.")

    def on_fit_view(self):
        sc=self.builder_tab.canvas.scene_
        self.builder_tab.canvas.fitInView(sc.itemsBoundingRect(),Qt.KeepAspectRatio)

    def on_auto_layout(self):
        items=list(self.builder_tab.canvas.table_items.values())
        col_count=3
        xsp=250
        ysp=180
        for i,itm in enumerate(items):
            row=i//col_count
            col=i%col_count
            itm.setPos(col*xsp, row*ysp)
        for jl in self.builder_tab.canvas.join_lines:
            jl.update_line()

    def demo_map(self):
        cv=self.builder_tab.canvas
        if not cv.collapsible_bfs_item or not cv.target_table_item:
            QMessageBox.information(
                self,"No BFS or Target",
                "Switch to DML mode (INSERT/UPDATE/DELETE) so BFS/Target placeholders appear."
            )
            return
        left_txt=None
        for ch in cv.collapsible_bfs_item.childItems():
            if isinstance(ch,QGraphicsTextItem):
                if ch.toPlainText().lower()=="srccol1":
                    left_txt=ch
                    break
        right_txt=None
        for ch in cv.target_table_item.childItems():
            if isinstance(ch,QGraphicsTextItem):
                if ch.toPlainText().lower()=="cola":
                    right_txt=ch
                    break
        if not left_txt or not right_txt:
            QMessageBox.information(self,"Not Found","srcCol1 or colA not found in BFS/Target item.")
            return
        cv.create_mapping_line(left_txt, right_txt)

###############################################################################
# main() => run app
###############################################################################
def main():
    app=QApplication(sys.argv)
    apply_fusion_style()
    w=MainVQBWindow()
    w.show()
    sys.exit(app.exec_())

if __name__=="__main__":
    main()